<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Linux 内核开发, CS 宵烛 xiaozhu NightCandle 计算机 网络安全">
    <meta name="description" content="记录 Linux 内核开发相关知识，包括机制解析和源码解读">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Linux 内核开发 | 宵烛 Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/loading.css">
<meta name="generator" content="Hexo 5.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">宵烛 Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">宵烛 Blog</div>
        <div class="logo-desc">
            
            学生 | 虚假CTF选手 | 计算机菜鸟
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/24.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Linux 内核开发</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Linux/">
                                <span class="chip bg-color">Linux</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-19
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-12-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    25.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    109 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="01-编译Linux4-9内核并运行">01 | 编译Linux4.9内核并运行</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel">Linux 源码下载</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/index.html">Kernel Documentation</a></p>
</li>
<li>
<p>Linux内部全景图</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-linux-kernel-map.png" style="zoom:50%;">
</li>
</ul>
<h3 id="内核源码目录">内核源码目录</h3>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-linuxkernel.png" alt="linux内核源码目录"></p>
<ul>
<li>arch：内核支持的CPU体系架构，例如arm/mach-omap1，即ti公司的soc，此soc的cpu核是ARM提供</li>
<li>firmware：固件相关</li>
<li>init：内核启动相关代码
<ul>
<li>main.c：start_kernel() 是C语言代码入口</li>
<li>do_mounts*：内核启动后挂载文件系统</li>
</ul>
</li>
<li>drivers：驱动框架代码，例如i2c，dma， leds</li>
<li>fs：文件系统代码</li>
<li>ipc：进程通讯相关</li>
<li>net：网络协议栈相关</li>
<li>kernel：内核核心代码
<ul>
<li>注意和arm/kernel目录的区别（arm体系相关），kernel目录会调用arm/kernel</li>
</ul>
</li>
<li>sound：声卡相关</li>
<li>crypto：加解密相关</li>
<li>include：内核头文件</li>
<li>lib：通用库</li>
<li>mm：内存管理相关</li>
</ul>
<br>
<h3 id="编译内核">编译内核</h3>
<ol>
<li>
<p>指定硬件体系架构</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要编译arm的内核，则指定ARCH=arm且需要安装交叉编译器</p>
</li>
<li>
<p>配置board config</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> x86_64_defconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>配置内核</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-LinuxConfigurationMenu.png" alt="Linux配置菜单"></p>
<p>这一步是对第2步的菜单进行微调，我们需要内核支持ramdisk驱动，需要选中如下配置：</p>
<pre class="line-numbers language-none"><code class="language-none">General setup  ---&gt;
	[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
Device Drivers  ---&gt;  
	[*] Block devices  ---&gt;
		&lt;*&gt;   RAM block device support
			(65536) Default RAM disk size (kbytes)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>报错</strong>：curses.h：No such file or directory（<code>apt-get install libncurses5-dev libncursesw5-dev</code>）</p>
</li>
<li>
<p>编译内核</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译成功后的内核位于：arch/x86_64/boot/bzImage</p>
<blockquote>
<p><strong>vmlinux</strong>：是内核源码编译出来的原始ELF格式文件，未经压缩。用于kernel-debug，产生system.map符号表，不能用于直接加载，不可以作为启动内核，只是启动过程中的中间媒体</p>
<p><strong>bzImage</strong>：是压缩的内核镜像文件，bz表示"big zImage"，两者的不同之处在于zImage解压缩内核到低端内存（第一个640K），bzImage解压缩内核到高端内存（1M以上）。如果内核比较大应该用bzImage，比zImage有更高的压缩率</p>
</blockquote>
</li>
<li>
<p>交叉编译器</p>
<p>交叉编译工具链的命名规则一般为：<code>$arch [-$vendor] -$os [-[gnu][eabi][hf]]-gcc</code></p>
<ul>
<li>arch：体系架构，不可省略</li>
<li>vendor：工具链提供商，可省略</li>
<li>os：目标操作系统，不可省略</li>
<li>eabi：嵌入式应用二进制接口（Embedded Application Binary Interface），可选的参数包括：
<ul>
<li>abi：二进制应用接口</li>
<li>eabi：嵌入式二进制应用接口，主要针对嵌入式平台</li>
<li>gnu：表示编译器使用gnu glibc库</li>
<li>el：表示使用软浮点处理单元（softfp）</li>
<li>hf：表示使用硬件浮点处理单元（hard）</li>
</ul>
</li>
</ul>
<p>例如：</p>
<ul>
<li>arm-linux-gcc：针对arm的linux的交叉编译器</li>
<li>arm-linux-gnueabi-gcc：针对arm的linux的交叉编译器，使用gnu glibc库</li>
</ul>
</li>
</ol>
<h3 id="编译文件系统">编译文件系统</h3>
<p><a target="_blank" rel="noopener" href="https://busybox.net/downloads/">buysbox源码下载</a></p>
<ol>
<li>
<p>配置buysbox源码</p>
<p>busybox配置为静态编译，busybox在运行的时候就不需要额外的动态链接库</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">Busybox Settings  ---&gt;
   	Build Options  ---&gt;
			[*] Build BusyBox as a static binary (no shared libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>编译和安装</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编译完成后的busybox安装在源码根目录下的_install目录</p>
<p><strong>报错</strong>：stime 函数未定义（<a target="_blank" rel="noopener" href="https://git.busybox.net/busybox/commit/?id=d3539be8f27b8cbfdfee460fe08299158f08bcd9">Remove stime function calls</a>）</p>
</li>
<li>
<p>进入_install目录，补充一些必要的文件或目录</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> etc dev mnt proc sys tmp
<span class="token function">mkdir</span> -p etc/init.d/
<span class="token function">vim</span> etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">proc	/proc	proc	defaults	0	0
tmpfs	/tmp	tmpfs	defaults	0	0
sysfs	/sys	sysfs	defaults	0	0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> etc/init.d/rcS
<span class="token function">chmod</span> <span class="token number">755</span> etc/init.d/rcS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">echo -e "Welcome to tinyLinux"
/bin/mount -a	# 挂载etc/fstab中的文件系统
echo -e "Remounting the root filesystem"
mount  -o  remount,rw  /	# 根文件系统从重新挂载一次
mkdir -p /dev/pts
mount -t devpts devpts /dev/pts
echo /sbin/mdev &gt; /proc/sys/kernel/hotplug	# 处理热插拔
mdev -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> etc/inittab
<span class="token function">chmod</span> <span class="token number">755</span> etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">::sysinit:/etc/init.d/rcS
::respawn:-/bin/sh
::askfirst:-/bin/sh
::ctrlaltdel:/bin/umount -a -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> dev
<span class="token function">mknod</span> console c <span class="token number">5</span> <span class="token number">1</span>
<span class="token function">mknod</span> null c <span class="token number">1</span> <span class="token number">3</span>
<span class="token function">mknod</span> tty1 c <span class="token number">4</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个最小的、完整的可以被内核启动的文件系统就完成了</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/schips/p/12125736.html">BusyBox 添加自定义命令/小程序</a></p>
</li>
</ol>
<h3 id="制作根文件系统镜像文件">制作根文件系统镜像文件</h3>
<ol>
<li>
<p>先制作一个空的镜像文件</p>
</li>
<li>
<p>然后把此镜像文件格式化为ext3格式</p>
</li>
<li>
<p>然后把此镜像文件挂载，并把根文件系统复制到挂载目录</p>
</li>
<li>
<p>卸载该镜像文件</p>
</li>
<li>
<p>打成gzip包</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>
<span class="token function">rm</span> -rf rootfs.ext3
<span class="token function">rm</span> -rf fs
<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>./rootfs.ext3 <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">32</span>
mkfs.ext3 rootfs.ext3
<span class="token function">mkdir</span> fs
<span class="token function">mount</span> -o loop rootfs.ext3 ./fs
<span class="token function">cp</span> -rf ./_install/* ./fs
<span class="token function">umount</span> ./fs
<span class="token function">gzip</span> --best -c rootfs.ext3 <span class="token operator">&gt;</span> rootfs.img.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终生成的文件系统镜像名字为：rootfs.img.gz</p>
</li>
</ol>
<h3 id="启动内核和文件系统">启动内核和文件系统</h3>
<ol>
<li>
<p>安装qemu</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu-system-x86<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>通过qemu模拟器启动编译好的内核和文件系统镜像</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage  -initrd ./busybox-1.30.0/rootfs.img.gz -append <span class="token string">"root=/dev/ram init=/linuxrc"</span> -serial file:output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-qemu.png" alt=""></p>
<blockquote>
<p>qemu取回鼠标 Ctrl + Alt + G</p>
</blockquote>
</li>
</ol>
<h3 id="Linux内核源码编译过程">Linux内核源码编译过程</h3>
<ol>
<li>
<p>顶层Makefile文件</p>
<p>包含体系相关Makefile文件</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRCARCH 	<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span> <span class="token comment">#export ARCH=x86指定</span>
<span class="token keyword">include</span> arch/<span class="token variable">$</span><span class="token punctuation">(</span>SRCARCH<span class="token punctuation">)</span>/Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内核中的子目录，编译系统去子目录下递归地调用Makefile文件</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">init-y		<span class="token operator">:=</span> init/
drivers-y	<span class="token operator">:=</span> drivers/ sound/ firmware/
net-y		<span class="token operator">:=</span> net/
libs-y		<span class="token operator">:=</span> lib/
core-y		<span class="token operator">:=</span> usr/
virt-y		<span class="token operator">:=</span> virt/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>drivers/tty</p>
<p>Kconfig 文件记录了 make menuconfig 时的选项</p>
<p>Makefile 文件是针对 drivers/tty 下所有源码的 Makefile</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_TTY<span class="token punctuation">)</span>		<span class="token operator">+=</span> tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o \
				   tty_buffer.o tty_port.o tty_mutex.o tty_ldsem.o
<span class="token comment">#CONFIG_TTY值对应Kconfig文件中的config TTY</span>
obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_LEGACY_PTYS<span class="token punctuation">)</span>	<span class="token operator">+=</span> pty.o

......

<span class="token comment"># obj-y 表示要编译到内核中,obj-m 表示要编译成驱动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>每个目录编译后会生成一个 built-in.o 文件，是目录下所有 obj-y 下所有 .o 文件的链接文件，这个 built-in.o 文件也会与上层目录的 built-in.o 文件链接在一起</p>
</li>
<li>
<p>编译成完整内核镜像，层层目录返回到顶层目录，所有的 built-in.o 文件会链接生成一个 vmlinux 文件，这个 vmlinux 文件会转换成 vmlinux.bin 并压缩为 vmlinux.bin.gz（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/571078063">vmlinux是如何被编译出来的</a>）</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> KBUILD_LDS          <span class="token operator">:=</span> arch/<span class="token variable">$</span><span class="token punctuation">(</span>SRCARCH<span class="token punctuation">)</span>/kernel/vmlinux.lds
<span class="token comment">#使用的连接脚本，告诉编译器怎么链接成最终的可执行文件</span>

vmlinux-dirs	<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/,%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %/, <span class="token variable">$</span><span class="token punctuation">(</span>init-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>init-m<span class="token punctuation">)</span> \
		     <span class="token variable">$</span><span class="token punctuation">(</span>core-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>core-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-m<span class="token punctuation">)</span> \
		     <span class="token variable">$</span><span class="token punctuation">(</span>net-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>net-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>virt-y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#要链接的源码目录</span>
vmlinux-alldirs	<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">sort</span> <span class="token variable">$</span><span class="token punctuation">(</span>vmlinux-dirs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/,%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %/, \
		     <span class="token variable">$</span><span class="token punctuation">(</span>init-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>core-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>net-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>virt-<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

init-y		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>init-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
core-y		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>core-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
drivers-y	<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>drivers-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
net-y		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>net-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
libs-y1		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/lib.a, <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
libs-y2		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
libs-y		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y1<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y2<span class="token punctuation">)</span>
virt-y		<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>virt-y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#所有目录下的built-in.o</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="02-Linux初始化">02 | Linux初始化</h2>
<h3 id="vmlinuz文件结构">vmlinuz文件结构</h3>
<ul>
<li>
<p>GRUB 会加载 Linux 的内核映像 <code>vmlinuz</code>，初始化内核并移交到内核继续执行</p>
</li>
<li>
<p>/boot 目录下的 vmlinuz 文件由 Linux 编译生成的 bzImage 文件复制而来</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span>
<span class="token symbol">install</span><span class="token punctuation">:</span>
	sh <span class="token variable">$</span><span class="token punctuation">(</span>srctree<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>/install.sh <span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/bzImage \
		System.map <span class="token string">"$(INSTALL_PATH)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>bzImage 需要三个依赖文件：setup.bin、vmlinux.bin、tools目录下build程序</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span>
<span class="token symbol"><span class="token variable">$</span>(obj)/bzImage</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/setup.bin <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.bin <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/tools/build FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,image<span class="token punctuation">)</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>kecho<span class="token punctuation">)</span> <span class="token string">'Kernel: $@ is ready'</span> <span class="token string">' (#'</span>`cat .version`<span class="token string">')'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>build是一个HOST OS下的应用程序，作用是将setup.bin、vmlinux.bin两个文件拼接成一个bzImage文件</p>
</blockquote>
</li>
<li>
<p>setup.bin 文件是由 arch/x86/boot 目录下一系列对应的程序源代码文件编译链接产生</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#目标文件由arch/x86/boot/目录下对应的程序源代码文件编译产生</span>
setup-y		<span class="token operator">+=</span> a20.o bioscall.o cmdline.o copy.o cpu.o cpuflags.o cpucheck.o
<span class="token comment">#……</span>

SETUP_OBJS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/,<span class="token variable">$</span><span class="token punctuation">(</span>setup-y<span class="token punctuation">)</span><span class="token punctuation">)</span>

LDFLAGS_setup.elf	<span class="token operator">:=</span> -m elf_i386 -T
<span class="token symbol"><span class="token variable">$</span>(obj)/setup.elf</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>/setup.ld <span class="token variable">$</span><span class="token punctuation">(</span>SETUP_OBJS<span class="token punctuation">)</span> FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,ld<span class="token punctuation">)</span>

OBJCOPYFLAGS_setup.bin	<span class="token operator">:=</span> -O binary
<span class="token symbol"><span class="token variable">$</span>(obj)/setup.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/setup.elf FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>vmlinux.bin 文件依赖于 arch/x86/boot/compressed 目录下的 vmlinux，vmlinux 则由该目录下的 head_32.o/head_64.o、cpuflags.o 等文件及 piggy.o 链接而成</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span>
OBJCOPYFLAGS_vmlinux.bin <span class="token operator">:=</span> -O binary -R .note -R .comment -S
<span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/compressed/vmlinux FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span>
<span class="token comment">#vmlinux.bin文件依赖于linux/arch/x86/boot/compressed/目录下的vmlinux目标</span>

<span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>
vmlinux-objs-y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.lds <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/head_<span class="token variable">$</span><span class="token punctuation">(</span>BITS<span class="token punctuation">)</span>.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/misc.o \
	<span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/string.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/cmdline.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/error.o \
	<span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/piggy.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/cpuflags.o
<span class="token comment">#……</span>

<span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>vmlinux-objs-y<span class="token punctuation">)</span> FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,check-and-link-vmlinux<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>piggy.o 由 piggy.S 汇编代码生成而来，piggy.S 是编译内核时由 <code>mkpiggy</code> 动态创建，piggy.S 包含了 vmlinux.bin.gz 内核映像文件，还定义了解压时需要的各种信息，包括压缩内核映像的长度、解压后的长度等</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>
quiet_cmd_mkpiggy <span class="token operator">=</span> MKPIGGY <span class="token variable">$@</span>
      cmd_mkpiggy <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/mkpiggy <span class="token variable">$&lt;</span> &gt; <span class="token variable">$@</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">(</span> rm -f <span class="token variable">$@</span> <span class="token punctuation">;</span> false <span class="token punctuation">)</span>

targets <span class="token operator">+=</span> piggy.S
<span class="token symbol"><span class="token variable">$</span>(obj)/piggy.S</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.bin.<span class="token variable">$</span><span class="token punctuation">(</span>suffix-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/mkpiggy FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,mkpiggy<span class="token punctuation">)</span>
<span class="token comment">#suffix-y表示内核压缩方式对应的后缀</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>mkpiggy 是内核自带的一个工具程序，它把输出方式重定向到文件，从而产生 piggy.S 汇编文件</p>
</blockquote>
</li>
<li>
<p>arch/x86/boot/compressed 目录下 vmlinux.bin 是由 objcopy 工具通过最顶层目录下的 vmlinux 生成（去除了文件的符号信息和重定位信息），并将其压缩成 vmlinux.bin.gz</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>
OBJCOPYFLAGS_vmlinux.bin <span class="token operator">:=</span>  -R .comment -S
<span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux.bin</span><span class="token punctuation">:</span> vmlinux FORCE
	<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="内核初始化">内核初始化</h3>
<h4 id="从-start开始">从_start开始</h4>
<ul>
<li>
<p>GRUB 将 vmlinuz 的 setup.bin 部分读到内存地址 <code>0x90000</code> 处，然后跳转到 <code>0x90200</code> 开始执行，跳过了512字节的 bootsector, 从 <code>_start</code> 开始</p>
</li>
<li>
<p>同时 GRUB 将 vmlinuz 的 vmlinux.bin 部分放在1MB（<code>0x100000</code>）开始的内存空间中，setup.bin 中通过 protected_mode_jump 函数跳转进入到 vmlinux.bin</p>
</li>
<li>
<p>setup.bin 文件的入口 _start 在 head.S 文件中定义</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#linux/arch/x86/boot/head.S
	.code16
	.section ".bstext", "ax"
	.global bootsect_start
bootsect_start:
	# Normalize the start address
	ljmp	$BOOTSEG, $start2

start2:
	#……
	# offset 512, entry point

	.globl	_start
_start:
		.byte	0xeb		# short (2-byte) jump
		.byte	start_of_setup-1f	# 跳转start_of_setup-1f
#……
#这里是一个庞大的数据结构，定义了启动时所需的默认参数，与arch/x86/include/uapi/asm/bootparam.h文件中的struct setup_header一一对应

start_of_setup:
# Force %es = %ds
	movw	%ds, %ax
	movw	%ax, %es	# ds = es
	cld					# 主要指定si、di寄存器的自增方向，即si++ di++

	movw	%ss, %dx
	cmpw	%ax, %dx	# %ds == %ss?
	movw	%sp, %dx
	je	2f		# -&gt; assume %sp is reasonably set

	# 如果ss为空则建立新栈
	movw	$_end, %dx
	testb	$CAN_USE_HEAP, loadflags
	jz	1f
	movw	heap_end_ptr, %dx
1:	addw	$STACK_SIZE, %dx
	jnc	2f
	xorw	%dx, %dx	# Prevent wraparound

2:	# Now %dx should point to the end of our stack space
	andw	$~3, %dx	# dword align (might as well...)
	jnz	3f
	movw	$0xfffc, %dx	# Make sure we're not zero
3:	movw	%ax, %ss
	movzwl	%dx, %esp	# Clear upper half of %esp
	sti			# 栈已经初始化好，开中断
	pushw	%ds
	pushw	$6f
	lretw		# cs=ds ip=6：跳转到标号6处
6:

# Check signature at end of setup
	cmpl	$0x5a5aaa55, setup_sig
	jne	setup_bad

# Zero the bss
	movw	$__bss_start, %di
	movw	$_end+3, %cx
	xorl	%eax, %eax
	subw	%di, %cx
	shrw	$2, %cx
	rep; stosl

# Jump to C code (should not return)
	calll	main	# 调用C语言main函数
#……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>硬盘中 MBR 如果是由 GRUB 写入的 boot.img，那么 head.S 中的 bootsector 对于硬盘启动是无用的</p>
</blockquote>
</li>
<li>
<p>setup_header 结构定义在 arch/x86/include/uapi/asm/bootparam.h 文件中，GRUB 会填充这个 setup_header 结构，将内核启动需要的信息写入到对应位置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">setup_header</span> <span class="token punctuation">{</span>
    __u8    setup_sects<span class="token punctuation">;</span>        <span class="token comment">//setup大小</span>
    __u16   root_flags<span class="token punctuation">;</span>         <span class="token comment">//根标志   </span>
    __u32   syssize<span class="token punctuation">;</span>            <span class="token comment">//系统文件大小</span>
    __u16   ram_size<span class="token punctuation">;</span>           <span class="token comment">//内存大小</span>
    __u16   vid_mode<span class="token punctuation">;</span>    
    __u16   root_dev<span class="token punctuation">;</span>           <span class="token comment">//根设备号</span>
    __u16   boot_flag<span class="token punctuation">;</span>          <span class="token comment">//引导标志</span>
    <span class="token comment">//……</span>
    __u32   realmode_swtch<span class="token punctuation">;</span>     <span class="token comment">//切换回实模式的函数地址     </span>
    __u16   start_sys_seg<span class="token punctuation">;</span>    
    __u16   kernel_version<span class="token punctuation">;</span>     <span class="token comment">//内核版本    </span>
    __u8    type_of_loader<span class="token punctuation">;</span>     <span class="token comment">//引导器类型 我们这里是GRUB</span>
    __u8    loadflags<span class="token punctuation">;</span>          <span class="token comment">//加载内核的标志 </span>
    __u16   setup_move_size<span class="token punctuation">;</span>    <span class="token comment">//移动setup的大小</span>
    __u32   code32_start<span class="token punctuation">;</span>       <span class="token comment">//将要跳转到32位模式下的地址 </span>
    __u32   ramdisk_image<span class="token punctuation">;</span>      <span class="token comment">//初始化内存盘映像地址，里面有内核驱动模块 </span>
    __u32   ramdisk_size<span class="token punctuation">;</span>       <span class="token comment">//初始化内存盘映像大小</span>
    <span class="token comment">//……</span>
<span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">Linux/x86 引导协议</a>：引导程序加载内核前确定好数据交换方式叫做引导协议，内核中引导协议相关部分的代码在 arch/x86/boot/header.S 中，内核会在这个文件中标明自己的对齐要求、是否可以重定位以及希望的加载地址等信息，同时也会预留空位，由引导加载程序在加载内核时填充，比如 initramfs 的加载位置和大小等信息</p>
</blockquote>
</li>
</ul>
<h4 id="16位的main函数">16位的main函数</h4>
<ul>
<li>
<p>head.S 中调用的 main 函数在 arch/x86/boot/main.c 文件中定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义boot_params变量</span>
<span class="token keyword">struct</span> <span class="token class-name">boot_params</span> boot_params <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token operator">*</span>HEAP <span class="token operator">=</span> _end<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>heap_end <span class="token operator">=</span> _end<span class="token punctuation">;</span>		<span class="token comment">/* Default end of heap = no heap */</span>

<span class="token comment">//...</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/* First, copy the boot header into the "zeropage" */</span>
    <span class="token comment">/* 将setup_header结构复制到boot_params结构中的hdr变量中 */</span>
	<span class="token function">copy_boot_params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 初始化早期引导所用的console */</span>
	<span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmdline_find_option_bool</span><span class="token punctuation">(</span><span class="token string">"debug"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"early console in setup code\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 初始化堆 */</span>
	<span class="token function">init_heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 检查CPU是否支持运行Linux */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">validate_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Unable to boot - please use a kernel appropriate "</span>
		     <span class="token string">"for your CPU.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* 告诉BIOS我们打算在什么CPU模式下运行它 */</span>
	<span class="token function">set_bios_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 查看物理内存空间布局 */</span>
	<span class="token function">detect_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 初始化键盘 */</span>
	<span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* Query Intel SpeedStep (IST) information */</span>
	<span class="token function">query_ist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 查询APM BIOS电源管理信息 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_APM<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_APM_MODULE<span class="token punctuation">)</span></span></span>
	<span class="token function">query_apm_bios</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

	<span class="token comment">/* 查询EDD BIOS扩展数据区域的信息 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_EDD<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_EDD_MODULE<span class="token punctuation">)</span></span></span>
	<span class="token function">query_edd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

	<span class="token comment">/* 设置显卡的图形模式 */</span>
	<span class="token function">set_video</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 进入CPU保护模式，不会返回 */</span>
	<span class="token function">go_to_protected_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//go_to_protected_mode -&gt; protected_mode_jump(pmjump.S)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>切换CPU到保护模式后跳入 vmlinux.bin 文件中的 startup_32 函数重新加载段描述符，如果是64位的系统，就要进入 startup_64 函数，切换到CPU到长模式，最后调用 extract_kernel 函数解压内核，并进入内核 startup_64 函数，由此Linux内核开始运行</p>
</blockquote>
</li>
</ul>
<h4 id="startup-32函数">startup_32函数</h4>
<ul>
<li>
<p>定义在 arch/x86/boot/compressed/head64.S<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</li>
<li>
<p>使用 grub 程序引导实际是从 startup_32 开始而不是 startup_64</p>
</li>
<li>
<p>startup_32 中需要重新加载段描述符，然后是栈的建立和检测CPU是否支持长模式</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">	__HEAD
	.code32
ENTRY(startup_32)
	
	cld
	/*
	 * 检查 KEEP_SEGMENTS 标记（loadflags）
	 * 如果在设置了 KEEP_SEGMENTS 就跳转到最近的 1f 标签，当没有 1f 标签，则用 __BOOT_DS 更新段寄存器
	 * 如果没有设置，需要重置 ds , ss 和 es 段寄存器到一个基地址为 0 的普通段中
	 */
	testb $KEEP_SEGMENTS, BP_loadflags(%esi)
	jnz 1f

	cli
	movl	$(__BOOT_DS), %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%eax, %ss
1:
	/* 确定 startup_32 的地址 */
	/* bootparams 结构体包含一个特殊字段 scratch，将其作为 call 指令的临时栈 */
	leal	(BP_scratch+4)(%esi), %esp
	call	1f
1:	popl	%ebp	/* 跳转到 1f 标签并且把该标签的地址放入 ebp 寄存器 */
	subl	$1b, %ebp	/* 用标签的地址减去偏移地址可得 startup_32 地址 */

/* setup a stack and make sure cpu supports long mode. */
	movl	$boot_stack_end, %eax	/* eax = 0x0 + boot_stack_end */
	addl	%ebp, %eax	/* eax = startup_32 + boot_stack_end */
	movl	%eax, %esp

	call	verify_cpu
	testl	%eax, %eax	/* 如果 eax 的值为可以继续 */
	jnz	no_longmode
	
	#......
ENDPROC(startup_32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>计算重定位地址，即计算解压缩之后的地址</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/*
 * Compute the delta between where we were compiled to run at
 * and where the code will actually run at.
 */

#ifdef CONFIG_RELOCATABLE
	movl	%ebp, %ebx	/* ebp 是 startup_32 标签的物理地址 */
	movl	BP_kernel_alignment(%esi), %eax
	decl	%eax
	addl	%eax, %ebx
	notl	%eax
	andl	%eax, %ebx
	cmpl	$LOAD_PHYSICAL_ADDR, %ebx	/* 对齐后与 LOAD_PHYSICAL_ADDR 的值进行比较 */
	jae	1f
#endif
	movl	$LOAD_PHYSICAL_ADDR, %ebx
1:

	/* Target address to relocate to for decompression */
	movl	BP_init_size(%esi), %eax
	subl	$_end, %eax
	addl	%eax, %ebx	/* ebx 包含应临时移动内核映像的地址 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>内核重定位的意义：默认的内核基地址由内核配置项 <code>CONFIG_PHYSICAL_START</code> 的值所确定，其默认值为 <code>0x1000000</code> 或 <code>16 MB</code> ，如果内核崩溃了，内核开发者需要一个配置于不同地址加载的 <code>救援内核</code> 来进行 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">kdump</a>，Linux 内核提供了特殊的配置选项以解决此问题：<code>CONFIG_RELOCATABLE</code>，设置此选项的内核可以从不同的地址启动</p>
</blockquote>
</li>
<li>
<p>如果CPU支持长模式，需要设置64位的全局描述表，开启CPU的PAE物理地址扩展特性，再设置最初的MMU页表，最后开启分页并进入长模式，跳转到 <code>startup_64</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/*
 * Prepare for entering 64 bit mode
 */
	/* 更新GDT */
	/* Load new GDT with the 64bit segments using 32bit descriptor */
	leal	gdt(%ebp), %eax
	movl	%eax, gdt+2(%ebp)
	lgdt	gdt(%ebp)

	/* Enable PAE mode */
	movl	%cr4, %eax
	orl	$X86_CR4_PAE, %eax
	movl	%eax, %cr4

 /*
  * Build early 4G boot pagetable
  */
	/* Initialize Page tables to 0 */
	leal	pgtable(%ebx), %edi
	xorl	%eax, %eax
	movl	$(BOOT_INIT_PGT_SIZE/4), %ecx
	rep	stosl

	/* Build Level 4 */
	leal	pgtable + 0(%ebx), %edi
	leal	0x1007 (%edi), %eax
	movl	%eax, 0(%edi)

	/* Build Level 3 */
	leal	pgtable + 0x1000(%ebx), %edi
	leal	0x1007(%edi), %eax
	movl	$4, %ecx
1:	movl	%eax, 0x00(%edi)
	addl	$0x00001000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b

	/* Build Level 2 */
	leal	pgtable + 0x2000(%ebx), %edi
	movl	$0x00000183, %eax
	movl	$2048, %ecx
1:	movl	%eax, 0(%edi)
	addl	$0x00200000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b

	/* Enable the boot page tables */
	leal	pgtable(%ebx), %eax
	movl	%eax, %cr3

	/* Enable Long mode in EFER (Extended Feature Enable Register) */
	movl	$MSR_EFER, %ecx
	rdmsr
	btsl	$_EFER_LME, %eax
	wrmsr

	/* After gdt is loaded */
	xorl	%eax, %eax
	lldt	%ax
	movl    $__BOOT_TSS, %eax
	ltr	%ax

	/*
	 * Setup for the jump to 64bit mode
	 */
	pushl	$__KERNEL_CS	/* 将内核段代码地址入栈 */
	leal	startup_64(%ebp), %eax	/* 将 startup_64 的地址导入 eax */
	#......
	pushl	%eax	/* 入栈 */

	/* Enter paged protected Mode, activating Long Mode */
	movl	$(X86_CR0_PG | X86_CR0_PE), %eax /* Enable Paging and Protected mode */
	movl	%eax, %cr0

	/* Jump from 32bit compatibility mode into 64bit mode. */
	lret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在 <code>lret</code> 指令之后，CPU 取出了之前入栈的 <code>startup_64</code> 地址跳转到那里</p>
</blockquote>
</li>
</ul>
<h4 id="startup-64函数">startup_64函数</h4>
<ul>
<li>
<p>定义在 arch/x86/boot/compressed/head64.S<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</li>
<li>
<p>初始化长模式下数据段寄存器，确定最终解压缩地址，初始化栈</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">	.code64
	.org 0x200
ENTRY(startup_64)
	#......

	/* Setup data segments. */
	xorl	%eax, %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%eax, %ss
	movl	%eax, %fs
	movl	%eax, %gs

	/* 计算内核编译时的位置和它被加载的位置的差 */
#ifdef CONFIG_RELOCATABLE
	leaq	startup_32(%rip) /* - $startup_32 */, %rbp	/* rbp 包含 startup_32 物理地址 */
	movl	BP_kernel_alignment(%rsi), %eax
	decl	%eax
	addq	%rax, %rbp
	notq	%rax
	andq	%rax, %rbp
	cmpq	$LOAD_PHYSICAL_ADDR, %rbp
	jae	1f
#endif
	movq	$LOAD_PHYSICAL_ADDR, %rbp
1:
	/* Target address to relocate to for decompression */
	movl	BP_init_size(%rsi), %ebx
	subl	$_end, %ebx
	addq	%rbp, %rbx	/* rbx 包含内核代码重定位以进行解压缩的地址 */
	
	/* 栈指针的设置 */
	leaq	boot_stack_end(%rbx), %rsp
	/* 标志寄存器的重置 */
	pushq	$0
	popfq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>拷贝压缩的内核到解压地址并跳转到解压代码处</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/*
 * 复制压缩的内核到解压了的内核重定位地址
 */
	pushq	%rsi	/* 保存rsi的值，存放指向boot_params的指针 */
	/* 压缩的内核映像位于当前代码和解压缩代码之间，将bss段之前的都拷贝到新的位置 */
	leaq	(_bss-8)(%rip), %rsi
	leaq	(_bss-8)(%rbx), %rdi
	movq	$_bss /* - $startup_32 */, %rcx	
	shrq	$3, %rcx
	std
	rep	movsq	/* 每次8字节地从 rsi 到 rdi 复制代码 */
	cld	/* 清除DF标志 */
	popq	%rsi

/*
 * 跳转到重定位后的地址
 */
	leaq	relocated(%rbx), %rax	/* 有.text节的重定位后的地址 */
	jmp	*%rax

	.text
relocated:
	#......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>内核解压</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/*
 * Do the extraction, and jump to the new kernel..
 */
	pushq	%rsi			/* Save the real mode argument */
	movq	%rsi, %rdi		/* real mode address */
	leaq	boot_heap(%rip), %rsi	/* malloc area for uncompression */
	leaq	input_data(%rip), %rdx  /* input_data */
	movl	$z_input_len, %ecx	/* input_len */
	movq	%rbp, %r8		/* output target address */
	movq	$z_output_len, %r9	/* decompressed length, end of relocs */
	call	extract_kernel		/* returns kernel location in %rax */
	popq	%rsi

/*
 * Jump to the decompressed kernel.
 */
	jmp	*%rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>最后一条指令 <code>jmp *rax</code> 中的 rax 保存就是 extract_kernel 函数返回的入口点，就是从这里开始进入了 Linux 内核</p>
</blockquote>
</li>
</ul>
<h4 id="extract-kernel函数">extract_kernel函数</h4>
<ul>
<li>
<p>在 linux/arch/x86/boot/compressed/misc.c 文件中定义，解压内核的函数，根据 piggy.o 中的信息从 vmlinux.bin.gz 中解压出 vmlinux 并解析elf格式</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extract_kernel</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>rmode<span class="token punctuation">,</span> memptr heap<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>input_data<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> input_len<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>output<span class="token punctuation">,</span>
				  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> output_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> kernel_total_size <span class="token operator">=</span> VO__end <span class="token operator">-</span> VO__text<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> virt_addr <span class="token operator">=</span> LOAD_PHYSICAL_ADDR<span class="token punctuation">;</span>

	<span class="token comment">//......</span>
	<span class="token function">debug_putstr</span><span class="token punctuation">(</span><span class="token string">"\nDecompressing Linux... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用具体的解压缩算法解压</span>
	<span class="token function">__decompress</span><span class="token punctuation">(</span>input_data<span class="token punctuation">,</span> input_len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> output_len<span class="token punctuation">,</span>
			<span class="token constant">NULL</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//解压出的vmlinux是elf格式，解析出里面的指令数据段和常规数据段</span>
    <span class="token comment">//返回内核程序的开始地址</span>
    <span class="token function">parse_elf</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//只有在启用了CONFIG_RANDOMIZE_BASE配置选项才会调用，函数会调整内核镜像的地址</span>
	<span class="token function">handle_relocations</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> output_len<span class="token punctuation">,</span> virt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">debug_putstr</span><span class="token punctuation">(</span><span class="token string">"done.\nBooting the kernel.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="进入Linux内核">进入Linux内核</h3>
<h4 id="Linux内核的startup-64">Linux内核的startup_64</h4>
<ul>
<li>
<p>startup_64 函数定义在 linux/arch/x86/kernel/head_64.S 文件中，它是<strong>内核的入口函数</strong></p>
</li>
<li>
<p>内核执行的第一步，完成了一些初步的检查</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">	__HEAD
	.code64
	.globl startup_64
startup_64:
	#......

	/*
	 * 计算内核的物理基址与实际加载地址的差，0 代表内核被加载到了默认地址
	 */
	leaq	_text(%rip), %rbp
	subq	$_text - __START_KERNEL_map, %rbp

	/* 检查这个地址是否已经正确对齐 */
	testl	$~PMD_PAGE_MASK, %ebp
	jnz	bad_address

	/*
	 * 检查高 18 位来防止这个地址过大
	 */
	leaq	_text(%rip), %rax
	shrq	$MAX_PHYSMEM_BITS, %rax
	jnz	bad_address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>修正页表基地址</p>
</li>
<li>
<p>Identity Map Paging</p>
</li>
<li>
<p>secondary_startup_64</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ENTRY(secondary_startup_64)
	#......
1:
	/* Enable PAE and PSE, but defer PGE until kaiser_enabled is decided */
	movl	$(X86_CR4_PAE | X86_CR4_PSE), %ecx
	movq	%rcx, %cr4

	/* Setup early boot stage 4 level pagetables. */
	addq	phys_base(%rip), %rax
	movq	%rax, %cr3
	#......
	
	/* 跳转到C语言代码 */
	movq	initial_code(%rip),%rax	# initial_code 包含 x86_64_start_kernel 的地址
	pushq	$0		# fake return address to stop unwinder
	pushq	$__KERNEL_CS	# set correct cs
	pushq	%rax		# target address in negative space
	lretq
ENDPROC(secondary_startup_64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>SMP系统加电之后，总线仲裁机制会选出多个CPU中的一个，称为BSP，BSP CPU先启动，其它CPU则等待BSP CPU的唤醒，对于第一个启动的CPU，会跳转 secondary_startup_64 函数中1标号处，对于其它被唤醒的CPU则会直接执行 secondary_startup_64 函数</p>
</blockquote>
</li>
</ul>
<h4 id="Linux内核的第一个C函数">Linux内核的第一个C函数</h4>
<ul>
<li>
<p><strong>x86_64_start_kernel</strong> 在 arch/x86/kernel/head64.c 文件中定义，函数接受一个参数 real_mode_data（bootparam 结构的地址），之前保存到了 rdi 寄存器中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __init <span class="token function">x86_64_start_kernel</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> real_mode_data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * 检查
	 */</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&lt;</span> __START_KERNEL_map<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">&lt;</span> KERNEL_IMAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_LEN <span class="token operator">+</span> KERNEL_IMAGE_SIZE <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token operator">*</span>PUD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__START_KERNEL_map <span class="token operator">&amp;</span> <span class="token operator">~</span>PMD_MASK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&amp;</span> <span class="token operator">~</span>PMD_MASK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&gt;</span> __START_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MODULES_END <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span> <span class="token operator">==</span>
				<span class="token punctuation">(</span>__START_KERNEL <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">__fix_to_virt</span><span class="token punctuation">(</span>__end_of_fixed_addresses<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> MODULES_END<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">cr4_init_shadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* Kill off the identity-map trampoline */</span>
	<span class="token function">reset_early_page_tables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//重新设置早期页表</span>

	<span class="token function">clear_bss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//清理BSS段</span>

	<span class="token function">clear_page</span><span class="token punctuation">(</span>init_level4_pgt<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//清理之前的顶层页目录</span>

	<span class="token function">kasan_early_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//设置并加载 IDT</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_EXCEPTION_VECTORS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token function">set_intr_gate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> early_idt_handler_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">load_idt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">desc_ptr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>idt_descr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">copy_bootdata</span><span class="token punctuation">(</span><span class="token function">__va</span><span class="token punctuation">(</span>real_mode_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//复制引导信息</span>

	<span class="token comment">/*
	 * Load microcode early on BSP.
	 */</span>
	<span class="token function">load_ucode_bsp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//加载BSP CPU的微码</span>

	<span class="token comment">/* set init_level4_pgt kernel high mapping*/</span>
	init_level4_pgt<span class="token punctuation">[</span><span class="token number">511</span><span class="token punctuation">]</span> <span class="token operator">=</span> early_level4_pgt<span class="token punctuation">[</span><span class="token number">511</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//让顶层页目录指向重新设置早期页表</span>

	<span class="token function">x86_64_start_reservations</span><span class="token punctuation">(</span>real_mode_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> __init <span class="token function">x86_64_start_reservations</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>real_mode_data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">//......</span>

	<span class="token function">start_kernel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="start-kernel函数">start_kernel函数</h4>
<ul>
<li>
<p>start_kernel 函数定义在 init/main.c 文件，其中调用了大量 Linux 内核功能的初始化函数：ARCH、日志、陷阱门、内存、调度器、工作队列、RCU锁、Trace事件、IRQ中断、定时器、软中断、ACPI、fork、缓存、安全、pagecache、信号量、cpuset、cgroup等等</p>
</li>
<li>
<p>start_kernel 函数执行完成，内核就具备了向应用程序提供一系列功能服务的能力</p>
</li>
<li>
<p>最后调用 rest_init()，重要功能是建立了两个内核线程<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，Linux 内核线程可以执行一个内核函数， 只不过这个函数有独立的线程上下文，可以被Linux的进程调度器调度，对于 kernel_init 线程来说，执行的就是 kernel_init 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __ref <span class="token function">rest_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> pid<span class="token punctuation">;</span>

    <span class="token comment">//建立 kernel_init 线程，pid=1（kernel_thread 调用 _do_fork 创建进程）</span>
	<span class="token function">kernel_thread</span><span class="token punctuation">(</span>kernel_init<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//建立 khreadd 线程，pid=2，负责所有内核线程的调度和管理</span>
    pid <span class="token operator">=</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>kthreadd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//......</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="Linux的第一个用户进程">Linux的第一个用户进程</h3>
<ul>
<li>
<p>Linux 内核的第一个用户态进程是在 kernel_init 线程建立的，kernel_init 线程执行的就是 <code>kernel_init</code> 函数</p>
</li>
<li>
<p>根据内核启动参数，调用 run_init_process 创建对应进程</p>
</li>
<li>
<p>调用 try_to_run_init_process 函数，尝试以 /sbin/init、/etc/init、/bin/init、/bin/sh 这些文件为可执行文件建立 init 进程，只要其中之一成功就可以，当从系统调用返回用户态时，init进程（1号进程）就从 ELF 执行了</p>
</li>
</ul>
<ol>
<li></li>
</ol>
<ol>
<li></li>
</ol>
<h2 id="03-Linux同步机制">03 | Linux同步机制</h2>
<h3 id="概述-6">概述</h3>
<h4 id="场景及解决">场景及解决</h4>
<ul>
<li>
<p>场景：在驱动程序中，有些设备只允许打开一次</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> xxx_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//驱动中的全局变量，表示打开的标志</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>xxx_count<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span> <span class="token comment">//打开失败</span>
    <span class="token punctuation">}</span>
    <span class="token operator">++</span> xxx_count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//打开成功</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>假如一个进程A先对此设备调用open，另一个进程B也对此设备调用open，若调度如下，A和B两个进程都可以成功打开驱动</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-sample.png" alt=""></p>
</li>
<li>
<p>并发执行的单元对共享资源的同时访问会引发竞态问题，解决途径是保证对共享资源的<strong>互斥访问</strong>，访问共享资源的代码区块叫做临界区</p>
</li>
<li>
<p>要解决上述场景中的问题，有这样两种思路：一种是使用<strong>原子操作</strong>，这里的原子是不可分隔的，要么不执行，要么执行完；另一种是<strong>控制中断</strong>，在执行之前关中断，执行完之后开中断</p>
</li>
<li>
<p>原子操作，在只有<strong>单个变量全局数据</strong>的情况下非常实用，如全局计数器、状态标志变量等</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"lock;"</span> <span class="token string">"addl %1,%0"</span>
                     <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span>
                     <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//"lock;" "addl %1,%0" 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 </span>
<span class="token comment">//: "+m" (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联</span>
<span class="token comment">//: "ir" (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>中断控制搞定复杂变量</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> u32_t cpuflg_t<span class="token punctuation">;</span>
<span class="token comment">//关闭中断</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_save_flags_cli</span><span class="token punctuation">(</span>cpuflg_t<span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
            <span class="token string">"pushfl \t\n"</span> <span class="token comment">//把eflags寄存器压入当前栈顶</span>
            <span class="token string">"cli    \t\n"</span> <span class="token comment">//关闭中断</span>
            <span class="token string">"popl %0 \t\n"</span><span class="token comment">//把当前栈顶弹出到flags为地址的内存中        </span>
            <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>
            <span class="token operator">:</span>
            <span class="token operator">:</span> <span class="token string">"memory"</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//开启中断</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_restore_flags_sti</span><span class="token punctuation">(</span>cpuflg_t<span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
            <span class="token string">"pushl %0 \t\n"</span><span class="token comment">//把flags为地址处的值寄存器压入当前栈顶</span>
            <span class="token string">"popfl \t\n"</span>   <span class="token comment">//把当前栈顶弹出到flags寄存器中</span>
            <span class="token operator">:</span>
            <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token string">"memory"</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>自旋锁</p>
<ul>
<li>在多核心 CPU 上通过控制中断来维护全局数据安全的方案失效了，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地CPU的中断，无法控制其它CPU核心的中断</li>
<li>自旋锁同步机制：若自旋锁已被别的执行者保持，调用者就会原地循环等待并检查该锁的持有者是否已经释放锁（即进入自旋状态），若释放则调用者开始持有该锁</li>
<li>自旋锁必须保证<strong>读取锁变量和判断并加锁的操作是原子执行的</strong>（CAS），x86 CPU提供原子交换指令<code>xchg</code>，可以让寄存器中的一个值与内存空间中的一个值交换</li>
</ul>
</li>
<li>
<p>信号量</p>
<ul>
<li>自旋锁都不适合长时间等待的情况，会导致CPU忙等待</li>
<li>信号量是1965年荷兰学者<em>Edsger Dijkstra</em>提出的，是一种用于资源互斥或者进程间同步的机制，信号量既能对资源数据进行保护，又能在资源无法满足的情况下让CPU可以执行其它任务，同时解决了<strong>等待、互斥、唤醒</strong>三个问题</li>
</ul>
</li>
</ul>
<h4 id="Linux内核同步机制">Linux内核同步机制</h4>
<ul>
<li>
<p>原子操作</p>
</li>
<li>
<p>控制中断</p>
</li>
<li>
<p>信号量（semaphore）</p>
</li>
<li>
<p>读写信号量（rw_semaphore）</p>
</li>
<li>
<p>spinlock</p>
</li>
<li>
<p>mutex</p>
</li>
<li>
<p>BKL（Big Kernel Lock，只在2.4内核中）</p>
</li>
<li>
<p>rwlock</p>
</li>
<li>
<p>brlock（只在2.4内核中）</p>
</li>
<li>
<p>RCU（2.6及以后的版本中）</p>
</li>
<li>
<p>seqlock（2.6及以后的版本中）</p>
</li>
<li>
<p>qspinlock</p>
<p>…<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
</li>
</ul>
<br>
<h3 id="atomic">atomic</h3>
<h4 id="使用">使用</h4>
<ul>
<li>
<p>原子操作指执行结束前不可打断的操作，是最小的执行单位</p>
</li>
<li>
<p>原子变量 atomic 适用于针对 int 变量进行同步的场景</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">static</span> atomic_t can_open <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/**
结构体:
typedef struct {
	int counter; //常用的32位的原子变量类型
} atomic_t;
初始化:
#define ATOMIC_INIT(i)	{ (i) }
**/</span>

<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">atomic_dec_and_test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"dev is busy, hello_open fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">hello_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>flip<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>API：以ARM平台为例</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-arm-atomic-api.png" alt=""></p>
</li>
</ul>
<h4 id="atomic内核源码">atomic内核源码</h4>
<ul>
<li>
<p>原子操作与硬件架构强相关</p>
</li>
<li>
<p>x86</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//原子读取变量中的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">int</span> <span class="token function">arch_atomic_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">__READ_ONCE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子写入一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_set</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">__WRITE_ONCE</span><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加上一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"addl %1,%0"</span>
             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>
             <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减去一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"subl %1,%0"</span>
             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>
             <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加1</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_inc</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"incl %0"</span>
             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减1</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_dec</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"decl %0"</span>
             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ol>
<li>
<p><code>LOCK_PREFIX</code>是一个宏，根据需要展开成<code>“lock;”</code>或空串，单核心CPU是不需要lock前缀的，只要在多核心CPU下才需要加上lock前缀</p>
</li>
<li>
<p><code>__READ_ONCE</code>，<code>__WRITE_ONCE</code>两个宏是对代码封装并利用GCC的特性对代码进行检查，把让错误显现在编译阶段</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>ARM体系</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ATOMIC_OP</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> c_op<span class="token punctuation">,</span> asm_op<span class="token punctuation">)</span>					</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> atomic_</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">op</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span>			</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">{</span>									</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> tmp<span class="token punctuation">;</span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">int</span> result<span class="token punctuation">;</span>							</span><span class="token punctuation">\</span>
									<span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">prefetchw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>						</span><span class="token punctuation">\</span>
	<span class="token expression">__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span></span><span class="token string">"@ atomic_"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">op</span> </span></span><span class="token string">"\n"</span>			<span class="token punctuation">\</span>
<span class="token string">"1:	ldrex	%0, [%3]\n"</span>						<span class="token punctuation">\</span>
<span class="token string">"	"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">asm</span><span class="token expression">_op </span></span></span><span class="token string">"	%0, %0, %4\n"</span>					<span class="token punctuation">\</span>
<span class="token string">"	strex	%1, %0, [%3]\n"</span>						<span class="token punctuation">\</span>
<span class="token string">"	teq	%1, #0\n"</span>						<span class="token punctuation">\</span>
<span class="token string">"	bne	1b"</span>							<span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=&amp;r"</span> <span class="token expression"><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"=&amp;r"</span> <span class="token expression"><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"+Qo"</span> <span class="token expression"><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>		</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">:</span> </span><span class="token string">"r"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"Ir"</span> <span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span>					</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token operator">:</span> </span><span class="token string">"cc"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>							</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">}</span>									</span></span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ol>
<li>原子操作的原子性依赖于<code>ldrex</code>与<code>strex</code>实现</li>
<li><code>ldrex</code>读取数据时会进行独占标记，防止其他内核路径访问，直至调用<code>strex</code>完成写入后清除标记</li>
<li><code>strex</code>也不能写入被别的内核路径独占的内存，若是写入失败则循环至成功写入</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="Linux控制中断">Linux控制中断</h3>
<ul>
<li>
<p>Linux中有很多场景需要在关中断下才可以安全执行一些操作</p>
<ul>
<li>
<p>多个中断处理程序需要访问一些共享数据，一个中断程序在访问数据时必须保证自身和其它中断处理程序互斥</p>
</li>
<li>
<p>设备驱动程序在设置设备寄存器时必须让CPU停止响应中断</p>
</li>
</ul>
</li>
<li>
<p>Linux控制CPU响应中断的函数（<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.13/source/include/linux/irqflags.h#L186">参阅相关代码</a>）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//实际保存eflags寄存器</span>
<span class="token keyword">extern</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"# __raw_save_flags\n\t"</span>
                 <span class="token string">"pushf ; pop %0"</span><span class="token operator">:</span><span class="token string">"=rm"</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">::</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际恢复eflags寄存器</span>
<span class="token keyword">extern</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">native_restore_fl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"push %0 ; popf"</span><span class="token operator">::</span><span class="token string">"g"</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"cli"</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际开启中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"sti"</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层开启中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层保存eflags寄存器</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层恢复eflags寄存器</span>
<span class="token keyword">static</span>  __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">native_restore_fl</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际保存eflags寄存器并关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//raw层关闭开启中断宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//raw层保存恢复eflags寄存器宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>           </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_save_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//通用层接口宏 </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">raw_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">raw_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>               </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">raw_local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">raw_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>编译Linux代码时，编译器自动对宏进行展开，其中，<code>do{}while(0)</code>是Linux代码中一种常用的技巧，可以保证大括号中的代码片段执行一次，保证宏展开时这个代码片段是一个整体</p>
</blockquote>
</li>
</ul>
<br>
<h3 id="spinlock">spinlock</h3>
<ul>
<li>
<p>Linux原始的自旋锁（wild spinlock）本质上用一个整数来表示，1代表锁未被占用，0或者负表示被占用，但是等锁者之间的公平性无法获得保证<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
</li>
<li>
<p>Linux内核 2.6.25 版本引入了排队自旋锁（ticket spinlock）解决获取自旋锁的公平性</p>
<blockquote>
<p>spinlock的公平性：先到先唤醒，后到后唤醒，只有next域与owner域相等时，才表示自旋锁处于未使用的状态，Linux进程执行申请自旋锁时，原子地将next域加1，进程释放自旋锁时，原子地将owner域加1</p>
<ol>
<li>初始化时owner = next = 0，第一个thread获取spinlock可获取成功</li>
<li>第二个thread获取spinlock，如果第一个thread还没有释放锁，则next ++</li>
<li>第三个thread获取spinlock，如果第一个thread还没有释放锁，则next = 2</li>
<li>此时第一个thread释放spinlock，则执行owner ++，owner = 1</li>
<li>此时虽然第二个和第三个thread都在等待锁，但因为第二个thread的owner = next，可以获取锁，第三个thread继续等待</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="使用-2">使用</h4>
<ul>
<li>
<p>使用示例</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c">spinlock_t count_lock<span class="token punctuation">;</span>
<span class="token keyword">int</span> open_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    open_count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    
<span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>spin_lock basic API</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-spinlock-api.png" alt=""></p>
</li>
<li>
<p>spin_lock API &amp; irq</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-spinlock-api-irq.png" alt=""></p>
<blockquote>
<p>性能上：spin_lock &gt; spin_lock_bh &gt; spin_lock_irq &gt; spin_lock_irqsave</p>
<p>安全上：spin_lock_irqsave &gt; spin_lock_irq &gt; spin_lock_bh &gt;spin_lock</p>
</blockquote>
</li>
</ul>
<h4 id="spinlock内核源码">spinlock内核源码</h4>
<ul>
<li>
<p>spinlock源码与体系相关，数据结构如下（ARM）<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// spinlock -&gt; raw_spinlock（有硬实时补丁也不能睡眠） -&gt; arch_spinlock_t</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">union</span> <span class="token punctuation">{</span>
		u32 slock<span class="token punctuation">;</span>
		<span class="token keyword">struct</span> <span class="token class-name">__raw_tickets</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__ARMEB__ </span><span class="token comment">//大端</span></span>
			u16 next<span class="token punctuation">;</span>  <span class="token comment">//owner表示持有这个数字的thread可以获取自旋锁</span>
			u16 owner<span class="token punctuation">;</span> <span class="token comment">//next表示如果后续再有thread请求获取这个自旋锁就给它分配这个数字</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
			u16 owner<span class="token punctuation">;</span>
			u16 next<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
		<span class="token punctuation">}</span> tickets<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> arch_spinlock_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>初始化</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//spin_lock_init -&gt; raw_spin_lock_init -&gt; __RAW_SPIN_LOCK_UNLOCKED -&gt; __RAW_SPIN_LOCK_INITIALIZER -&gt; __ARCH_SPIN_LOCK_UNLOCKED</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ARCH_SPIN_LOCK_UNLOCKED	<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	u32 lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span> arch_rwlock_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>spin_lock（）</p>
<p>UP：如果内核不允许抢占，spin_lock是个空函数，如果内核允许抢占，spin_lock只是禁止抢占</p>
<p>SMP：spin_lock除了禁止抢占，还会调用体系相关代码实现排他性loop</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//UP：单核CPU</span>
<span class="token comment">//spin_lock -&gt; raw_spin_lock(_raw_spin_lock) -&gt; __LOCK(lock)</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">___LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> </span><span class="token comment">//抢占关闭</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">___LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token function">__acquire</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token comment">//SMP：多核</span>
<span class="token comment">//spin_lock -&gt; raw_spin_lock(_raw_spin_lock) -&gt; __raw_spin_lock -&gt; __raw_spin_lock</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__raw_spin_lock</span><span class="token punctuation">(</span>raw_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 禁止抢占</span>
	<span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// for debug</span>
	<span class="token function">spin_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>dep_map<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// real work done here（do_raw_spin_lock(lock)）</span>
	<span class="token function">LOCK_CONTENDED</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> do_raw_spin_trylock<span class="token punctuation">,</span> do_raw_spin_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">LOCK_CONTENDED</span><span class="token punctuation">(</span>_lock<span class="token punctuation">,</span> try<span class="token punctuation">,</span> lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token function">lock</span><span class="token punctuation">(</span>_lock<span class="token punctuation">)</span></span></span>

<span class="token keyword">void</span> <span class="token function">do_raw_spin_lock</span><span class="token punctuation">(</span>raw_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">debug_spin_lock_before</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">arch_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>raw_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">debug_spin_lock_after</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_spin_lock</span><span class="token punctuation">(</span>arch_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> tmp<span class="token punctuation">;</span>
	u32 newval<span class="token punctuation">;</span>
	arch_spinlock_t lockval<span class="token punctuation">;</span>

	<span class="token function">prefetchw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
<span class="token string">"1:	ldrex	%0, [%3]\n"</span>
<span class="token string">"	add	%1, %0, %4\n"</span>
<span class="token string">"	strex	%2, %1, [%3]\n"</span>
<span class="token string">"	teq	%2, #0\n"</span>
<span class="token string">"	bne	1b"</span>
	<span class="token operator">:</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>lockval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>newval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"r"</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"I"</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> TICKET_SHIFT<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>next <span class="token operator">!=</span> lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>owner<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">wfe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进入一小段时间等待状态，忙等但尽量让cpu进去low power mode</span>
        <span class="token comment">//参考：https://www.cnblogs.com/sky-heaven/p/12926376.html</span>
        
		lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>owner <span class="token operator">=</span> <span class="token function">ACCESS_ONCE</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>tickets<span class="token punctuation">.</span>owner<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ol>
<li>由于slock与tickets共享同一块内存（union），slock占32位4字节，tickets内部变量next与owner各16位2字节，以大端序为例，slock 高2字节与next共享，低2字节与owner共享，因此实际上是将<code>tickets.next</code>+1</li>
<li>通过wfe指令进入一小段时间等待状态后读取新的owner值检查与next是否相等，不等则继续等待，相等则结束等待</li>
<li>owner的值由arch_spin_unlock控制，当next==owner时，释放锁，否则进入循环等待</li>
</ol>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220113-spinlock-flow-chart.png" alt="流程图"></p>
</blockquote>
</li>
</ul>
<h3 id="semaphore">semaphore</h3>
<h4 id="使用-3">使用</h4>
<ul>
<li>
<p>进程在信号量保护的临界区代码里是可以睡眠的，这是和自旋锁的最大的区别</p>
</li>
<li>
<p>Linux中的信号量能保证资源在一个时刻只有一个进程使用，这是单值信号量，也可以作为资源计数器，这是多值信号量</p>
</li>
<li>
<p>使用示例</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> sema<span class="token punctuation">;</span> <span class="token comment">//信号量</span>
<span class="token keyword">int</span> open_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//上锁</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"dev is busy, hello_open fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    open_count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">hello_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>flip<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    open_count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>测试</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-test.png" alt=""></p>
</li>
</ul>
<h4 id="内核源码实现">内核源码实现</h4>
<ul>
<li>
<p>semaphore 结构体</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">{</span>
	raw_spinlock_t		lock<span class="token punctuation">;</span> <span class="token comment">//保护信号量自身的自旋锁</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>		count<span class="token punctuation">;</span> <span class="token comment">//信号量值</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span>	wait_list<span class="token punctuation">;</span> <span class="token comment">//挂载睡眠等待进程的双向链表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>初始化函数（include/linux/semaphore.h）</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SEMAPHORE_INITIALIZER</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> n<span class="token punctuation">)</span>				</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">{</span>									</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>lock		<span class="token operator">=</span> <span class="token function">__RAW_SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span>	</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>count		<span class="token operator">=</span> n<span class="token punctuation">,</span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>wait_list	<span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">,</span>		</span><span class="token punctuation">\</span>
	<span class="token comment">//LIST_HEAD_INIT 初始化双向链表</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span>
	<span class="token operator">*</span>sem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">)</span> <span class="token function">__SEMAPHORE_INITIALIZER</span><span class="token punctuation">(</span><span class="token operator">*</span>sem<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">lockdep_init_map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">.</span>dep_map<span class="token punctuation">,</span> <span class="token string">"semaphore-&gt;lock"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>down（kernel/locking/semaphore.c）</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//获取信号量</span>
<span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token comment">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量</span>
	<span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//自旋锁保护</span>
    <span class="token comment">//信号量不够，休眠进程并把task加到sem的wait_list上</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		sem<span class="token operator">-&gt;</span>count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//如果信号量值大于0,则对其减1</span>
	<span class="token keyword">else</span>
		<span class="token function">__down</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号量不够，让当前进程进入睡眠</span>
	<span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//进入睡眠等待</span>
<span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">__down_common</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">,</span> MAX_SCHEDULE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//#define TASK_UNINTERRUPTIBLE	2 //进程状态为不可中断的睡眠状态</span>
    <span class="token comment">//#define	MAX_SCHEDULE_TIMEOUT	LONG_MAX</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> __sched <span class="token function">__down_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">long</span> state<span class="token punctuation">,</span>
								<span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment">//表示当前进程</span>
    <span class="token comment">/**
    struct semaphore_waiter {
		struct list_head list;
		struct task_struct *task;
		bool up;
	};
    **/</span>
	<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> waiter<span class="token punctuation">;</span>
    <span class="token comment">//将这个信号量上等待的task加到sem-&gt;wait_list的头部</span>
	<span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//链表相加</span>
	waiter<span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span> 
	waiter<span class="token punctuation">.</span>up <span class="token operator">=</span> false<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending_state</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//有没有打断</span>
			<span class="token keyword">goto</span> interrupted<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//有没有超时</span>
			<span class="token keyword">goto</span> timed_out<span class="token punctuation">;</span>
        <span class="token comment">//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE</span>
		<span class="token function">__set_task_state</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">raw_spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放在down函数中加的锁</span>
        <span class="token comment">/** 为什么这里要分开上锁？**/</span>
		timeout <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进入睡眠，让出CPU</span>
		<span class="token function">raw_spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进程下次运行会回到这里，所以要加锁</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>waiter<span class="token punctuation">.</span>up<span class="token punctuation">)</span> <span class="token comment">//跳出循环</span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>up</p>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//释放信号量</span>
<span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token comment">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量</span>
	<span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//wait_list是否为空</span>
		sem<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//如果信号量等待链表中为空，则对信号量值加1</span>
	<span class="token keyword">else</span> 
		<span class="token function">__up</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//否则执行唤醒进程相关的操作</span>
	<span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
 <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">/** wait_list上有等待的进程把它拿下来唤醒**/</span>
	<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">,</span>
						<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将semaphore_waiter拿出来</span>
	waiter<span class="token operator">-&gt;</span>up <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//置为true</span>
	<span class="token function">wake_up_process</span><span class="token punctuation">(</span>waiter<span class="token operator">-&gt;</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤醒进程</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="rw-spinlock">rw spinlock</h3>
<ul>
<li>
<p>读写锁也称为共享-独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥），读写之间是互斥的，而且读取和写入操作在竞争锁的时候，写会优先得到锁</p>
</li>
<li>
<p>读写锁非常适合读取数据的频率远大于修改数据的频率的场景中，这样可以在任何时刻，保证多个进程的读取操作并发地执行，给系统带来了更高的并发度</p>
</li>
<li>
<p>Linux中的读写锁本质上是自旋锁的变种，Linux读写锁的原理<strong>本质是基于计数器</strong>，初始值为<code>0x01000000</code>，获取读锁时对其减1，结果不小于0则表示获取读锁成功；获取写锁时直接减去<code>0x01000000</code>，因为只有当锁值为初始值时，减去初始值结果才可以是0，这是唯一没有进程持有任何锁的情况，这样才能保证获取写锁时是互斥的<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p>
</li>
</ul>
<h3 id="qspinlock">qspinlock</h3>
<ul>
<li>ticket spinlock的问题：不可伸缩性</li>
<li>Linux内核 4.2 引入了 qspinlock<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>，主要基于 mcs spinlock 的设计思想，解决了其接口不一致或空间太大的问题</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/440837507">https://zhuanlan.zhihu.com/p/440837507</a></li>
</ul>
<h3 id="同步机制的比较">同步机制的比较</h3>
<ul>
<li>
<p>信号量的特点</p>
<ul>
<li>用于进程和进程之间的同步</li>
<li>允许有多个进程进入临界区代码执行</li>
<li>进程获取不到信号量锁会陷入休眠，并让出CPU</li>
<li><strong>被信号量锁保护的临界区代码允许睡眠</strong></li>
<li>本质是基于进程调度器，UP和SMP下的实现无差异</li>
<li><strong>不支持进程和中断之间的同步</strong></li>
</ul>
</li>
<li>
<p>自旋锁的特点</p>
<ul>
<li>是一种<strong>死等</strong>的锁机制</li>
<li>一次只能有一个执行单元获取锁并进入临界区，其它的执行单元都是在门口不断死等</li>
<li>执行时间短</li>
<li><strong>可以在中断上下文执行</strong>（中断上下文代码不允许睡眠，也不允许调用可能会引起睡眠的函数）</li>
<li>spinlock不区分reader和writer，对于那些读写强度不对称的是不适合的</li>
</ul>
</li>
<li>
<p>读写自旋锁</p>
<ul>
<li>自旋锁的改进，rw spinlock给reader赋予了更高的优先级</li>
</ul>
</li>
<li>
<p>顺序锁 seqlock</p>
<ul>
<li>seqlock 给writer赋予了更高的优先级</li>
</ul>
<blockquote>
<p>spin lock的不足：性能问题</p>
<p>rw spin lcok、spin lock和seqlock，它们都是基于一个remory中的共享变量（对该变量的访问是原子的）</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220113-spinlock-performance.png" alt=""></p>
</blockquote>
</li>
<li>
<p>rcu</p>
<ul>
<li>基于multi-processor之间的共享counter的锁机制已经不能满足性能的需求，在这种情况下rcu机制应运而生</li>
</ul>
</li>
</ul>
<ol>
<li></li>
</ol>
<h2 id="04-内存地址空间">04 | 内存地址空间</h2>
<h3 id="内核空间和用户空间">内核空间和用户空间</h3>
<ul>
<li>
<p>32位 linux 系统的地址空间分布</p>
<p>操作系统分配给每个进程一个独立的、连续的、虚拟的地址内存空间<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-memory-space.png" alt=""></p>
</li>
<li>
<p>逻辑地址、虚拟地址、线性地址、物理地址<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup></p>
</li>
<li>
<p>linux 内核划分内核空间和用户空间的原因</p>
<ul>
<li>
<p><strong>安全考量</strong>：系统中有各种资源，而linux是多用户、多进程系统，所以这些资源必须在受限的、被管理的状态下使用，空间隔离可以保证即便是单个应用程序出现错误也不会影响到操作系统的稳定性</p>
</li>
<li>
<p><strong>处理器模式不同，权限不同</strong>：内核空间和用户空间代码运行时的处理器工作模式是不同的，用户模式只能正常执行程序，而特权模式才能访问外设、处理中断等</p>
</li>
<li>
<p>对于x86体系的cpu， 用户空间代码运行在Ring3，内核空间代码运行Ring0</p>
</li>
<li>
<p>对于arm体系的cpu，用户空间代码运行在usr模式，内核空间代码运行在svc模式</p>
</li>
<li>
<p><strong>核心代码和业务代码的解耦</strong>：内核代码偏重于系统和资源管理，而用户空间代码偏重于业务逻辑代码的实现，两者分工不同，隔离也是解耦</p>
</li>
</ul>
</li>
<li>
<p>64位系统的内核空间和用户空间的地址分布</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211119-64-os.png" alt=""></p>
<ul>
<li>64位系统的地址线有64位，一般来说48位的地址线就够了，比如armv8-A，高64TB是内核空间，低64TB是用户空间</li>
<li>内核空间的的高16位都是1，用户空间的低16位都是0，这样可以方便的对用户空间和内核空间进行有效性检测，防止越界</li>
</ul>
</li>
</ul>
<h3 id="x86段页式内存管理">x86段页式内存管理</h3>
<ul>
<li>
<p><a href="https://night-candle.github.io/2021/01/28/hello-os/#MMU">MMU</a></p>
</li>
<li>
<p>逻辑地址到物理地址的转换（32位）</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211120-x86cpu-mm.png" alt="x86 cpu 段页式内存管理机制"></p>
</li>
<li>
<p>分段 <code>Segmentation</code></p>
<p>逻辑地址转换为线性地址的过程：</p>
<p>（1）先从段选择符中得到段描述符</p>
<p>（2）从段描述符中得到段基地址</p>
<p>（3）线性地址=段基地址 + 段内偏移</p>
</li>
<li>
<p>分页 <code>Paging</code></p>
<p>线性地址转换成物理地址通过页表映射实现，以<a href="https://night-candle.github.io/2021/01/28/hello-os/#4KB%E9%A1%B5">保护模式下4KB页</a>（二级页表）为例，线性地址分成三段，用前两段分别作为索引去查表，根据页表项（Page Table Entry）获得一个物理内存块的起始地址（物理内存编号），加上页内偏移就得到了物理地址<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-paging.png" alt=""></p>
</li>
<li>
<p>Linux 内核中逻辑地址、虚拟地址和线性地址的关系</p>
<ul>
<li>
<p>Intel 的设计中段式内存管理中的段类型分为三种：代码段、数据段、系统段，但只靠页式内存管理就已经可以完成 Linux 内核需要的所有功能，所以 Linux 内核将所有类型的段的 segment base address 都设成 0 。由于段限长是地址总线的寻址限度，所以所有段内空间跟整个线性空间重合了，逻辑地址也就简化为了段内的偏移量</p>
</li>
<li>
<p>所以在 x86 linux 内核里，<strong>逻辑地址 = 虚拟地址 = 线性地址</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="内核空间和用户空间数据拷贝">内核空间和用户空间数据拷贝</h3>
<ol>
<li>
<p>内核空间和用户空间</p>
</li>
<li>
<p>驱动代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/moduleparam.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/slab.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">BUFFER_MAX</span>    <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">OK</span>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ERROR</span>         <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>gDev<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>gFile<span class="token punctuation">;</span>
dev_t  devNum<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> subDevNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> reg_major  <span class="token operator">=</span>  <span class="token number">232</span><span class="token punctuation">;</span>    
<span class="token keyword">int</span> reg_minor <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUFFER_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//在内核空间中</span>

<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// u是用户空间的一个地址</span>
ssize_t <span class="token function">hello_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// printk(KERN_INFO "hello_write\n");</span>
	<span class="token keyword">int</span> writelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    writelen <span class="token operator">=</span> BUFFER_MAX<span class="token operator">&gt;</span>s <span class="token operator">?</span> s <span class="token operator">:</span> BUFFER_MAX<span class="token punctuation">;</span> <span class="token comment">//防止越界</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> u<span class="token punctuation">,</span> writelen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//copy_from_user实现数据拷贝</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> writelen<span class="token punctuation">;</span> <span class="token comment">//返回拷贝成功字节数</span>
<span class="token punctuation">}</span>

ssize_t <span class="token function">hello_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// printk(KERN_INFO "hello_read\n");</span>
    <span class="token keyword">int</span> readlen<span class="token punctuation">;</span>
    readlen <span class="token operator">=</span> BUFFER_MAX<span class="token operator">&gt;</span>s <span class="token operator">?</span> s <span class="token operator">:</span> BUFFER_MAX<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//copy_to_user把内核空间的数据拷贝给用户空间</span>
    	<span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> readlen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    devNum <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>reg_major<span class="token punctuation">,</span> reg_minor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>OK <span class="token operator">==</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">,</span> <span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"register_chrdev_region ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"register_chrdev_region error n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">" hello driver init \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gDev <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    gFile <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>open <span class="token operator">=</span> hello_open<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>read <span class="token operator">=</span> hello_read<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>write <span class="token operator">=</span> hello_write<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    <span class="token function">cdev_init</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> devNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 	<span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">" hello driver exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">kfree</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Makefile同上</p>
</li>
<li>
<p>测试代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>
    fd_set fdset<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open success\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    w_len <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>w_len <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"write error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write len: %d\n"</span><span class="token punctuation">,</span> w_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>
    fd_set fdset<span class="token punctuation">;</span>
    <span class="token keyword">char</span> rbuf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>rbuf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open successe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
	r_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> rbuf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>r_len <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read len: %d\n"</span><span class="token punctuation">,</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> rbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>c
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211119-test.png" alt=""></p>
</li>
</ol>
<h2 id="05-Linux内存管理">05 | Linux内存管理</h2>
<ul>
<li>Linux 中用来<strong>管理物理内存页面</strong>的伙伴系统，以及负责<strong>分配比页更小的内存对象</strong>的SLAB分配器</li>
</ul>
<h3 id="伙伴系统">伙伴系统</h3>
<h4 id="数据结构-2">数据结构</h4>
<ul>
<li>
<p>Linux 使用分页机制管理物理内存，把物理内存分成 4KB 大小的页面进行管理，早期 Linux 使用了位图，后来使用了字节数组，现在 Linux 定义了 <code>struct page</code> 结构体描述每个物理页，内核中一个 page 结构表示一个物理内存页面</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token punctuation">{</span>
    <span class="token comment">//page结构体的标志，它决定页面是什么状态</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token comment">//挂载上级结构的链表</span>
            <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lru<span class="token punctuation">;</span>
            <span class="token comment">//用于文件系统，address_space结构描述上文件占用了哪些内存页面</span>
            <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">;</span>
            pgoff_t index<span class="token punctuation">;</span>  
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> private<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//DMA设备的地址</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            dma_addr_t dma_addr<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//当页面用于内存对象时指向相关的数据结构 </span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>   
            <span class="token keyword">union</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slab_list<span class="token punctuation">;</span>
                <span class="token keyword">struct</span> <span class="token punctuation">{</span>  
                    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_64BIT</span></span>
                    <span class="token keyword">int</span> pages<span class="token punctuation">;</span> 
                    <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
                    <span class="token keyword">short</span> <span class="token keyword">int</span> pages<span class="token punctuation">;</span>
                    <span class="token keyword">short</span> <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token comment">//指向管理SLAB的结构kmem_cache</span>
            <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>slab_cache<span class="token punctuation">;</span>
            <span class="token comment">//指向SLAB的第一个对象</span>
            <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>   
            <span class="token keyword">union</span> <span class="token punctuation">{</span>
                <span class="token keyword">void</span> <span class="token operator">*</span>s_mem<span class="token punctuation">;</span>  
                <span class="token keyword">unsigned</span> <span class="token keyword">long</span> counters<span class="token punctuation">;</span>   
                <span class="token keyword">struct</span> <span class="token punctuation">{</span>            
                    <span class="token keyword">unsigned</span> inuse<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> objects<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">;</span>
                    <span class="token keyword">unsigned</span> frozen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//用于页表映射相关的字段</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _pt_pad_1<span class="token punctuation">;</span>   
            pgtable_t pmd_huge_pte<span class="token punctuation">;</span> 
            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _pt_pad_2<span class="token punctuation">;</span>
            <span class="token keyword">union</span> <span class="token punctuation">{</span>
                <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>pt_mm<span class="token punctuation">;</span>
                atomic_t pt_frag_refcount<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token comment">//自旋锁</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">ALLOC_SPLIT_PTLOCKS</span></span>
            spinlock_t <span class="token operator">*</span>ptl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
            spinlock_t ptl<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//用于设备映射</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            <span class="token keyword">struct</span> <span class="token class-name">dev_pagemap</span> <span class="token operator">*</span>pgmap<span class="token punctuation">;</span>
            <span class="token keyword">void</span> <span class="token operator">*</span>zone_device_data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//页面引用计数</span>
    atomic_t _refcount<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span>
    <span class="token keyword">int</span> _last_cpupid<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span> _struct_page_alignment<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>page 结构大量使用了 union 联合体定义结构字段，page 结构会根据不同的状态来使用 union 联合体的变量表示的数据信息</p>
</blockquote>
</li>
<li>
<p>Linux 内核用 <code>zone</code> 数据结构表示一个区，其中 <code>free_area</code> 结构的数组用于实现伙伴系统，free_area 结构中 list_head 链表数组将具有相同迁移类型的 page 尽可能地分组，同一类型的所有相同 order 的 page 就构成了一组 page 结构块，zone 结构中还有一个指针指向 pglist_data</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">migratetype</span> <span class="token punctuation">{</span>
    MIGRATE_UNMOVABLE<span class="token punctuation">,</span> <span class="token comment">//不能移动的</span>
    MIGRATE_MOVABLE<span class="token punctuation">,</span>   <span class="token comment">//可移动和</span>
    MIGRATE_RECLAIMABLE<span class="token punctuation">,</span>
    MIGRATE_PCPTYPES<span class="token punctuation">,</span>  <span class="token comment">//属于pcp list的</span>
    MIGRATE_HIGHATOMIC <span class="token operator">=</span> MIGRATE_PCPTYPES<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CMA</span></span>
    MIGRATE_CMA<span class="token punctuation">,</span>   <span class="token comment">//属于CMA区的</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MEMORY_ISOLATION</span></span>
    MIGRATE_ISOLATE<span class="token punctuation">,</span>   
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    MIGRATE_TYPES
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//页面空闲链表头</span>
<span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token punctuation">{</span>
    <span class="token comment">//数组将具有相同迁移类型的page结构尽可能地分组</span>
    <span class="token comment">//分配时会先按请求的migratetype从对应page结构块中寻找，不成功则会从其他migratetype的page结构块中分配</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    free_list<span class="token punctuation">[</span>MIGRATE_TYPES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       nr_free<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _watermark<span class="token punctuation">[</span>NR_WMARK<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> watermark_boost<span class="token punctuation">;</span>
    <span class="token comment">//预留的内存页面数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_reserved_highatomic<span class="token punctuation">;</span>
    <span class="token comment">//内存区属于哪个内存节点 </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>
    <span class="token keyword">int</span> node<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span>  <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>
    <span class="token comment">//内存区开始的page结构数组的开始下标 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       zone_start_pfn<span class="token punctuation">;</span>
    
    atomic_long_t       managed_pages<span class="token punctuation">;</span>
    <span class="token comment">//内存区总的页面数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       spanned_pages<span class="token punctuation">;</span>
    <span class="token comment">//内存区存在的页面数（一些内存区中存在内存空洞）</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       present_pages<span class="token punctuation">;</span>
    <span class="token comment">//内存区名字</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token comment">//挂载页面page结构的链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//内存区的标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       flags<span class="token punctuation">;</span>
    <span class="token comment">/*保护free_area的自旋锁*/</span>
    spinlock_t      lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>_watermark：水位，用于控制内存区是否需要进行内存回收</p>
<p>Linux 内核中也有<strong>区</strong>的逻辑概念，因为硬件的限制，内核不能对所有的物理内存页统一对待，所以就把属性相同物理内存页面，归结到了一个区中，不同硬件平台，区的划分也不一样</p>
<ul>
<li>
<p>32 位 x86 平台中，一些使用 DMA 的设备只能访问 0-16MB 的物理空间，因此将其划分为 ==DMA 区==</p>
</li>
<li>
<p>==高内存区==则适用于要访问的物理地址空间大于虚拟地址空间，Linux 内核不能建立直接映射的情况，64 位 x86 平台没有高内存区</p>
</li>
<li>
<p>Linux 里可以查看机器上的内存区</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>Linux 使用 <code>pglist_data</code> 数据结构表示一个内存节点，Linux 对 NUMA 进行了抽象<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，它可以将一整块连续物理内存的划分成若干 node，也可以把不是连续的物理内存当成 UMA，在本节点中分配不到内存页面的时候，就会到其它节点中分配内存页面</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
    ZONELIST_FALLBACK<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>
    ZONELIST_NOFALLBACK<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    MAX_ZONELISTS
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">zoneref</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">;</span><span class="token comment">//内存区指针</span>
    <span class="token keyword">int</span> zone_idx<span class="token punctuation">;</span>     <span class="token comment">//内存区对应的索引</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">zonelist</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zoneref</span> _zonerefs<span class="token punctuation">[</span>MAX_ZONES_PER_ZONELIST <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//zone枚举类型 从0开始</span>
<span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
    ZONE_DMA<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>
    ZONE_DMA32<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_NORMAL<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HIGHMEM</span></span>
    ZONE_HIGHMEM<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    ZONE_MOVABLE<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DEVICE</span></span>
    ZONE_DEVICE<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    __MAX_NR_ZONES

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//定义MAX_NR_ZONES为__MAX_NR_ZONES 最大为6</span>
<span class="token function">DEFINE</span><span class="token punctuation">(</span>MAX_NR_ZONES<span class="token punctuation">,</span> __MAX_NR_ZONES<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//内存节点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token punctuation">{</span>
    <span class="token comment">//定一个内存区数组，最大为6个zone元素</span>
    <span class="token keyword">struct</span> <span class="token class-name">zone</span> node_zones<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//两个zonelist，一个是指向本节点的的内存区，另一个指向由本节点分配不到内存时可选的备用内存区</span>
    <span class="token keyword">struct</span> <span class="token class-name">zonelist</span> node_zonelists<span class="token punctuation">[</span>MAX_ZONELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//本节点有多少个内存区</span>
    <span class="token keyword">int</span> nr_zones<span class="token punctuation">;</span> 
    <span class="token comment">//本节点开始的page索引号</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_start_pfn<span class="token punctuation">;</span>
    <span class="token comment">//本节点有多少个可用的页面 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_present_pages<span class="token punctuation">;</span>
    <span class="token comment">//本节点有多少个可用的页面包含内存空洞 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_spanned_pages<span class="token punctuation">;</span>
    <span class="token comment">//节点id</span>
    <span class="token keyword">int</span> node_id<span class="token punctuation">;</span>
    <span class="token comment">//交换内存页面相关的字段</span>
    wait_queue_head_t kswapd_wait<span class="token punctuation">;</span>
    wait_queue_head_t pfmemalloc_wait<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>kswapd<span class="token punctuation">;</span> 
    <span class="token comment">//本节点保留的内存页面</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       totalreserve_pages<span class="token punctuation">;</span>
    <span class="token comment">//自旋锁</span>
    spinlock_t      lru_lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span> pg_data_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><strong>数据结构之间的关系</strong></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220809-physical-memory-management.jpg" alt=""></p>
</li>
</ul>
<h4 id="伙伴算法">伙伴算法</h4>
<ul>
<li>
<p>场景：内核在很多情况下，需要申请连续的页框，而且数量不定</p>
</li>
<li>
<p>Linux 物理内存页面管理中，连续且相同大小的 pages 就可以表示成伙伴</p>
</li>
<li>
<p>Linux 把所有的空闲页框分组为11个块链表（<code>#define MAX_ORDER 11</code>），每个链表上的页框块是固定的，在第i条链表中每个页框块都包含$2^i$个连续页，每个页框块的第一个页框的物理地址是该块大小的整数倍（例如：大小为16个页框的块其起始地址是$16 \times 2^{12}$的倍数）</p>
</li>
<li>
<p>假设连续的物理内存，各页面块左右的页面，要么是等同大小，要么就是整数倍，而且还是偶数，形同伙伴</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220114-buddy.png" alt=""></p>
</li>
<li>
<p>伙伴管理算法的申请过程：如果申请指定大小的页面在其页面块链表中不存在，则会往高阶的页面块链表进行查找，直到找到为止，如果在高阶的页面块链表找到空闲的页面块，则会将其拆分为两块，如果拆分后仍比需要的大，那么继续拆分，直至到大小刚好为止</p>
</li>
<li>
<p>伙伴管理算法的释放过程：当某块页面被释放时，且其存在空闲的<strong>伙伴页面块</strong>（两个页面块的大小相同且两者的物理地址连续），则算法会将其两者合并为一个大的页面块，合并后的页面块如果还可以找到伙伴页面块，则会继续合并，直至到大小为$2^{MAX_ORDER}$个页面为止</p>
<blockquote>
<p>如何分配 4M 以上内存：</p>
<ol>
<li>
<p>修改MAX_ORDER</p>
</li>
<li>
<p>内核启动选型传递"mem="参数，预留部分内存</p>
</li>
<li>
<p>在start_kernel中mem_init函数之前调用alloc_boot_mem函数预分配大块内存</p>
</li>
<li>
<p>vmalloc 函数：分配在虚拟内存中连续但在物理内存中不一定连续的内存</p>
<p>…</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="反碎片机制">反碎片机制</h4>
<h4 id="分配内存页面">分配内存页面</h4>
<ul>
<li>
<p>页框操作函数</p>
<ul>
<li>
<p><code>alloc_pages()</code>：分配$2^{order}$个连续的物理页，并返回一个指针，指向第一个页的page结构体</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p><code>page_address()</code>：返回page页面所映射的的虚拟地址</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">page_address</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li>
<p>分配物理内存页面的过程：首先要找到内存节点，接着找到内存区，然后合适的空闲链表，最后在其中找到页的 page 结构，完成物理内存页面的分配</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-alloc-pages.png" style="zoom:80%;">
</li>
<li>
<p>所有的接口函数都会调用到 <code>alloc_pages</code> 函数，而这个函数最终会调用 <code>__alloc_pages_nodemask</code> 函数完成内存页面的分配</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_t gfp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>pol <span class="token operator">=</span> <span class="token operator">&amp;</span>default_policy<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>gfp <span class="token operator">&amp;</span> __GFP_THISNODE<span class="token punctuation">)</span><span class="token punctuation">)</span>
        pol <span class="token operator">=</span> <span class="token function">get_task_policy</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pol<span class="token operator">-&gt;</span>mode <span class="token operator">==</span> MPOL_INTERLEAVE<span class="token punctuation">)</span>
        page <span class="token operator">=</span> <span class="token function">alloc_page_interleave</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token function">interleave_nodes</span><span class="token punctuation">(</span>pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">//gfp_t 用位的状态表示请求分配不同的内存区的内存页面，以及分配内存页面的不同方式</span>
        page <span class="token operator">=</span> <span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
                <span class="token function">policy_node</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">,</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token function">policy_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><code>__alloc_pages_nodemask</code> 函数：1）准备分配页面的参数；2）进入快速分配路径；3）若快速分配路径没有分配到页面，就进入慢速分配路径</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span> <span class="token keyword">int</span> preferred_nid<span class="token punctuation">,</span>  nodemask_t <span class="token operator">*</span>nodemask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> alloc_flags <span class="token operator">=</span> ALLOC_WMARK_LOW<span class="token punctuation">;</span>
    gfp_t alloc_mask<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">alloc_context</span> ac <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//分配页面的order大于等于最大的order直接返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>order <span class="token operator">&gt;=</span> MAX_ORDER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">WARN_ON_ONCE</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>gfp_mask <span class="token operator">&amp;</span> __GFP_NOWARN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    gfp_mask <span class="token operator">&amp;=</span> gfp_allowed_mask<span class="token punctuation">;</span>
    alloc_mask <span class="token operator">=</span> gfp_mask<span class="token punctuation">;</span>
    <span class="token comment">//准备分配页面的参数放在ac变量中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">prepare_alloc_pages</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> preferred_nid<span class="token punctuation">,</span> nodemask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">,</span> <span class="token operator">&amp;</span>alloc_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>alloc_flags<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    alloc_flags <span class="token operator">|=</span> <span class="token function">alloc_flags_nofragment</span><span class="token punctuation">(</span>ac<span class="token punctuation">.</span>preferred_zoneref<span class="token operator">-&gt;</span>zone<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//进入快速分配路径</span>
    page <span class="token operator">=</span> <span class="token function">get_page_from_freelist</span><span class="token punctuation">(</span>alloc_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> alloc_flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    alloc_mask <span class="token operator">=</span> <span class="token function">current_gfp_context</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ac<span class="token punctuation">.</span>spread_dirty_pages <span class="token operator">=</span> false<span class="token punctuation">;</span>
    ac<span class="token punctuation">.</span>nodemask <span class="token operator">=</span> nodemask<span class="token punctuation">;</span>
    <span class="token comment">//进入慢速分配路径</span>
    page <span class="token operator">=</span> <span class="token function">__alloc_pages_slowpath</span><span class="token punctuation">(</span>alloc_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h5 id="快速分配路径">快速分配路径</h5>
<h5 id="慢速分配路径">慢速分配路径</h5>
<h3 id="Slab-分配器">Slab 分配器</h3>
<ul>
<li>
<p>引入：现实中更多要以内核对象为单位分配内存，这些数据结构实例变量的大小通常从几十到几百字节不等，远小于一个页面的大小，如果为此分配一个页面无疑是对内存资源的浪费</p>
</li>
<li>
<p>slab 用于实现内核中更小粒度的内存分配，减少伙伴算法在分配小块连续内存时所产生的内部碎片</p>
</li>
<li>
<p>将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销，通过着色技术调整对象以更好的使用硬件高速缓存</p>
</li>
<li>
<p>slab 分配器中，每一类对象拥有一个*“cache”*，对象从 cache 处获取内存，而 cache 则从 buddy 系统获取内存，因此在物理上是连续的；一个 cache 分成了若干个 slabs，同一 cache 中的 slabs 都存储相同的对象，而 slabs 由一个或者多个物理上连续的页组成</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220114-slab.png" style="zoom: 67%;">
</li>
</ul>
<h4 id="Slab-对象">Slab 对象</h4>
<ul>
<li>
<p>Slab 分配器中把一个内存页面或一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是==Slab 对象==，但是这一组连续的内存页面中不只是 Slab 对象，还有==Slab 管理头==和==着色区==</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-slab.jpg" style="zoom:80%;">
</li>
<li>
<p>着色区是一块动态的内存块，建立 Slab 时才会设置大小，目的是为了错开不同 Slab 中的对象地址，降低硬件 Cache 行中的地址争用，以免导致 Cache 抖动效应</p>
</li>
<li>
<p>Slab 头是一个数据结构，但是不一定放在保存对象内存页面的开始，通常会有一个保存 Slab 管理头的 Slab</p>
</li>
<li>
<p>在 Linux 中 Slab 管理头用 <code>kmem_cache</code> 结构来表示（一个 kmem_cache 代表一个高速缓存）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{</span>
    <span class="token comment">//是每个CPU一个array_cache类型的变量，cpu_cache是用于管理空闲对象的 </span>
    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> __percpu <span class="token operator">*</span>cpu_cache<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment">//cache大小</span>
    slab_flags_t flags<span class="token punctuation">;</span><span class="token comment">//slab标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//对象个数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> gfporder<span class="token punctuation">;</span><span class="token comment">//分配内存页面的order</span>
    gfp_t allocflags<span class="token punctuation">;</span>
    size_t colour<span class="token punctuation">;</span><span class="token comment">//着色区大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> colour_off<span class="token punctuation">;</span><span class="token comment">//着色区的开始偏移</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//本SLAB的名字</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span><span class="token comment">//所有的SLAB都要链接起来</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span><span class="token comment">//引用计数</span>
    <span class="token keyword">int</span> object_size<span class="token punctuation">;</span><span class="token comment">//对象大小</span>
    <span class="token keyword">int</span> align<span class="token punctuation">;</span><span class="token comment">//对齐大小</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//指向管理kmemcache的上层结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> avail<span class="token punctuation">;</span><span class="token comment">//当前可用对象的数目</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span><span class="token comment">//允许容纳对象的最大数目</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//遵循LIFO顺序的数组</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>有多少个 CPU 就会有多少个 array_cache 类型的变量，这种为每个 CPU 构造一个变量副本的同步机制，就是<strong>每CPU变量</strong>（<code>per-cpu-variable</code>）</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-kmemcache.png" alt=""></p>
</li>
<li>
<p>第一个 kmem_cache 静态定义在代码中</p>
</li>
</ul>
<h4 id="管理-kmem-cache">管理 kmem_cache</h4>
<ul>
<li>
<p>每个内存节点对应一个 <code>kmem_cache_node</code> 结构用来管理 kmem_cache 结构，它开始是静态定义的，</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">NUM_INIT_LISTS</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> MAX_NUMNODES<span class="token punctuation">)</span></span></span>
<span class="token comment">//定义的kmem_cache_node结构数组</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> __initdata init_kmem_cache_node<span class="token punctuation">[</span>NUM_INIT_LISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>
    spinlock_t list_lock<span class="token punctuation">;</span><span class="token comment">//自旋锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_partial<span class="token punctuation">;</span><span class="token comment">//有一部分空闲对象的kmem_cache结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_full<span class="token punctuation">;</span><span class="token comment">//没有空闲对象的kmem_cache结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_free<span class="token punctuation">;</span><span class="token comment">//对象全部空闲kmem_cache结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_slabs<span class="token punctuation">;</span> <span class="token comment">//一共多少kmem_cache结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_slabs<span class="token punctuation">;</span>  <span class="token comment">//空闲的kmem_cache结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_objects<span class="token punctuation">;</span><span class="token comment">//空闲的对象</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> free_limit<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>初始化时建立了第一个 kmem_cache 结构之后 init_list 函数负责分配内存空间</p>
</li>
<li>
<p>第一次分配对象时那么 Slab 模块会调用 <code>cache_grow_begin</code> 函数获取内存页面，然后用获取的页面来存放对象，随后会调用 <code>cache_grow_end</code> 函数把页面挂载到 kmem_cache_node 的链表中，并让页面指向 kmem_cache，这样 kmem_cache_node、kmem_cache、page 三者之间就联系起来了</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-slab-global-structure.png" alt=""></p>
<blockquote>
<p>上图中 page 可能是一组连续的 pages，但是只会把第一个 page 挂载到 kmem_cache_node，同时，slab_map_pages 函数中又让 page 指向了 kmem_cache</p>
</blockquote>
</li>
</ul>
<h4 id="Slab-分配对象">Slab 分配对象</h4>
<ul>
<li>
<p>Slab 分配对象过程</p>
<ul>
<li>
<p>根据请求分配对象的大小，查找对应的 kmem_cache</p>
</li>
<li>
<p>从中获取 arry_cache，然后分配对象</p>
</li>
<li>
<p>如果没有空闲对象，就需要在 kmem_cache 对应的 kmem_cache_node 中查找有空闲对象的 kmem_cache</p>
</li>
<li>
<p>如果还是没找到就要分配内存页面新增 kmem_cache</p>
</li>
</ul>
</li>
<li>
<p>在 Linux 内核中 kmalloc 函数经常用于分配小的缓冲区或者数据结构分配实例空间，这个函数就是 Slab 分配<strong>接口</strong>，用来分配对象</p>
</li>
<li>
<p>普通高速缓存：返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在<strong>物理上是连续的</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token comment">//    </span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kzalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token comment">//内存空间置为0</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在<strong>物理上无需连续</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token comment">//    </span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vzalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span><span class="token comment">//内存空间置为0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>专用高速缓存</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//建立高速缓存</span>
<span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>
<span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t align<span class="token punctuation">,</span>
		  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>cat /proc/slabinfo</code> 查看所有的高速缓存</p>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//从高速缓存申请内存</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
    
<span class="token keyword">void</span> <span class="token function">kmem_cache_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
    
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span>
<span class="token function">slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="kmalloc-内核源码">kmalloc 内核源码</h3>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220116-kmalloc.png" alt=""></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_constant_p</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token function">kmalloc_large</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//...</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token function">__kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//size一般不会指定</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// mm/slab.c中的实现</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">__do_kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> _RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__do_kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span>
					  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	cachep <span class="token operator">=</span> <span class="token function">kmalloc_slab</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找size对应的kmem_cache</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">ZERO_OR_NULL_PTR</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> cachep<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">slab_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查到空闲的对象，进行分配</span>
	<span class="token comment">//...</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查找-kmem-cache">查找 kmem_cache</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Find the kmem_cache structure that serves a given size of
 * allocation
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span><span class="token function">kmalloc_slab</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> index<span class="token punctuation">;</span>
	<span class="token comment">//计算出index</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">192</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>size<span class="token punctuation">)</span>
			<span class="token keyword">return</span> ZERO_SIZE_PTR<span class="token punctuation">;</span>
		index <span class="token operator">=</span> size_index<span class="token punctuation">[</span><span class="token function">size_index_elem</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		index <span class="token operator">=</span> <span class="token function">fls</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
<span class="token comment">//...</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token keyword">return</span> kmalloc_caches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//kmalloc_caches是个全局二维数组，kmalloc_slab只是根据分配大小和分配标志计算出数组下标后取出其中kmem_cache结构指针</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>一页的大小是4K，所以PAGE_SHIFT值为12，往左偏移12位</p>
<p>MAX_ORDER值为11，即为伙伴算法块链表数</p>
<p>所以内核中最多可以定义23个高速缓存结构体</p>
</blockquote>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//建立所有的kmalloc_caches中的kmem_cache，高速缓存索引和object size对应关系</span>
<span class="token keyword">void</span> __init <span class="token function">create_kmalloc_caches</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> KMALLOC_SHIFT_LOW<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> KMALLOC_SHIFT_HIGH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment">//建立一个新的kmem_cache</span>
			<span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第5个开始</span>

		<span class="token comment">/*
		 * Caches that are not of the two-to-the-power-of size.
		 * These have to be created immediately after the
		 * earlier power of two caches
		 */</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>KMALLOC_MIN_SIZE <span class="token operator">&lt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span>
			<span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>KMALLOC_MIN_SIZE <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span>
			<span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* Kmalloc array is now usable */</span>
	slab_state <span class="token operator">=</span> UP<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
<span class="token comment">//...</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> __init <span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	kmalloc_caches<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">create_kmalloc_cache</span><span class="token punctuation">(</span>kmalloc_info<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
					kmalloc_info<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">const</span> kmalloc_info<span class="token punctuation">[</span><span class="token punctuation">]</span> __initconst <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">{</span><span class="token constant">NULL</span><span class="token punctuation">,</span>                      <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>		<span class="token punctuation">{</span><span class="token string">"kmalloc-96"</span><span class="token punctuation">,</span>             <span class="token number">96</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span><span class="token string">"kmalloc-192"</span><span class="token punctuation">,</span>           <span class="token number">192</span><span class="token punctuation">}</span><span class="token punctuation">,</span>		<span class="token punctuation">{</span><span class="token string">"kmalloc-8"</span><span class="token punctuation">,</span>               <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span><span class="token string">"kmalloc-16"</span><span class="token punctuation">,</span>             <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">,</span>		<span class="token punctuation">{</span><span class="token string">"kmalloc-32"</span><span class="token punctuation">,</span>             <span class="token number">32</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">{</span><span class="token string">"kmalloc-64"</span><span class="token punctuation">,</span>             <span class="token number">64</span><span class="token punctuation">}</span><span class="token punctuation">,</span>		<span class="token punctuation">{</span><span class="token string">"kmalloc-128"</span><span class="token punctuation">,</span>           <span class="token number">128</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="分配对象">分配对象</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> save_flags<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">;</span>
    <span class="token comment">//关中断</span>
    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>save_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//分配对象</span>
    objp <span class="token operator">=</span> <span class="token function">__do_cache_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//恢复中断</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>save_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> objp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>__do_cache_alloc</code> 函数 → <code>____cache_alloc</code> 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__do_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">____cache_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">____cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token operator">*</span>ac<span class="token punctuation">;</span>
    <span class="token comment">//获取当前cpu在cachep结构中的array_cache结构的指针</span>
    ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果ac中的avail不为0,说明当前kmem_cache结构中freelist是有空闲对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ac<span class="token operator">-&gt;</span>touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//空间对象的地址保存在ac-&gt;entry</span>
        objp <span class="token operator">=</span> ac<span class="token operator">-&gt;</span>entry<span class="token punctuation">[</span><span class="token operator">--</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果array_cache结构中没有空闲对象了，调用cache_alloc_refill函数</span>
    objp <span class="token operator">=</span> <span class="token function">cache_alloc_refill</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> objp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cache_alloc_refill</code> 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">cache_alloc_refill</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> batchcount<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token operator">*</span>ac<span class="token punctuation">,</span> <span class="token operator">*</span>shared<span class="token punctuation">;</span>
    <span class="token keyword">int</span> node<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token comment">//获取内存节点</span>
    node <span class="token operator">=</span> <span class="token function">numa_mem_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>
    batchcount <span class="token operator">=</span> ac<span class="token operator">-&gt;</span>batchcount<span class="token punctuation">;</span>
    <span class="token comment">//获取cachep所属的kmem_cache_node</span>
    n <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    shared <span class="token operator">=</span> <span class="token function">READ_ONCE</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token operator">-&gt;</span>free_objects <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>shared <span class="token operator">||</span> <span class="token operator">!</span>shared<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> direct_grow<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>batchcount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//获取kmem_cache_node结构中其它kmem_cache</span>
        <span class="token comment">//返回的是page，page会指向kmem_cache</span>
        page <span class="token operator">=</span> <span class="token function">get_first_slab</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token comment">//没有了</span>
            <span class="token keyword">goto</span> must_grow<span class="token punctuation">;</span>
        batchcount <span class="token operator">=</span> <span class="token function">alloc_block</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> page<span class="token punctuation">,</span> batchcount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
must_grow<span class="token operator">:</span>
    n<span class="token operator">-&gt;</span>free_objects <span class="token operator">-=</span> ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">;</span>
direct_grow<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//分配新的kmem_cache并初始化</span>
        page <span class="token operator">=</span> <span class="token function">cache_grow_begin</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> <span class="token function">gfp_exact_node</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail <span class="token operator">&amp;&amp;</span> page<span class="token punctuation">)</span>
            <span class="token function">alloc_block</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> page<span class="token punctuation">,</span> batchcount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//让page挂载到kmem_cache_node结构的slabs_list链表上</span>
        <span class="token function">cache_grow_end</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ac<span class="token operator">-&gt;</span>touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//重新分配</span>
    <span class="token keyword">return</span> ac<span class="token operator">-&gt;</span>entry<span class="token punctuation">[</span><span class="token operator">--</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">get_first_slab</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
    <span class="token function">assert_spin_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//首先从kmem_cache_node结构中的slabs_partial链表上查看有没有page</span>
    page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>slabs_partial<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span>slab_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果没有</span>
        n<span class="token operator">-&gt;</span>free_touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//从kmem_cache_node结构中的slabs_free链表上查看有没有page</span>
        page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>slabs_free<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span>slab_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span>
            n<span class="token operator">-&gt;</span>free_slabs<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//空闲slab计数减一</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//返回page</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="进程虚拟地址空间管理">进程虚拟地址空间管理</h3>
<ul>
<li>
<p>进程如何管理和分配它的3G虚拟地址空间？</p>
<p><strong>分治思想</strong></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-vma.png" alt=""></p>
</li>
<li>
<p>1</p>
</li>
</ul>
<p><code>/proc/PID/maps</code>显示进程映射了的内存区域和访问权限</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-maps.png" alt=""></p>
<blockquote>
<p>内核中进程的一段地址空间用一个<code>vm_area_struct</code>结构体表示，所有地址空间存储在 <strong>task -&gt; mm -&gt; mmap</strong>链表中</p>
</blockquote>
<h3 id="内存池">内存池</h3>
<p>内核态内存池</p>
<p>用户态内存池</p>
<h3 id="DMA-内存">DMA 内存</h3>
<ol>
<li>直接内存访问是一种<strong>硬件机制</strong>，它允许外围设备和主内存之间直接传输它们的 I/O 数据，而不需要系统处理器的参与</li>
</ol>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-vm_area_struct.jpg" alt=""></p>
<h3 id="Page-Cache">Page Cache</h3>
<p>服务器的 load 飙高、服务器的 I/O 吞吐飙高、业务响应时延出现大的毛刺、业务平均访问时延明显增加 … 这些问题很可能是由于 Page Cache 管理不到位引起的，Page Cache 管理不当除了会增加系统 I/O 吞吐外，还会引起业务性能抖动</p>
<h4 id="什么是-Page-Cache">什么是 Page Cache</h4>
<ul>
<li>
<p>Page Cache 是内核管理的内存，它不属于用户</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211126-page-cache.jpg" alt="应用程序产生Page Cache的逻辑示意图"></p>
</li>
<li>
<p>Linux 上直接查看 Page Cache 的方式包括 <code>/proc/meminfo</code>、<code>free</code> 、<code>/proc/vmstat</code> 命令等</p>
<blockquote>
<p>/proc/meminfo：</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211127-meminfo.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mmalecki/procps/blob/master/free.c">free</a>：通过解析 /proc/meminfo 得出统计数据</p>
<p><strong>buff/cache = Buffers + Cached + SReclaimable</strong></p>
</blockquote>
</li>
<li>
<p><strong>Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</strong></p>
<p>等式的两边就是 Page Cache</p>
<p><strong>Active(file) + Inactive(file)</strong> 是 File-backed page（与文件对应的内存页），mmap() 内存映射方式和 buffered I/O 消耗的内存就属于这部分</p>
<p><strong>SwapCached</strong> 是在打开了 Swap 分区后，把 Inactive(anon) + Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存，由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，这样做的目的是为了减少 I/O</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211127-swapcached.jpg" alt=""></p>
<blockquote>
<p>SwapCached 只在 Swap 分区打开的情况下才会有，建议在生产环境中关闭 Swap 分区，因为 Swap 过程产生的 I/O 会很容易引起性能抖动</p>
</blockquote>
<p><strong>Shmem</strong> 是指匿名共享映射这种方式分配的内存（free 命令中 shared 这一项），比如 tmpfs（临时文件系统）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/mmalecki/procps/blob/master/free.c">https://github.com/mmalecki/procps/blob/master/free.c</a></p>
<h4 id="为什么需要-Page-Cache-？">为什么需要 Page Cache ？</h4>
<ul>
<li>标准 I/O 和内存映射会先把数据写入到 Page Cache，这样做会通过减少 I/O 次数来提升读写效率</li>
</ul>
<h2 id="06-进程与进程调度">06 | 进程与进程调度</h2>
<h3 id="Linux-进程">Linux 进程</h3>
<h4 id="进程数据结构">进程数据结构</h4>
<ul>
<li>
<p>Linux 把运行中的应用程序抽象成一个数据结构 <code>task_struct</code>，一个应用程序所需要的各种资源（如内存、文件等）都包含在这个结构中，内存中一个 task_struct 结构体的实例变量代表一个 Linux 进程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span><span class="token comment">//处理器特有数据 </span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span>   state<span class="token punctuation">;</span>       <span class="token comment">//进程状态 </span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>stack<span class="token punctuation">;</span>      <span class="token comment">//进程内核栈地址 </span>
    refcount_t      usage<span class="token punctuation">;</span>       <span class="token comment">//进程使用计数</span>
    <span class="token keyword">int</span>             on_rq<span class="token punctuation">;</span>       <span class="token comment">//进程是否在运行队列上</span>
    <span class="token keyword">int</span>             prio<span class="token punctuation">;</span>        <span class="token comment">//动态优先级</span>
    <span class="token keyword">int</span>             static_prio<span class="token punctuation">;</span> <span class="token comment">//静态优先级</span>
    <span class="token keyword">int</span>             normal_prio<span class="token punctuation">;</span> <span class="token comment">//取决于静态优先级和调度策略</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    rt_priority<span class="token punctuation">;</span> <span class="token comment">//实时优先级</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span class="token comment">//指向其所在的调度类</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>         se<span class="token punctuation">;</span><span class="token comment">//普通进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>      rt<span class="token punctuation">;</span><span class="token comment">//实时进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>      dl<span class="token punctuation">;</span><span class="token comment">//采用EDF算法调度实时进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_info</span>       sched_info<span class="token punctuation">;</span><span class="token comment">//用于调度器统计进程的运行信息 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span class="token comment">//所有进程的链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>mm<span class="token punctuation">;</span>  <span class="token comment">//指向进程内存结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>active_mm<span class="token punctuation">;</span>
    pid_t               pid<span class="token punctuation">;</span>            <span class="token comment">//进程id</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu    <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向其父进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        children<span class="token punctuation">;</span> <span class="token comment">//链表中的所有元素都是它的子进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        sibling<span class="token punctuation">;</span>  <span class="token comment">//用于把当前进程插入到兄弟链表中</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>      <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span class="token comment">//指向其所在进程组的领头进程</span>
    u64             utime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在用户态下所经过的节拍数</span>
    u64             stime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在内核态下所经过的节拍数</span>
    u64             gtime<span class="token punctuation">;</span>   <span class="token comment">//用于记录作为虚拟机进程所经过的节拍数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           min_flt<span class="token punctuation">;</span><span class="token comment">//缺页统计 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           maj_flt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>        <span class="token operator">*</span>fs<span class="token punctuation">;</span>    <span class="token comment">//进程相关的文件系统信息</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span>     <span class="token operator">*</span>files<span class="token punctuation">;</span><span class="token comment">//进程打开的所有文件</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_struct</span>        <span class="token operator">*</span>stack_vm_area<span class="token punctuation">;</span><span class="token comment">//内核栈的内存区</span>
    
    <span class="token comment">//省略了进程的权能、性能跟踪、信号、numa、cgroup等内容</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>task_struct 的创建：在新版本中，从 SLAB 中分配 task_struct 结构体以及从伙伴内存系统分配内核栈</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">alloc_pages_node</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> THREADINFO_GFP<span class="token punctuation">,</span>
                         THREAD_SIZE_ORDER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配两个页面</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> <span class="token function">kasan_reset_tag</span><span class="token punctuation">(</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> tsk<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span><span class="token comment">//让task_struct结构的stack字段指向page的地址</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在task_struct_cachep内存对象中分配一个task_struct结构休对象 </span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">dup_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>orig<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">;</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span>
    tsk <span class="token operator">=</span> <span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct结构体</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tsk<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    stack <span class="token operator">=</span> <span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内核栈</span>
    tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> stack<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tsk<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span> <span class="token keyword">int</span> trace<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> pidfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct和内核栈</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

pid_t <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u64 clone_flags <span class="token operator">=</span> args<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    pid_t nr<span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token comment">//复制进程</span>
    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> nr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//建立进程接口</span>
<span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> args <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="进程地址空间">进程地址空间</h4>
<ul>
<li>
<p>Linux 是支持虚拟内存的操作系统内核，<code>mm_struct</code> 结构是 Linux 用于描述一个进程的地址空间的数据结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span> <span class="token comment">//虚拟地址区间链表VMAs</span>
        <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span>   <span class="token comment">//组织vm_area_struct结构的红黑树的根</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>    <span class="token comment">//进程虚拟地址空间大小</span>
        pgd_t <span class="token operator">*</span> pgd<span class="token punctuation">;</span>        <span class="token comment">//指向MMU页表</span>
        atomic_t mm_users<span class="token punctuation">;</span> <span class="token comment">//多个进程共享这个mm_struct</span>
        atomic_t mm_count<span class="token punctuation">;</span> <span class="token comment">//mm_struct结构本身计数 </span>
        atomic_long_t pgtables_bytes<span class="token punctuation">;</span><span class="token comment">//页表占用了多个页</span>
        <span class="token keyword">int</span> map_count<span class="token punctuation">;</span>      <span class="token comment">//多少个VMA</span>
        spinlock_t page_table_lock<span class="token punctuation">;</span> <span class="token comment">//保护页表的自旋锁</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mmlist<span class="token punctuation">;</span> <span class="token comment">//挂入mm_struct结构的链表</span>
        <span class="token comment">//进程应用程序代码开始、结束地址，应用程序数据的开始、结束地址 </span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
        <span class="token comment">//进程应用程序堆区的开始、当前地址、栈开始地址 </span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
        <span class="token comment">//进程应用程序参数区开始、结束地址</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20221205-mmstruct.png" alt=""></p>
</blockquote>
</li>
<li>
<p>mm_struct 实例变量的创建</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在mm_cachep内存对象中分配一个mm_struct结构休对象</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>mm_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span><span class="token function">dup_mm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>oldmm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>
    <span class="token comment">//分配mm_struct结构</span>
    mm <span class="token operator">=</span> <span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>
    <span class="token comment">//复制mm_struct结构</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldmm<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> mm<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>min_flt <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>maj_flt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>nvcsw <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>nivcsw <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配mm_struct结构的实例变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>
good_mm<span class="token operator">:</span>
    tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
fail_nomem<span class="token operator">:</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="Linux-进程文件表">Linux 进程文件表</h4>
<ul>
<li>
<p>一个进程对一个文件进行读写操作之前，必须先打开文件，这个打开的文件就记录在进程的文件表中，它由task_struct结构中的files字段指向。这里指向的其实是个<strong>files_struct结构</strong>，代码如下所示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>
 
    atomic_t count<span class="token punctuation">;</span><span class="token comment">//自动计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> __rcu <span class="token operator">*</span>fdt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> fdtab<span class="token punctuation">;</span>
    spinlock_t file_lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_fd<span class="token punctuation">;</span><span class="token comment">//下一个文件句柄</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//执行exec()时要关闭的文件句柄</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> open_fds_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> full_fds_bits_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span> fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//默认情况下打开文件的指针数组</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="Linux-进程调度">Linux 进程调度</h3>
<p>进程调度实体</p>
<p>进程运行队列</p>
<p>调度实体和运行队列的关系</p>
<p>调度器类</p>
<h2 id="07-设备管理与驱动">07 | 设备管理与驱动</h2>
<h3 id="Linux-设备信息">Linux 设备信息</h3>
<ul>
<li>Linux 的设计哲学就是一切皆文件，对设备文件进行操作就等同于操作具体的设备</li>
<li>Linux 设备文件在 <code>/sys/bus</code> 目录下查看，Linux 用总线组织设备和驱动</li>
</ul>
<h4 id="核心数据结构">核心数据结构</h4>
<h5 id="kobject-kset">kobject/kset</h5>
<ul>
<li>
<p><code>kobject</code> 和 <code>kset</code> 是构成 <code>/sys</code> 目录下（sysfs 文件系统挂载在此目录下）的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，它们都能表示一个目录或者文件节点，kset 与 kobject 结构只是基础数据结构</p>
</li>
<li>
<p>kobject：一个 kobject 对应着 /sys 目录下的一个目录或者文件，kobject 挂载在 kset 下并且指向了 kset，而 kset 结构中本身又包含一个 kobject 结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span>           <span class="token comment">//名称，反映在sysfs中</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    entry<span class="token punctuation">;</span>       <span class="token comment">//挂入kset结构的链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span>      <span class="token operator">*</span>parent<span class="token punctuation">;</span>     <span class="token comment">//指向父结构 </span>
    <span class="token keyword">struct</span> <span class="token class-name">kset</span>     <span class="token operator">*</span>kset<span class="token punctuation">;</span>           <span class="token comment">//指向所属的kset</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobj_type</span>    <span class="token operator">*</span>ktype<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span>  <span class="token operator">*</span>sd<span class="token punctuation">;</span>         <span class="token comment">//指向sysfs文件系统目录项 </span>
    <span class="token keyword">struct</span> <span class="token class-name">kref</span>     kref<span class="token punctuation">;</span>            <span class="token comment">//引用计数器结构</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_initialized<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//初始化状态</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_in_sysfs<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//是否在sysfs中</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_add_uevent_sent<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_remove_uevent_sent<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uevent_suppress<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>kset：既是 kobject 的容器，同时本身还是一个 kobject</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span> <span class="token comment">//挂载kobject结构的链表</span>
    spinlock_t list_lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span><span class="token comment">//自身包含一个kobject结构</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kset_uevent_ops</span> <span class="token operator">*</span>uevent_ops<span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>Linux 内核中至少有两个顶层 kset</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>devices_kset<span class="token punctuation">;</span><span class="token comment">//管理所有设备</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>bus_kset<span class="token punctuation">;</span><span class="token comment">//管理所有总线</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>system_kset<span class="token punctuation">;</span>
<span class="token keyword">int</span> __init <span class="token function">devices_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    devices_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"devices"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device_uevent_ops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立设备kset</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> __init <span class="token function">buses_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bus_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"bus"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bus_uevent_ops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立总线kset</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bus_kset<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    system_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>devices_kset<span class="token operator">-&gt;</span>kobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在设备kset之下建立system的kset</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>system_kset<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>kset 和 kobject 在逻辑上形成的层次结构</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220830-kobject-and-kset.png" alt=""></p>
</li>
</ul>
<h5 id="总线">总线</h5>
<ul>
<li>
<p>总线是 Linux 设备的基础，它可以表示 CPU 与设备的连接</p>
</li>
<li>
<p>Linux 把总线抽象成 <code>bus_type</code> 结构，结构中包括总线名字、总线属性，还有操作该总线下所有设备通用操作函数的指针，可以看出，总线不仅仅是组织设备和驱动的容器，还是<strong>同类设备的共有功能的抽象层</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//总线名称</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>dev_name<span class="token punctuation">;</span><span class="token comment">//用于列举设备，如（"foo%u", dev-&gt;id）</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span>       <span class="token operator">*</span>dev_root<span class="token punctuation">;</span><span class="token comment">//父设备</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>bus_groups<span class="token punctuation">;</span><span class="token comment">//总线的默认属性</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>dev_groups<span class="token punctuation">;</span><span class="token comment">//总线上设备的默认属性</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>drv_groups<span class="token punctuation">;</span><span class="token comment">//总线上驱动的默认属性</span>
    <span class="token comment">//每当有新的设备或驱动程序被添加到这个总线上时调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>uevent<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kobj_uevent_env</span> <span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配的设备</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将设备状态同步到软件状态时调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_state<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当一个设备从这个总线上删除时被调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当系统关闭时被调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以使设备重新上线（在下线后）</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>online<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以使设备离线，以便热移除。可能会失败。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>offline<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当这个总线上的设备想进入睡眠模式时调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以使该总线上的一个设备脱离睡眠模式</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以找出该总线上的一个设备支持多少个虚拟设备功能</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>num_vf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以在该总线上的设备配置DMA</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>dma_configure<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该总线的电源管理操作，回调特定的设备驱动的pm-ops</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dev_pm_ops</span> <span class="token operator">*</span>pm<span class="token punctuation">;</span>
    <span class="token comment">//此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iommu_ops</span> <span class="token operator">*</span>iommu_ops<span class="token punctuation">;</span>
    <span class="token comment">//驱动核心的私有数据，只有驱动核心能够接触这个</span>
    <span class="token keyword">struct</span> <span class="token class-name">subsys_private</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> lock_key<span class="token punctuation">;</span>
    <span class="token comment">//当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备</span>
    bool need_parent_lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>其中 <code>subsys_private</code> 是总线的驱动核心的私有数据，通过 bus_kset 可以找到所有的 kset，通过 kset 又能找到 subsys_private，再通过subsys_private就可以找到总线了，也可以找到该总线上所有的设备与驱动</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//通过kobject找到对应的subsys_private</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">to_subsys_private</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token function">container_of</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">subsys_private</span><span class="token punctuation">,</span> subsys<span class="token punctuation">.</span>kobj<span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">subsys_private</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kset</span> subsys<span class="token punctuation">;</span><span class="token comment">//定义这个子系统结构的kset</span>
    <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>devices_kset<span class="token punctuation">;</span><span class="token comment">//该总线的"设备"目录，包含所有的设备</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> interfaces<span class="token punctuation">;</span><span class="token comment">//总线相关接口的列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> mutex<span class="token punctuation">;</span><span class="token comment">//保护设备，和接口列表</span>
    <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>drivers_kset<span class="token punctuation">;</span><span class="token comment">//该总线的"驱动"目录，包含所有的驱动</span>
    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_devices<span class="token punctuation">;</span><span class="token comment">//挂载总线上所有设备的可迭代链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_drivers<span class="token punctuation">;</span><span class="token comment">//挂载总线上所有驱动的可迭代链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">blocking_notifier_head</span> bus_notifier<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> drivers_autoprobe<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token operator">*</span>bus<span class="token punctuation">;</span>   <span class="token comment">//指向所属总线</span>
    <span class="token keyword">struct</span> <span class="token class-name">kset</span> glue_dirs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span><span class="token comment">//指向这个结构所关联类结构的指针</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h5 id="设备">设备</h5>
<ul>
<li>
<p>Linux 使用 <code>device</code> 结构体表示一个设备，里面包含了一个设备的所有信息，其中有总线和驱动指针，这能帮助设备找到自己的驱动程序和总线</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span>       <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向父设备</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_private</span>   <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//设备的私有数据</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>init_name<span class="token punctuation">;</span> <span class="token comment">//设备初始化名字</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">device_type</span> <span class="token operator">*</span>type<span class="token punctuation">;</span><span class="token comment">//设备类型</span>
    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token operator">*</span>bus<span class="token punctuation">;</span>  <span class="token comment">//指向设备所属总线</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>driver<span class="token punctuation">;</span><span class="token comment">//指向设备的驱动</span>
    <span class="token keyword">void</span>        <span class="token operator">*</span>platform_data<span class="token punctuation">;</span><span class="token comment">//设备平台数据</span>
    <span class="token keyword">void</span>        <span class="token operator">*</span>driver_data<span class="token punctuation">;</span><span class="token comment">//设备驱动的私有数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">dev_links_info</span>   links<span class="token punctuation">;</span><span class="token comment">//设备供应商链接</span>
    <span class="token keyword">struct</span> <span class="token class-name">dev_pm_info</span>  power<span class="token punctuation">;</span><span class="token comment">//用于设备的电源管理</span>
    <span class="token keyword">struct</span> <span class="token class-name">dev_pm_domain</span>    <span class="token operator">*</span>pm_domain<span class="token punctuation">;</span><span class="token comment">//提供在系统暂停时执行调用</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_MSI_IRQ</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    msi_list<span class="token punctuation">;</span><span class="token comment">//主机的MSI描述符链表</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">dev_archdata</span> archdata<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_node</span>  <span class="token operator">*</span>of_node<span class="token punctuation">;</span> <span class="token comment">//用访问设备树节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">fwnode_handle</span>    <span class="token operator">*</span>fwnode<span class="token punctuation">;</span> <span class="token comment">//设备固件节点</span>
    dev_t           devt<span class="token punctuation">;</span>   <span class="token comment">//用于创建sysfs "dev"</span>
    u32         id<span class="token punctuation">;</span> <span class="token comment">//设备实例id</span>
    spinlock_t      devres_lock<span class="token punctuation">;</span><span class="token comment">//设备资源链表锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    devres_head<span class="token punctuation">;</span><span class="token comment">//设备资源链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">class</span>        <span class="token operator">*</span>class<span class="token punctuation">;</span><span class="token comment">//设备的类</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>  <span class="token comment">//可选的属性组</span>
    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在所有引用结束后释放设备</span>
    <span class="token keyword">struct</span> <span class="token class-name">iommu_group</span>  <span class="token operator">*</span>iommu_group<span class="token punctuation">;</span><span class="token comment">//该设备属于的IOMMU组</span>
    <span class="token keyword">struct</span> <span class="token class-name">dev_iommu</span>    <span class="token operator">*</span>iommu<span class="token punctuation">;</span><span class="token comment">//每个设备的通用IOMMU运行时数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>device 结构中同样包含了 kobject，这使得设备可以加入 kset 和 kobject 组建的层次结构中</p>
</li>
</ul>
<h5 id="驱动">驱动</h5>
<ul>
<li>
<p>Linux 中 <code>device_driver</code> 结构表示一个驱动，其中包含了驱动程序的相关信息，结构中包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//驱动名称</span>
    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span>     <span class="token operator">*</span>bus<span class="token punctuation">;</span><span class="token comment">//指向总线</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span>       <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//模块持有者</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>mod_name<span class="token punctuation">;</span><span class="token comment">//用于内置模块</span>
    bool suppress_bind_attrs<span class="token punctuation">;</span><span class="token comment">//禁用通过sysfs的绑定/解绑</span>
    <span class="token keyword">enum</span> <span class="token class-name">probe_type</span> probe_type<span class="token punctuation">;</span><span class="token comment">//要使用的探查类型（同步或异步）</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">of_device_id</span>   <span class="token operator">*</span>of_match_table<span class="token punctuation">;</span><span class="token comment">//开放固件表</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">acpi_device_id</span> <span class="token operator">*</span>acpi_match_table<span class="token punctuation">;</span><span class="token comment">//ACPI匹配表</span>
    <span class="token comment">//被调用来查询一个特定设备的存在</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将设备状态同步到软件状态时调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_state<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//关机时调用，使设备停止</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以使设备进入睡眠模式，通常是进入一个低功率状态</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用以使设备从睡眠模式中恢复</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//默认属性</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>
    <span class="token comment">//绑定设备的属性</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>dev_groups<span class="token punctuation">;</span>
    <span class="token comment">//设备电源操作</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dev_pm_ops</span> <span class="token operator">*</span>pm<span class="token punctuation">;</span>
    <span class="token comment">//当sysfs目录被写入时被调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>coredump<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//驱动程序私有数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">driver_private</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><code>driver_private</code> 结构中同样包含 kobject，用于组织所有的驱动，还指向驱动本身，这和 bus_type 中的 subsys_private 结构的机制如出一辙</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">driver_private</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_devices<span class="token punctuation">;</span><span class="token comment">//驱动管理的所有设备的链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">klist_node</span> knode_bus<span class="token punctuation">;</span><span class="token comment">//加入bus链表的节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">module_kobject</span> <span class="token operator">*</span>mkobj<span class="token punctuation">;</span><span class="token comment">//指向用kobject管理模块节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>driver<span class="token punctuation">;</span><span class="token comment">//指向驱动本身</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h4 id="文件操作函数">文件操作函数</h4>
<ul>
<li>
<p>在前面驱动程序核心数据结构的基础上，Linux 系统中提供了更为高级的封装，Linux 将设备分成几类分别是：字符设备、块设备、网络设备以及杂项设备</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>描述&amp;举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符设备</td>
<td>以字节流形式被访问的设备，比如字符终端和串口设备</td>
</tr>
<tr>
<td>块设备</td>
<td>以数据块形式被访问的设备，比如硬盘、光盘</td>
</tr>
<tr>
<td>网络设备</td>
<td>主机与主机之间进行数据交换的设备</td>
</tr>
<tr>
<td>杂项设备</td>
<td>一些不符合 LInux 预先确定的字符设备划分为杂项设备</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>以杂项设备为例，Linux 用 <code>miscdevice</code> 结构表示一个杂项设备，它一般在驱动程序代码文件中静态定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">miscdevice</span>  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> minor<span class="token punctuation">;</span><span class="token comment">//设备号</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//设备名称</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">;</span><span class="token comment">//文件操作函数结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span><span class="token comment">//链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向父设备的device结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>this_device<span class="token punctuation">;</span><span class="token comment">//指向本设备的device结构</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nodename<span class="token punctuation">;</span><span class="token comment">//节点名字</span>
    umode_t mode<span class="token punctuation">;</span><span class="token comment">//访问权限</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>this_device</code> 指针指向下层的、属于这个杂项设备的 <code>device</code> 结构</p>
</li>
<li>
<p>设备一经注册就会在 sys 相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在 <code>file_operations</code> 结构中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//所在的模块</span>
    <span class="token function">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整读写偏移</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//映射</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>以打开操作为例看 Linux 如何调用到 file_operations 结构中的函数：打开系统调用接口 → <code>filp_open</code> 函数 → <code>file_open_name</code> 函数 → <code>do_filp_open</code> 函数 → <code>path_openat</code> 函数 → <code>do_o_path</code> 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_o_path</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span>
	<span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token function">path_lookupat</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">audit_inode</span><span class="token punctuation">(</span>nd<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> path<span class="token punctuation">.</span>dentry<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		error <span class="token operator">=</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> file<span class="token punctuation">,</span> <span class="token function">current_cred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">path_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    file<span class="token operator">-&gt;</span>f_path <span class="token operator">=</span> <span class="token operator">*</span>path<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token function">d_backing_inode</span><span class="token punctuation">(</span>path<span class="token operator">-&gt;</span>dentry<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//省略</span>
    f<span class="token operator">-&gt;</span>f_op <span class="token operator">=</span> <span class="token function">fops_get</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_fop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取文件节点的file_operations</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>open<span class="token punctuation">)</span><span class="token comment">//如果open为空则调用file_operations结构中的open函数</span>
        open <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>open<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>open<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        error <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//省略</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>file_operations 结构的地址存在一个文件的 inode 结构中，在 Linux 系统中，都是用 inode 结构表示一个文件，不管它是数据文件还是设备文件</p>
</blockquote>
</li>
</ul>
<h3 id="实现简单字符设备驱动">实现简单字符设备驱动</h3>
<blockquote>
<p>环境 ubuntu 20.04，内核版本 5.4.0-54-generic</p>
</blockquote>
<ol>
<li>
<p>编写hello驱动代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/moduleparam.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/slab.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">BUFFER_MAX</span>    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">OK</span>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ERROR</span>         <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>gDev<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>gFile<span class="token punctuation">;</span>
dev_t  devNum<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> subDevNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> reg_major  <span class="token operator">=</span>  <span class="token number">232</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> reg_minor <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>buffer<span class="token punctuation">;</span>
<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

ssize_t <span class="token function">hello_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_write\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
ssize_t <span class="token function">hello_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    devNum <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>reg_major<span class="token punctuation">,</span> reg_minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据主设备号和次设备号手动生成设备号</span>
    <span class="token comment">//注册到内核</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>OK <span class="token operator">==</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">,</span> <span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"register_chrdev_region ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"register_chrdev_region error n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">" hello driver init \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//申请结构体</span>
    gDev <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cdev表示字符设备</span>
    gFile <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>open <span class="token operator">=</span> hello_open<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>read <span class="token operator">=</span> hello_read<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>write <span class="token operator">=</span> hello_write<span class="token punctuation">;</span>
    gFile<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>
    
    <span class="token function">cdev_init</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cdev_add</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> devNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//驱动卸载</span>
    <span class="token function">cdev_del</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//module_init 声明驱动的入口函数 hello_init</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//module_exit 声明驱动的出口函数 hello_exit</span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//模块许可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>编写Makefile</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>
obj-m <span class="token operator">:=</span> helloDev.o <span class="token comment">#内核编译系统进行识别</span>
<span class="token keyword">else</span>
PWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> pwd<span class="token punctuation">)</span> 
KDIR<span class="token operator">:=</span> /lib/modules/4.4.0-31-generic/build <span class="token comment">#内核头文件的目录</span>
<span class="token comment">#KDIR := /lib/modules/`uname -r`/build </span>
<span class="token symbol">all</span><span class="token punctuation">:</span>
	make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> <span class="token comment">#-C进入内核目录执行</span>
<span class="token symbol">clean</span><span class="token punctuation">:</span>	
	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~
<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>驱动不能链接和使用应用层的任何 lib 库，驱动需要引用内核的头文件和函数，所以编译时需指定内核源码的地址</p>
</blockquote>
</li>
<li>
<p>执行make进行编译和加载hello驱动到内核</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-driver-test.png" alt="加载驱动并查看内核日志"></p>
<p>可见执行insmod的时候，驱动文件里的hello_init被调用了</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-check-driver.png" alt="lsmod命令查看驱动"></p>
</li>
<li>
<p>编写应用程序测试hello驱动</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>
    fd_set fdset<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello world"</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\r\n"</span><span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	
	<span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open successe\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    w_len <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    r_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\r\n"</span><span class="token punctuation">,</span> w_len<span class="token punctuation">,</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\r\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>手动创建设备文件</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mknod</span> /dev/hello c <span class="token number">232</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-driver-test-succeeded.png" alt="执行测试程序"></p>
<p>执行dmesg查看驱动输出，发现驱动的hell_open, hello_write, hello_read被依次调用了</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-test.png" alt=""></p>
</li>
</ol>
<h3 id="应用层write-怎样调用到驱动的write">应用层write()怎样调用到驱动的write()</h3>
<ol>
<li>
<p>对write函数，C库只会做一些检查，然后就陷入write的系统调用，系统调用会通过软中断的方式陷入到内核空间里去执行</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211113-calling-process.png" alt="调用流程"></p>
</li>
<li>
<p>操作系统的系统调用是如何知道应该调用哪个驱动里的write函数？</p>
<ul>
<li>
<p>在hello驱动里，有定义主次设备号并组合成了devNum</p>
<p><code>cdev_init(gDev, gFile);</code>  建立了 gDev 和 gFile 的逻辑关系</p>
<p><code>cdev_add(gDev, devNum, 1);</code> 建立了 gDev 和 devNum 的逻辑关系</p>
</li>
<li>
<p>以上两句代码其实建立了gFile 和 devNum 的对应关系，也就是 file_operations 和主次设备号的对应关系</p>
</li>
<li>
<p>打开设备文件 /dev/hello 后就已经建立了这个文件和 hello 驱动里的 struct file 和 struct file_operations 的对应关系</p>
</li>
</ul>
</li>
<li>
<p>阅读内核 write 系统调用的实现部分</p>
<p>关键代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write<span class="token punctuation">)</span> <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>判断 hello 驱动里有没有定义 write 函数，如果有，那就调用</p>
<p>所以按照如上的路径，应用程序里的 write 就顺利的调用到了 hello 驱动里的 write 函数</p>
<blockquote>
<p>注意：在 linux 里，在应用层用文件句柄也就是fd表示一个打开的文件，但是在内核里用 <code>struct file</code> 表示一个打开的文件，用 <code>struct file_operations</code> 表示对该文件的操作，他们之间是一一对应的</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211113-write-function-call.png" alt="fs/read_write.c"></p>
</blockquote>
</li>
</ol>
<p>​</p>
<h3 id="字符设备驱动代码添加到内核源码树">字符设备驱动代码添加到内核源码树</h3>
<ol>
<li>
<p>拷贝源码到字符设备文件夹中</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-move.png" alt=""></p>
</li>
<li>
<p>添加Makefile</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_HELLO<span class="token punctuation">)</span> <span class="token operator">+=</span> helloDev.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>将驱动添加到内核源码树中，修改 Kconfig 文件</p>
<pre class="line-numbers language-none"><code class="language-none">config HELLO
     tristate "hello device"
     default y
     help
       hello device<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看配置</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-add-success.png" alt=""></p>
</li>
<li>
<p>重新编译内核（驱动编译到内核中，静态加载）</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-recompiling-kernel.png" alt=""></p>
</li>
</ol>
<h3 id="字符设备驱动到平台设备驱动">字符设备驱动到平台设备驱动</h3>
<ol>
<li>
<p>platform驱动</p>
<ul>
<li>
<p>platform是一条虚拟总线，可以将一些设备放置在该虚拟设备总线上，设备为platform_device，要操作这些设备需要使用匹配的驱动，驱动为platform_driver</p>
</li>
<li>
<p>使用platform总线的好处</p>
<ul>
<li>把设备都挂接在一个pseudo总线上，便于管理，同时也符合Linux的设备模型机制。其结果是，配套的sysfs节点、设备电源管理都成为可能</li>
<li>隔离设备和驱动。在BSP中定义platform设备和它使用的资源、设备的具体配置信息；而在驱动中，只需要通过通用的API去获取资源和数据，做到了BSP相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>将char设备驱动改造为platform驱动</p>
<p>当执行insmod时，驱动会在总线上查找与其对应的设备，查找成功后执行 probe 动作进行设备初始化，当驱动卸载后执行remove函数，进行退出动作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/platform_device.h&gt;</span></span>
<span class="token comment">//</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_plat_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">resource</span> hello_dev_resource<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token punctuation">.</span>start <span class="token operator">=</span> LEDBASE<span class="token punctuation">,</span>
		<span class="token punctuation">.</span>end   <span class="token operator">=</span> LEDBASE <span class="token operator">+</span> LEDLEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>
		<span class="token punctuation">.</span>flags <span class="token operator">=</span> IORESOURCE_MEM<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//平台设备结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">platform_device</span> hello_device <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span>name		  <span class="token operator">=</span> <span class="token string">"hello-device"</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span>id		  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span>num_resources	  <span class="token operator">=</span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>hello_dev_resource<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//指定资源</span>
	<span class="token punctuation">.</span>resource	  <span class="token operator">=</span> hello_dev_resource<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>dev <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token punctuation">.</span>release <span class="token operator">=</span> hello_plat_release<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//平台驱动结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> hellodev_driver <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span>probe		<span class="token operator">=</span> hellodev_probe<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>remove		<span class="token operator">=</span> hellodev_remove<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>driver		<span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token punctuation">.</span>owner	<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
		<span class="token punctuation">.</span>name	<span class="token operator">=</span> <span class="token string">"hello-device"</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//初始化</span>
<span class="token keyword">int</span> <span class="token function">charDrvInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//注册平台设备和驱动</span>
	<span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hello_device<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">platform_driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hellodev_driver<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">void</span> __exit <span class="token function">charDrvExit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hello_device<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">platform_driver_unregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hellodev_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>charDrvInit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>charDrvExit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>源码</p>
<p>platform_device结构体</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span>	<span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token keyword">int</span>		id<span class="token punctuation">;</span>
	bool		id_auto<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">device</span>	dev<span class="token punctuation">;</span>
	u32		num_resources<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">resource</span>	<span class="token operator">*</span>resource<span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">platform_device_id</span>	<span class="token operator">*</span>id_entry<span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>driver_override<span class="token punctuation">;</span> <span class="token comment">/* Driver name to force a match */</span>

	<span class="token comment">/* MFD cell pointer */</span>
	<span class="token keyword">struct</span> <span class="token class-name">mfd_cell</span> <span class="token operator">*</span>mfd_cell<span class="token punctuation">;</span>

	<span class="token comment">/* arch specific additions */</span>
	<span class="token keyword">struct</span> <span class="token class-name">pdev_archdata</span>	archdata<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>platform_driver结构体</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">device_driver</span> driver<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">platform_device_id</span> <span class="token operator">*</span>id_table<span class="token punctuation">;</span>
	bool prevent_deferred_probe<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设备注册</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token function">device_initialize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">arch_setup_pdev_archdata</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">platform_device_add</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>驱动注册</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//platform_driver_register -&gt; __platform_driver_register</span>

<span class="token keyword">int</span> <span class="token function">__platform_driver_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span>
				<span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>owner <span class="token operator">=</span> owner<span class="token punctuation">;</span>
	drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>bus <span class="token operator">=</span> <span class="token operator">&amp;</span>platform_bus_type<span class="token punctuation">;</span>
	drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>probe <span class="token operator">=</span> platform_drv_probe<span class="token punctuation">;</span>
	drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>remove <span class="token operator">=</span> platform_drv_remove<span class="token punctuation">;</span>
	drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>shutdown <span class="token operator">=</span> platform_drv_shutdown<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">bus_type</span> platform_bus_type <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span>name		<span class="token operator">=</span> <span class="token string">"platform"</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span>dev_groups	<span class="token operator">=</span> platform_dev_groups<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>match		<span class="token operator">=</span> platform_match<span class="token punctuation">,</span><span class="token comment">//match函数用于之后匹配</span>
	<span class="token punctuation">.</span>uevent		<span class="token operator">=</span> platform_uevent<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>pm		<span class="token operator">=</span> <span class="token operator">&amp;</span>platform_dev_pm_ops<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>驱动的匹配原则</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//driver_register -&gt; bus_add_driver -&gt; driver_attach</span>

<span class="token comment">//总线上找到设备，让驱动与设备进行匹配</span>
<span class="token keyword">int</span> <span class="token function">driver_attach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">bus_for_each_dev</span><span class="token punctuation">(</span>drv<span class="token operator">-&gt;</span>bus<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> drv<span class="token punctuation">,</span> __driver_attach<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__driver_attach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv <span class="token operator">=</span> data<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">driver_match_device</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token operator">-&gt;</span>driver<span class="token punctuation">)</span>
		<span class="token function">driver_probe_device</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">//driver_probe_device -&gt; really_probe -&gt; drv-&gt;probe(dev);//调用驱动的probe</span>
	<span class="token function">device_unlock</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span>
		<span class="token function">device_unlock</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">driver_match_device</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span>
				      <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> drv<span class="token operator">-&gt;</span>bus<span class="token operator">-&gt;</span>match <span class="token operator">?</span> drv<span class="token operator">-&gt;</span>bus<span class="token operator">-&gt;</span><span class="token function">match</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//bus上定义的match函数</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">platform_match</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev <span class="token operator">=</span> <span class="token function">to_platform_device</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span>pdrv <span class="token operator">=</span> <span class="token function">to_platform_driver</span><span class="token punctuation">(</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* fall-back to driver name match */</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>pdev<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> drv<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="08-文件管理">08 | 文件管理</h2>
<h3 id="文件系统">文件系统</h3>
<p>文件系统解决的就是如何把许多文件储存在某一种储存设备上，方便进程对各种文件执行打开、关闭、读写、增加和删除等操作。因为这些操作实际上非常复杂，所以操作系统中分出一个子系统专门处理这些问题，这个系统就叫<strong>文件系统</strong>。</p>
<p>文件系统的核心现在我们还没法直观地感受到，但是它在上层为用户或者进程提供了一个逻辑视图，也就是目录结构。</p>
<p>下图中就是典型的文件系统逻辑视图，从/（根）目录开始，就能找到每个文件、每个目录和每个目录下的所有文件。我们可以看出目录也是文件的一部分，它也扮演了“组织仓库管理员”的角色，可以对文件进行分层分类，以便用户对众多文件进行管理。</p>
<h3 id="VFS">VFS</h3>
<ul>
<li>
<p>VFS（Virtual Filesystem）可以理解为通用文件系统抽象层，让不同的文件系统表现出一致的行为，VFS向上对应用提供了操作文件的标准接口，向下规范了一个文件系统要接入VFS必需要实现的机制</p>
</li>
<li>
<p>VFS提供一系列数据结构和具体文件系统应该实现的回调函数，这样，一个文件系统就可以被安装到VFS中</p>
</li>
</ul>
<h4 id="数据结构-3">数据结构</h4>
<ul>
<li>
<p>VFS 为了屏蔽各个文件系统的差异，就必须要定义一组通用的数据结构，规范各个文件系统的实现，每种结构都对应一套回调函数集合，这是典型的<strong>面向对象的设计方法</strong></p>
</li>
<li>
<p>这些数据结构包含描述文件系统信息的超级块、表示文件名称的目录结构、描述文件自身信息的索引节点结构、表示一个打开文件的实例结构</p>
</li>
</ul>
<h5 id="超级块结构">超级块结构</h5>
<ul>
<li>
<p>这个结构用于一个<strong>具体文件系统的相关信息</strong>，其中包含了 VFS 规定的标准信息，也有具体文件系统的特有信息</p>
</li>
<li>
<p>Linux 中的超级块结构是一个文件系统安装在 VFS 中的标识</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_list<span class="token punctuation">;</span> <span class="token comment">//超级块链表</span>
    dev_t           s_dev<span class="token punctuation">;</span>     <span class="token comment">//设备标识</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>       s_blocksize_bits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_blocksize<span class="token punctuation">;</span><span class="token comment">//以字节为单位的块大小</span>
    loff_t          s_maxbytes<span class="token punctuation">;</span> <span class="token comment">//一个文件最大多少字节</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>s_type<span class="token punctuation">;</span> <span class="token comment">//文件系统类型</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">super_operations</span>   <span class="token operator">*</span>s_op<span class="token punctuation">;</span><span class="token comment">//超级块函数集合</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dquot_operations</span>   <span class="token operator">*</span>dq_op<span class="token punctuation">;</span><span class="token comment">//磁盘限额函数集合</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_flags<span class="token punctuation">;</span><span class="token comment">//挂载标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_magic<span class="token punctuation">;</span><span class="token comment">//文件系统魔数</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span>       <span class="token operator">*</span>s_root<span class="token punctuation">;</span><span class="token comment">//挂载目录</span>
    <span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> s_umount<span class="token punctuation">;</span><span class="token comment">//卸载信号量</span>
    <span class="token keyword">int</span>         s_count<span class="token punctuation">;</span><span class="token comment">//引用计数</span>
    atomic_t        s_active<span class="token punctuation">;</span><span class="token comment">//活动计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>s_bdev<span class="token punctuation">;</span><span class="token comment">//块设备</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>s_fs_info<span class="token punctuation">;</span><span class="token comment">//文件系统信息</span>
    time64_t           s_time_min<span class="token punctuation">;</span><span class="token comment">//最小时间限制</span>
    time64_t           s_time_max<span class="token punctuation">;</span><span class="token comment">//最大时间限制</span>
    <span class="token keyword">char</span>            s_id<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//标识名称</span>
    uuid_t          s_uuid<span class="token punctuation">;</span>     <span class="token comment">//文件系统的UUID</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_dentry_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的目录 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_inode_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的索引结点</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        s_sync_lock<span class="token punctuation">;</span><span class="token comment">//同步锁  </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes<span class="token punctuation">;</span>   <span class="token comment">//所有的索引节点</span>
    spinlock_t      s_inode_wblist_lock<span class="token punctuation">;</span><span class="token comment">//回写索引节点的锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes_wb<span class="token punctuation">;</span>    <span class="token comment">//挂载所有要回写的索引节点</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>在挂载文件系统时 VFS 会调用获取文件系统超级块的函数，用具体文件系统的信息构造一个上述结构的实例，有了这个实例 VFS 就能感知到文件系统了</p>
</li>
<li>
<p>超级块函数集合结构，结构中所有函数指针所指向的函数都应该要由一个具体文件系统实现</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//分配一个新的索引结点结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>alloc_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//销毁给定的索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destroy_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放给定的索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS在索引节点为脏(改变)时，会调用此函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dirty_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数用于将给定的索引节点写入磁盘</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">writeback_control</span> <span class="token operator">*</span>wbc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在最后一个指向索引节点的引用被释放后，VFS会调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>drop_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>evict_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//减少超级块计数调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//同步文件系统调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放超级块调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放文件系统调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>thaw_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unfreeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS通过调用该函数，获取文件系统状态</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>statfs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstatfs</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当指定新的安装选项重新安装文件系统时，VFS会调用此函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remount_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数中断安装操作。该函数被网络文件系统使用，如NFS</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>umount_begin<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>有了超级块和超级块函数集合结构 VFS 就能让一个文件系统的信息和表示变得规范了，也就是说，文件系统只要实现了 super_block 和 super_operations 两个结构就可以插入到 VFS</p>
</li>
</ul>
<h5 id="目录结构">目录结构</h5>
<ul>
<li>
<p>Linux 中所有文件都是用目录组织的，包括具体的文件系统也是挂载到某个目录下</p>
</li>
<li>
<p>VFS 用 <code>struct dentry</code> 来表示一个目录，dentry 结构中包含了目录名称和挂载子目录的链表，同时也能指向父目录，需要注意：目录也是文件，需要用 inode 索引结构来管理目录文件数据</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> d_flags<span class="token punctuation">;</span>       <span class="token comment">//目录标志</span>
    seqcount_spinlock_t d_seq<span class="token punctuation">;</span>  <span class="token comment">//锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">hlist_bl_node</span> d_hash<span class="token punctuation">;</span><span class="token comment">//目录的哈希链表    </span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token comment">//指向父目录</span>
    <span class="token keyword">struct</span> <span class="token class-name">qstr</span> d_name<span class="token punctuation">;</span>         <span class="token comment">//目录名称</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>      <span class="token comment">//指向目录文件的索引节点 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//短目录名</span>
    <span class="token keyword">struct</span> <span class="token class-name">lockref</span> d_lockref<span class="token punctuation">;</span>   <span class="token comment">//目录锁与计数</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token operator">*</span>d_op<span class="token punctuation">;</span><span class="token comment">//目录的函数集</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>d_sb<span class="token punctuation">;</span>   <span class="token comment">//指向超级块</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> d_time<span class="token punctuation">;</span>       <span class="token comment">//时间</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>d_fsdata<span class="token punctuation">;</span>         <span class="token comment">//指向具体文件系统的数据</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_lru<span class="token punctuation">;</span>     <span class="token comment">//LRU链表</span>
        wait_queue_head_t <span class="token operator">*</span>d_wait<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_child<span class="token punctuation">;</span>   <span class="token comment">//挂入父目录的链表节点 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_subdirs<span class="token punctuation">;</span> <span class="token comment">//挂载所有子目录的链表</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
<span class="token comment">//快速字符串保存关于字符串的 "元数据"（即长度和哈希值）</span>
<span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            HASH_LEN_DECLARE<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        u64 hash_len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//指向名称字符串</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>目录函数集，结构中的函数也需要具体文件系统实现，查找或者操作目录时 VFS 就会调用这些函数让具体文件系统根据自己储存设备上的目录信息处理并设置 dentry 结构中的信息，使文件系统中的目录和 VFS 的目录对应</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//该函数判断目录对象是否有效</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_weak_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数为目录项生成散列值，当目录项要加入散列表中时，VFS调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数来比较name1和name2两个文件名。多数文件系统使用VFS的默认操作，仅做字符串比较。对于有些文件系统，比如FAT，简单的字符串比较不能满足其需要，因为 FAT文件系统不区分大小写</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当目录项对象的计数值等于0时，VFS调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当分配目录时调用 </span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_init<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当目录项对象要被释放时，VFS调用该函数，默认情况下，它什么也不做</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_prune<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当一个目录项对象丢失了相关索引节点时，VFS调用该函数。默认情况下VFS会调用iput()函数释放索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_iput<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当需要生成一个dentry的路径名时被调用</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_dname<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当要遍历一个自动挂载时被调用（可选），这应该创建一个新的VFS挂载记录并将该记录返回给调用者</span>
    <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_automount<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//文件系统管理从dentry的过渡（可选）时，被调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_manage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//叠加/联合类型的文件系统实现此方法</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_real<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ____cacheline_aligned<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h5 id="文件索引结点">文件索引结点</h5>
<ul>
<li>
<p>VFS 用 inode 结构表示一个文件索引结点，它里面包含文件权限、文件所属用户、文件访问和修改时间、文件数据块号等一个文件的全部信息，<strong>一个 inode 结构就对应一个文件</strong>，但这个 inode 结构与某个具体文件系统上的 <em>“inode”</em> 结构并不是一一对应关系</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">{</span>
    umode_t         i_mode<span class="token punctuation">;</span><span class="token comment">//文件访问权限</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      i_opflags<span class="token punctuation">;</span><span class="token comment">//打开文件时的标志</span>
    kuid_t          i_uid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户id</span>
    kgid_t          i_gid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户组id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        i_flags<span class="token punctuation">;</span><span class="token comment">//标志</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span>   <span class="token operator">*</span>i_op<span class="token punctuation">;</span><span class="token comment">//inode函数集</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span>  <span class="token operator">*</span>i_sb<span class="token punctuation">;</span><span class="token comment">//指向所属超级块</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    <span class="token operator">*</span>i_mapping<span class="token punctuation">;</span><span class="token comment">//文件数据在内存中的页缓存</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       i_ino<span class="token punctuation">;</span><span class="token comment">//inode号</span>
    dev_t           i_rdev<span class="token punctuation">;</span><span class="token comment">//实际设备标志符</span>
    loff_t          i_size<span class="token punctuation">;</span><span class="token comment">//文件大小，以字节为单位</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_atime<span class="token punctuation">;</span><span class="token comment">//文件访问时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_mtime<span class="token punctuation">;</span><span class="token comment">//文件修改时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_ctime<span class="token punctuation">;</span><span class="token comment">//最后修改时间</span>
    spinlock_t      i_lock<span class="token punctuation">;</span> <span class="token comment">//保护inode的自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>          i_bytes<span class="token punctuation">;</span><span class="token comment">//使用的字节数</span>
    u8          i_blkbits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小；</span>
    u8          i_write_hint<span class="token punctuation">;</span>
    blkcnt_t        i_blocks<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_io_list<span class="token punctuation">;</span>  
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_lru<span class="token punctuation">;</span>      <span class="token comment">//在缓存LRU中的链表节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_sb_list<span class="token punctuation">;</span><span class="token comment">//在超级块中中的链表节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_wb_list<span class="token punctuation">;</span>
    atomic64_t      i_version<span class="token punctuation">;</span><span class="token comment">//版本号</span>
    atomic64_t      i_sequence<span class="token punctuation">;</span> 
    atomic_t        i_count<span class="token punctuation">;</span><span class="token comment">//计数</span>
    atomic_t        i_dio_count<span class="token punctuation">;</span><span class="token comment">//直接io进程计数</span>
    atomic_t        i_writecount<span class="token punctuation">;</span><span class="token comment">//写进程计数</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>i_fop<span class="token punctuation">;</span><span class="token comment">//文件函数集合 </span>
        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_lock_context</span>    <span class="token operator">*</span>i_flctx<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    i_data<span class="token punctuation">;</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>i_private<span class="token punctuation">;</span> <span class="token comment">//私有数据指针</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>inode 结构的函数集合，用于具体文件系统根据自己特有的信息构造出 VFS 使用的 inode 结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//VFS通过系统create()和open()接口来调用该函数，从而为dentry对象创建一个新的索引节点</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry中给出的文件名</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>lookup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统link()接口调用，用来创建硬连接。硬链接名称由dentry参数指定</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统unlink()接口调用，删除由目录项dentry链接的索引节点对象</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统symlik()接口调用，创建符号连接，该符号连接名称由symname指定，连接对象是dir目录中的dentry目录项</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>symlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被mkdir()接口调用，创建一个新目录。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mkdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被rmdir()接口调用，删除dentry目录项代表的文件</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rmdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被mknod()接口调用，创建特殊文件(设备文件、命名管道或套接字)。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mknod<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> dev_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数来移动文件。文件源路径在old_dir目录中，源文件由old_dentry目录项所指定，目标路径在new_dir目录中，目标文件由new_dentry指定</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rename<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统readlink()接口调用，拷贝数据到特定的缓冲buffer中。拷贝的数据来自dentry指定的符号链接</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，从一个符号连接查找他指向的索引节点</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>follow_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在follow_link()调用之后，该函数由vfs调用进行清除工作</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，修改文件的大小，在调用之前，索引节点的i_size项必须被设置成预期的大小</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>truncate<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许特定的访问模式，返回0，否则返回负值的错误码</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>permission<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被notify_change接口调用，在修改索引节点之后，通知发生了改变事件</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iattr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在通知索引节点需要从磁盘中更新时，VFS会调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>getattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstat</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，向dentry指定的文件设置扩展属性</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，拷贝给定文件的扩展属性name对应的数值</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>getxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数将特定文件所有属性列表拷贝到一个缓冲列表中</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>listxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数从给定文件中删除指定的属性</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>removexattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h5 id="打开的文件">打开的文件</h5>
<ul>
<li>
<p>VFS 设计了文件对象结构来表示进程已打开的文件，应用程序直接处理的就是文件，而不是超级块、索引节点或目录项，文件对象结构包含了访问模式、当前读写偏移等信息</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span>   fu_llist<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span>     fu_rcuhead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span>     f_path<span class="token punctuation">;</span> <span class="token comment">//文件路径</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span>        <span class="token operator">*</span>f_inode<span class="token punctuation">;</span>  <span class="token comment">//文件对应的inode</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>f_op<span class="token punctuation">;</span><span class="token comment">//文件函数集合</span>
    spinlock_t      f_lock<span class="token punctuation">;</span>  <span class="token comment">//自旋锁</span>
    <span class="token keyword">enum</span> <span class="token class-name">rw_hint</span>        f_write_hint<span class="token punctuation">;</span>
    atomic_long_t       f_count<span class="token punctuation">;</span><span class="token comment">//文件对象计数据</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        f_flags<span class="token punctuation">;</span><span class="token comment">//文件标志</span>
    fmode_t         f_mode<span class="token punctuation">;</span><span class="token comment">//文件权限</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        f_pos_lock<span class="token punctuation">;</span><span class="token comment">//文件读写位置锁</span>
    loff_t          f_pos<span class="token punctuation">;</span><span class="token comment">//进程读写文件的当前位置</span>
    u64         f_version<span class="token punctuation">;</span><span class="token comment">//文件版本</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>private_data<span class="token punctuation">;</span><span class="token comment">//私有数据</span>
<span class="token punctuation">}</span> __randomize_layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>进程结构中的文件表就是 file 结构的指针数组，进程每打开一个文件就会建立一个 file 结构实例并将其地址放入数组中，最后返回对应的数组下标（open 函数的返回）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>        <span class="token operator">*</span>fs<span class="token punctuation">;</span>    <span class="token comment">//进程相关的文件系统信息</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span>     <span class="token operator">*</span>files<span class="token punctuation">;</span><span class="token comment">//进程打开的所有文件</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
   * read mostly part
   */</span>
	atomic_t count<span class="token punctuation">;</span>
	bool resize_in_progress<span class="token punctuation">;</span>
	wait_queue_head_t resize_wait<span class="token punctuation">;</span>

	<span class="token keyword">struct</span> <span class="token class-name">fdtable</span> __rcu <span class="token operator">*</span>fdt<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">fdtable</span> fdtab<span class="token punctuation">;</span>
  <span class="token comment">/*
   * written part on a separate cache line in SMP
   */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">fdtable</span> <span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_fds<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span><span class="token operator">*</span>fd<span class="token punctuation">;</span>      <span class="token comment">/* current fd array */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>close_on_exec<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>open_fds<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>full_fds_bits<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>file 结构对应的函数集合 file_operations 结构，这些函数需要具体文件系统来实现，由 VFS 层来调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//所在的模块</span>
    <span class="token function">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整读写偏移</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读</span>
    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//映射</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h5 id="四大对象结构的关系">四大对象结构的关系</h5>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220814-vfs.png" style="zoom: 25%;">
<h4 id="文件操作">文件操作</h4>
<h5 id="打开文件">打开文件</h5>
<h5 id="读写文件">读写文件</h5>
<h5 id="关闭文件">关闭文件</h5>
<h3 id="文件系统实例">文件系统实例</h3>
<h3 id="基于-FUSE-实现自定义文件系统">基于 FUSE 实现自定义文件系统</h3>
<p>fuse文件系统</p>
<p>用户空间驱动</p>
<ul>
<li>
<p>1</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220223-fuse.png" alt=""></p>
</li>
</ul>
<h2 id="09-网络模块">09 | 网络模块</h2>
<blockquote>
<p>…</p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Booting/linux-bootstrap-4.html">内核引导过程：切换到64位模式</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Booting/linux-bootstrap-5.html">内核引导过程：内核解压</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364898425">深入理解Linux内核之内核线程</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mosYi_W-Rp1-HgdtxUqSEg">Linux kernel同步机制（上）</a>和<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-GnR-nryH_7xkNVhJ8AMNw">Linux kernel 同步机制（下）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133445693">spinlock前世今生</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/80589442">从CPU缓存一致性的角度看Linux spinlock的不可伸缩性</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crybaby/p/13062811.html">Linux x86 自旋锁内核源码分析</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364044713">Linux 读写锁 rwlock</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/viUgMAnVgC_bHyVifkHqsQ">自旋锁探秘</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377946859">Linux 用户空间与内核空间及分段机制</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.toutiao.com/a6855591224003265036/?log_from=42a7e1ffc21a_1637399126505">Linux 内核中逻辑、虚拟、线性和物理地址大扫盲</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mirage1993/article/details/71156109">Linux 内核中逻辑地址/虚拟地址/线性地址三者的区别</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8129309">页表映射机制：线性地址如何转为物理地址？</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">宵烛</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://night-candle.github.io/2021/11/19/linux-kernel/">http://night-candle.github.io/2021/11/19/linux-kernel/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">宵烛</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Linux/">
                                    <span class="chip bg-color">Linux</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/04/07/container-in-action/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="container-in-action">
                        
                        <span class="card-title">container-in-action</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            结合 Linux 操作系统的主要模块，把容器知识结构系统串联起来，同时看到 Namespace 和 Cgroups 带来的特殊性
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-04-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AE%B9%E5%99%A8/">
                        <span class="chip bg-color">容器</span>
                    </a>
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/02/04/cs-network-socket/">
                    <div class="card-image">
                        
                        <img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/cover-watermelon.jpg" class="responsive-img" alt="网络编程原理与实践">
                        
                        <span class="card-title">网络编程原理与实践</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文从实践出发，从问题的角度对网络编程相关的知识点进行阐述。和代码、实验进行关联，引出理论或算法的实际意义
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-02-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%A7%91/" class="post-category">
                                    计科
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                        <span class="chip bg-color">网络协议</span>
                    </a>
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                        <span class="chip bg-color">网络编程</span>
                    </a>
                    
                    <a href="/tags/socket/">
                        <span class="chip bg-color">socket</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('200')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 宵烛 Blog<br />'
            + '文章作者: 宵烛<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important; position: absolute;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <a href="/about" target="_blank">宵烛</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">95.2k</span>
            
            
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2021";
                        var startMonth = "1";
                        var startDate = "25";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/night-candle" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1219303301@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
    <div id="jsi-flying-fish-container" class="nav-wrapper" style="margin: 0px; padding: 0px;"></div>
    <script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
