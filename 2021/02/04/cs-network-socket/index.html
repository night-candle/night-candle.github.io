<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="网络编程原理与实践, CS 宵烛 xiaozhu NightCandle 计算机 网络安全">
    <meta name="description" content="本文从实践出发，从问题的角度对网络编程相关的知识点进行阐述。和代码、实验进行关联，引出理论或算法的实际意义">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>网络编程原理与实践 | 宵烛 Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 5.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">宵烛 Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">宵烛 Blog</div>
        <div class="logo-desc">
            
            学生 | 虚假CTF选手 | 计算机菜鸟
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://raw.githubusercontent.com/night-candle/figurebed/main/img/cover-watermelon.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">网络编程原理与实践</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                <span class="chip bg-color">网络协议</span>
                            </a>
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                                <span class="chip bg-color">网络编程</span>
                            </a>
                        
                            <a href="/tags/socket/">
                                <span class="chip bg-color">socket</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%A7%91/" class="post-category">
                                计科
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-02-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-05-05
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/cover-watermelon.jpg" alt=""></p>
<h2 id="00-前言-3">00 | 前言</h2>
<p>  在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，可以进行数据传递，从而实现资源的共享</p>
<p>  网络编程从大方面说就是对信息的发送到接受，通过操作相应 API 调度计算机硬件资源，并利用传输管道（网线）进行数据交换的过程</p>
<p>  一些关于网络编程方面的问题看似简单，但想做到完全理解却并不容易，学习高性能网络编程，需要掌握两个核心要点：<strong>第一就是理解网络协议，并在这个基础上和操作系统内核配合，感知各种网络 I/O 事件；第二就是学会使用线程处理并发</strong></p>
<p>  本文会从实践出发，从问题的角度对知识点进行阐述</p>
<p>​</p>
<p>​</p>
<h2 id="01-网络编程入门">01 | 网络编程入门</h2>
<h3 id="1-1-基本概念">1.1 基本概念</h3>
<h4 id="1-1-1-客户端-服务器网络模型">1.1.1 客户端 - 服务器网络模型</h4>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-network-model.png" alt=""></p>
<ol>
<li>
<p>当一个客户端需要服务时，它会向服务器端发送一个请求，这个请求是按照双方约定的格式来发送的，以便保证服务器端可以理解</p>
</li>
<li>
<p>服务器端收到这个请求后，会根据双方约定的格式解释它，并且以合适的方式进行操作</p>
</li>
<li>
<p>服务器端完成处理请求之后，会给客户端发送一个响应，然后等待客户端的下一步操作</p>
</li>
<li>
<p>客户端收到响应并进行处理</p>
<blockquote>
<p>区别出客户端和服务器，本质上是因为二者编程模型是不同的，<strong>但无论是客户端，还是服务器端，它们运行的单位都是进程</strong></p>
</blockquote>
</li>
</ol>
<p>​</p>
<p>​</p>
<h4 id="1-1-2-IP-和端口">1.1.2 IP 和端口</h4>
<ul>
<li>
<p>在 TCP/IP 协议栈中，IP 用来表示网络世界的地址</p>
</li>
<li>
<p>在一台计算机上是可以同时存在多个连接的，区分出不同的连接就需要用到端口这个概念</p>
<blockquote>
<p>端口号是一个 16 位的整数，最多为 65536</p>
</blockquote>
</li>
<li>
<p><strong>计算机的 IP 地址是唯一的，每个连接的端口号是不同的</strong></p>
</li>
<li>
<p>当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为<strong>临时端口</strong>，服务器端的端口通常是一个众所周知的端口<code>Well Known Ports</code></p>
</li>
<li>
<p>一个连接可以通过客户端 - 服务器端的 IP 和端口唯一确定，这叫做<strong>套接字对</strong>，按照（客户端地址、客户端端口、服务端地址、服务端端口）这样的四元组表示：</p>
<pre class="line-numbers language-none"><code class="language-none">（clientaddr:clientport, serveraddr: serverport)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-connection.png" alt="一个客户端 - 服务器之间的连接"></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-1-3-子网掩码">1.1.3 子网掩码</h4>
<p>  在网络 IP 划分的时候需要区分两个概念：</p>
<ul>
<li>
<p>网络<code>network</code>：表示这组 IP 共同的部分，比如在 <strong>192.168.1.1</strong>~<strong>192.168.1.255</strong> 这个区间里，它们共同的部分是 <strong>192.168.1.0</strong></p>
</li>
<li>
<p>主机<code>host</code>：表示这组 IP 不同的部分，上例中 1~255 就是不同的部分，表示有 255 个可用的不同 IP</p>
<blockquote>
<p>例如 IPv4 地址，<strong>192.0.2.12</strong>，前面三个 bytes 是子网，最后一个 byte 是 host，或者说 host 为 8 位，子网掩码为 <strong>192.0.2.0/24</strong>（<strong>255.255.255.0</strong>）</p>
</blockquote>
</li>
<li>
<p>网络地址位数由子网掩码<code>Netmask</code>决定，<strong>将 IP 地址与子网掩码进行位与操作，就能得到网络的值</strong></p>
</li>
<li>
<p><strong>注意</strong>：子网掩码的格式永远都是二进制格式：前面是一连串的 1，后面跟着一连串的 0</p>
<blockquote>
<p><strong>255.192.0.0</strong> 这样的子网掩码无法直观地知道有多少个 1，多少个 0，后来有了新的表示方法：<strong>IP / 网络的位数</strong><br>
如 IP <strong>192.0.2.12/30</strong>：有 30 个 1， 2 个 0，主机个数为 4</p>
</blockquote>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-1-4-保留网段和端口">1.1.4 保留网段和端口</h4>
<h5 id="保留网段">保留网段</h5>
<ul>
<li>
<p>国际标准组织在 IPv4 地址空间里面专门划出了一些网段，这些网段不会用做公网上的 IP 而是仅仅保留做内部使用，这些地址称作保留网段</p>
</li>
<li>
<p>下表是三个保留网段，用于专用网络中的本地通信</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-reserved-network-ranges.png" alt=""></p>
</li>
<li>
<p><code>255.255.255.255/32</code>：用于受限广播地址</p>
</li>
<li>
<p><code>224.0.0.0/4</code>：用于多播</p>
</li>
</ul>
<p>​</p>
<h5 id="保留端口">保留端口</h5>
<ul>
<li>
<p>保留端口就是大家约定俗成的，已经被对应服务广为使用的端口，比如 ftp 的 21 端口，ssh 的 22 端口，http 的 80 端口等</p>
</li>
<li>
<p>glibc 定义的保留端口：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Standard well-known ports.  */</span>
<span class="token keyword">enum</span>
  <span class="token punctuation">{</span>
    IPPORT_ECHO <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>    <span class="token comment">/* Echo service.  */</span>
    IPPORT_DISCARD <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span>   <span class="token comment">/* Discard transmissions service.  */</span>
    IPPORT_SYSTAT <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span>   <span class="token comment">/* System status service.  */</span>
    IPPORT_DAYTIME <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">,</span>  <span class="token comment">/* Time of day service.  */</span>
    IPPORT_NETSTAT <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span>  <span class="token comment">/* Network status service.  */</span>
    IPPORT_FTP <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">,</span>    <span class="token comment">/* File Transfer Protocol.  */</span>
    IPPORT_TELNET <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">,</span>   <span class="token comment">/* Telnet protocol.  */</span>
    IPPORT_SMTP <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span>   <span class="token comment">/* Simple Mail Transfer Protocol.  */</span>
    IPPORT_TIMESERVER <span class="token operator">=</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token comment">/* Timeserver service.  */</span>
    IPPORT_NAMESERVER <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token comment">/* Domain Name Service.  */</span>
    IPPORT_WHOIS <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">,</span>    <span class="token comment">/* Internet Whois service.  */</span>
    IPPORT_MTP <span class="token operator">=</span> <span class="token number">57</span><span class="token punctuation">,</span>
    IPPORT_TFTP <span class="token operator">=</span> <span class="token number">69</span><span class="token punctuation">,</span>   <span class="token comment">/* Trivial File Transfer Protocol.  */</span>
    IPPORT_RJE <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">,</span>
    IPPORT_FINGER <span class="token operator">=</span> <span class="token number">79</span><span class="token punctuation">,</span>   <span class="token comment">/* Finger service.  */</span>
    IPPORT_TTYLINK <span class="token operator">=</span> <span class="token number">87</span><span class="token punctuation">,</span>
    IPPORT_SUPDUP <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">,</span>   <span class="token comment">/* SUPDUP protocol.  */</span>
    IPPORT_EXECSERVER <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span>  <span class="token comment">/* execd service.  */</span>
    IPPORT_LOGINSERVER <span class="token operator">=</span> <span class="token number">513</span><span class="token punctuation">,</span> <span class="token comment">/* rlogind service.  */</span>
    IPPORT_CMDSERVER <span class="token operator">=</span> <span class="token number">514</span><span class="token punctuation">,</span>
    IPPORT_EFSSERVER <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span>
    <span class="token comment">/* UDP ports.  */</span>
    IPPORT_BIFFUDP <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span>
    IPPORT_WHOSERVER <span class="token operator">=</span> <span class="token number">513</span><span class="token punctuation">,</span>
    IPPORT_ROUTESERVER <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span>
    <span class="token comment">/* Ports less than this value are reserved for privileged processes.  */</span>
    IPPORT_RESERVED <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span>
    <span class="token comment">/* Ports greater this value are reserved for (non-privileged) servers.  */</span>
    IPPORT_USERRESERVED <span class="token operator">=</span> <span class="token number">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<h4 id="1-1-5-域名系统">1.1.5 域名系统</h4>
<ul>
<li>
<p>IP 协议的职责是<strong>网际互连</strong>，它使用 IP 地址把 MAC 编号转换成了四位数字，对物理网卡的 MAC 地址做了一层抽象，只要每个小网络在 IP 地址这个概念上达成一致，不管在 MAC 层有多大的差异，都可以接入 TCP/IP 协议栈，终汇合进整个互联网</p>
</li>
<li>
<p>但数字形式的地址对于人类来说却既难以记忆又难以输入，于是<strong>域名系统</strong><code>Domain Name System</code>出现了，用有意义的名字来作为 IP 地址的等价替代，在 IP 地址之上再进行一次抽象</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="域名的形式">域名的形式</h5>
<ul>
<li>
<p>在 DNS 中，<strong>域名</strong><code>Domain Name</code>又称为<strong>主机名</strong><code>Host</code></p>
</li>
<li>
<p>全球域名按照从大到小的结构，形成了一棵树状结构，实际访问一个域名时，是从最底层开始写起，域名用 <code>.</code> 分隔成多个单词，级别从左到右逐级升高，最右边的被称为<strong>顶级域名</strong></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210129-domain-name.png" alt=""></p>
</li>
<li>
<p>域名还有许多其他的用途：在Web服务器中，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用<code>server_name</code>指令：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    
    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>                <span class="token comment"># 监听 80 端口    </span>
    <span class="token keyword">server_name</span>  a<span class="token punctuation">.</span>test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  <span class="token comment"># 主机名是 a.test.com  </span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>域名本质上是个<strong>名字空间系统</strong>，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识，因为这个特性，域名也被扩展到了其他应用领域</p>
<ul>
<li>比如 Java 的包机制采用域名作为命名空间</li>
<li><code>XML</code> 里使用 <code>URI</code> 作为名字空间，也间接使用了域名</li>
</ul>
</li>
</ul>
<p>​</p>
<h5 id="域名的解析">域名的解析</h5>
<ul>
<li>
<p>IP 地址必须转换成 MAC 地址才能访问主机，使用 TCP/IP 协议来通信要使用 IP 地址，所以需要把域名做转换，<strong>映射</strong>到它的真实 IP，这就是域名解析</p>
</li>
<li>
<p>DNS 的核心系统是一个三层的树状分布式服务，基本对应域名的结构：</p>
<ul>
<li>
<p>根域名服务器 <code>Root DNS Server</code>：管理顶级域名服务器，返回 com、net、cn 等顶级域名服务器的 IP 地址</p>
</li>
<li>
<p>顶级域名服务器 <code>Top-level DNS Server</code>：管理各自域名下的权威域名服务器，比如  com 顶级域名服务器可以返回 <a target="_blank" rel="noopener" href="http://apple.com">apple.com</a> 域名服务器的 IP 地址</p>
</li>
<li>
<p>权威域名服务器 <code>Authoritative DNS Server</code>：管理自己域名下主机的 IP 地址，比如 <a target="_blank" rel="noopener" href="http://apple.com">apple.com</a> 权威域名服务器可以返回 <a target="_blank" rel="noopener" href="http://www.apple.com">www.apple.com</a> 的 IP 地址</p>
</li>
</ul>
</li>
<li>
<p>根域名服务器必须是众所周知的，目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到，有了这个系统以后，任何一个域名都可以在这个树形结构里<strong>从顶至下进行查询</strong>（把域名从右到左走了一遍），获得域名对应的 IP</p>
<blockquote>
<ol>
<li>目前全世界有 13 组根 DNS 服务器，因为 DNS 协议里包大小的限制（512 字节），再除以 DNS 记录长度，最多 15 组，再去掉 buffer</li>
<li>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起</li>
</ol>
</blockquote>
</li>
<li>
<p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，基本思路就是<strong>缓存</strong></p>
<ul>
<li>
<p>大公司、网络运行商都会建立自己的 DNS 服务器作为用户 DNS 查询的代理，这些服务器被称为<strong>非权威域名服务器</strong>，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址，这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方（比较知名的 DNS 有 Google 的<strong>8.8.8.8</strong>，Microsoft 的<strong>4.2.2.1</strong>，CloudFlare 的<strong>1.1.1.1</strong>）</p>
</li>
<li>
<p>操作系统里也会对 DNS 解析结果做缓存，直接在操作系统里就可以拿到 IP 地址，另外，操作系统里还有一个特殊的<strong>主机映射</strong>文件（在 Linux 里是<code>/etc/hosts</code>，在 Windows 里是<code>C:\WINDOWS\system32\drivers\etc\hosts</code>），如果操作系统在缓存里找不到 DNS 记录，就会找这个文件</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：DNS 是一个树状的分布式查询系统，为了提高查询效率，外围有多级的缓存</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210129-dns-architecture.png" alt="现在的DNS架构"></p>
</blockquote>
<p>​</p>
<h5 id="负载均衡">负载均衡</h5>
<ul>
<li>
<p>重定向，对外服务的域名不变，而主机的 IP 地址变动。当主机有情况需要下线或迁移时，可以更改 DNS 记录让域名指向其他机器。</p>
</li>
<li>
<p><strong>基于域名实现的负载均衡</strong></p>
<ul>
<li>
<p>域名解析可以返回多个 IP 地址，客户端收到多个 IP 地址后，使用轮询算法依次向服务器发起请求，实现负载均衡</p>
</li>
<li>
<p>域名解析可以配置内部的策略，返回离客户端近的主机或者当前服务质量好的主机，在 DNS 端把请求分发到不同的服务器</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="1-1-6-数据报和字节流">1.1.6 数据报和字节流</h4>
<ul>
<li>
<p>TCP又叫<strong>字节流套接字</strong><code>Stream Socket</code>，<strong>UDP</strong> 又叫<strong>数据报套接字</strong><code>Datagram Socket</code>，一般以<code>SOCK_STREAM</code>与<code>SOCK_DGRAM</code>分别表示 TCP 和 UDP 套接字，<code>Datagram Sockets</code> 有时称为无连接的 sockets<code>connectionless sockets</code></p>
</li>
<li>
<p>字节流套接字是可靠的，双向连接的通讯串流，TCP 通过诸如<strong>连接管理，拥塞控制，数据流与窗口管理，超时和重传</strong>等一系列精巧而详细的设计，提供了高质量的端到端的通信方式</p>
</li>
<li>
<p>数据报套接字也可以做到更高的可靠性，只不过这种可靠性，需要应用程序进行设计处理，比如对报文进行编号，设计 <code>Request-Ack</code> 机制，再加上重传等，在一定程度上可以达到更为高可靠的 UDP 程序</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-1-7-其他">1.1.7 其他</h4>
<p>​</p>
<p>​</p>
<h3 id="1-2-网络分层">1.2 网络分层</h3>
<h4 id="1-2-1-TCP-IP-网络分层模型">1.2.1 TCP/IP 网络分层模型</h4>
<ol>
<li>
<p>链接层<code>link layer</code>，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时也叫 <code>MAC</code> 层</p>
</li>
<li>
<p>网际层或网络互连层<code>internet layer</code>，IP 协议就处在这一层，可以在链接层的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只需要把 IP 地址翻译成 MAC 地址</p>
</li>
<li>
<p>传输层<code>transport layer</code>，这个层次协议的职责是保证数据在 IP 地址标记的两点之间可靠地传输，是 TCP 协议工作的层次</p>
</li>
<li>
<p>应用层<code>application layer</code>，有各种面向具体应用的协议（如 Telnet、SSH、FTP、SMTP、<a href="https://night-candle.github.io/2021/02/04/cs-network-protocol/#toc-heading-5">HTTP</a>）</p>
<blockquote>
<p>MAC 层的传输单位是<strong>帧</strong><code>frame</code>，IP 层的传输单位是<strong>包</strong><code>packet</code>，TCP 层的传输单位是<strong>段</strong><code>segment</code>，HTTP 的传输单位则是<strong>消息</strong>或<strong>报文</strong><code>message</code>，它们可以统称为<strong>数据包</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-tcpip.png" alt=""></p>
</li>
</ol>
<p>​</p>
<h4 id="1-2-2-OSI-网络分层模型">1.2.2 OSI 网络分层模型</h4>
<ol>
<li>
<p><strong>物理层</strong>，网络的物理形式，例如电缆、光纤、网卡、集线器等等</p>
</li>
<li>
<p><strong>数据链路层</strong>，它基本相当于 TCP/IP 的链接层</p>
</li>
<li>
<p><strong>网络层</strong>，相当于 TCP/IP 里的网际层</p>
</li>
<li>
<p><strong>传输层</strong>，相当于 TCP/IP 里的传输层</p>
</li>
<li>
<p><strong>会话层</strong>，维护网络中的连接状态，即保持会话和同步</p>
</li>
<li>
<p><strong>表示层</strong>，把数据转换为合适、可理解的语法和语义</p>
</li>
<li>
<p><strong>应用层</strong>，面向具体的应用传输数据</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-osi.png" alt=""></p>
<blockquote>
<p>常用术语：</p>
<p><strong>四层负载均衡</strong>：工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡<br>
<strong>七层负载均衡</strong>：工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器<br>
<strong>三层路由</strong>：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关<br>
<strong>二层转发</strong>：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播</p>
</blockquote>
</li>
</ol>
<p>​</p>
<h4 id="1-2-3-5层参考模型">1.2.3 5层参考模型</h4>
<ul>
<li>
<p>TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置，而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整</p>
</li>
<li>
<p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-map.png" alt="对应关系"></p>
</li>
<li>
<p>因此有了结合 OSI 和 TCP/IP 优点的 5 层参考模型</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="1-3-Socket-套接字">1.3 Socket 套接字</h3>
<h4 id="1-3-1-Socket-是什么？">1.3.1 Socket 是什么？</h4>
<ul>
<li>
<p><code>socket</code> 译为<strong>套接字</strong>， 在网络编程中寓意是可以通过插口接入的方式，快速完成网络连接和数据收发，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信</p>
<blockquote>
<p><em>To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.  Concatenated with the network and host addresses from the internet communication layer, this forms a socket.  A pair of sockets uniquely identifies each connection.</em>（RFC793）</p>
</blockquote>
</li>
<li>
<p>理解 socket</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210202-server-client.png" alt="客户端和服务器工作核心逻辑"></p>
<ul>
<li>
<p>服务器端初始化的过程：首先初始化 <code>socket</code>，之后需要执行 <code>bind</code> 函数，将自己的服务能力绑定在一个固定的地址和端口上，紧接着执行 <code>listen</code> 操作，将原先的 <code>socket</code> 转化为服务端的 <code>socket</code>，服务端最后阻塞在 <code>accept</code> 上，此时，服务器端已经准备就绪，等待客户端的请求</p>
</li>
<li>
<p>客户端需要先初始化 <code>socket</code>，再执行 <code>connect</code> 向服务器端的地址和端口发起连接请求</p>
<p>这个过程就是<strong>TCP 三次握手</strong><code>Three-way Handshake</code>，三次握手完成，客户端和服务器端建立连接，就进入了数据传输过程，<strong>一旦连接建立，数据的传输就不再是单向的，而是双向的</strong></p>
<blockquote>
<p>具体来说，客户端进程向操作系统内核发起 <code>write</code> 字节流写操作，内核协议栈将字节流通过网络设备传输到服务器端，服务器端从内核得到信息，将字节流从内核读入到进程中，并开始业务逻辑的处理，完成之后，服务器端再将得到的结果以同样的方式写给客户端</p>
</blockquote>
</li>
<li>
<p>四次挥手：当客户端交互完成需断开连接时，会执行 <code>close</code> 函数，内核此时会通过原先的连接链路向服务端发送一个 <code>FIN</code> 包，服务端收到之后执行被动关闭，这时候整个链路处于半关闭状态，此后服务端也会执行 <code>close</code> 函数，整个链路才会真正关闭，<strong>半关闭的状态下，发起 close 请求的一方在没有收到对方 FIN 包之前都认为连接是正常的</strong>，而在全关闭的状态下，双方都感知连接已经关闭</p>
</li>
<li>
<p>以上所有的操作，都是通过 <code>socket</code> 来完成的，无论是 <code>connect</code>还是 <code>accept</code>，或者 <code>read/write</code> 操作等，<strong>socket 是用来建立连接，传输数据的唯一途径</strong></p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-3-2-Socket-发展历史">1.3.2 Socket 发展历史*</h4>
<ul>
<li>
<p><code>socket</code> 是加州大学伯克利分校的研究人员在 20 世纪 80 年代早期提出的，所以也被叫做伯克利套接字，研究者们设想<strong>用 socket 的概念屏蔽掉底层协议栈的差别</strong></p>
</li>
<li>
<p>第一版实现 <code>socket</code> 的就是 <code>TCP/IP</code> 协议，最早是在 <strong>BSD 4.2 Unix 内核</strong>上实现了 socket</p>
</li>
<li>
<p>很快人们就发现这么一个概念带来了网络编程的便利，Linux 作为 Unix 系统的一个开源实现，很早就从头开发实现了 TCP/IP 协议，伴随着 socket 的成功，Windows 也引入了 socket 的概念，在今天的世界里，socket 成为网络互联互通的标准</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-3-3-套接字地址格式">1.3.3 套接字地址格式</h4>
<ul>
<li>
<p>在使用套接字时，首先要解决通信双方寻址的问题</p>
</li>
<li>
<p>下面是套接字的<strong>通用</strong>地址结构（适用于多种地址族）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* POSIX.1g 规范规定了地址族为 2 字节的值.  */</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> sa_family_t<span class="token punctuation">;</span>
<span class="token comment">/* 描述通用套接字地址  */</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token punctuation">{</span>
    sa_family_t sa_family<span class="token punctuation">;</span>  <span class="token comment">/* 地址族.  16-bit*/</span>
    <span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* 具体的地址值 112-bit */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结构体里第一个字段是<strong>地址族</strong>，表示<strong>使用什么样的方式对地址进行解释和保存</strong>，地址族在 glibc 里的定义非常多，常用的有：</p>
<ul>
<li>
<p><code>AF_LOCAL</code>：表示的是本地地址，对应的是 <code>Unix</code> 套接字，这种情况一般用于本地 <code>socket</code> 通信，很多情况下也可以写成 <code>AF_UNIX</code>、<code>AF_FILE</code></p>
</li>
<li>
<p><code>AF_INET</code>：因特网使用的 IPv4 地址</p>
</li>
<li>
<p><code>AF_INET6</code>：因特网使用的 IPv6 地址</p>
</li>
</ul>
</li>
<li>
<p><code>AF_</code> 含义是 <code>Address Family</code>，还有以 <code>PF_</code> 表示的宏，含义是 <code>Protocol Family</code>（协议族），用 AF_ 这样的值来初始化 socket 地址，用 PF_ 这样的值来初始化 socket</p>
<p>在 <code>&lt;sys/socket.h&gt;</code> 头文件中可以看到这两个值是一一对应的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 各种地址族的宏定义  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNSPEC PF_UNSPEC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_LOCAL  PF_LOCAL</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNIX   PF_UNIX</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_FILE   PF_FILE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET   PF_INET</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_AX25   PF_AX25</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_IPX    PF_IPX</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_APPLETALK  PF_APPLETALK</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_NETROM PF_NETROM</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_BRIDGE PF_BRIDGE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_ATMPVC PF_ATMPVC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_X25    PF_X25</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET6  PF_INET6</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><strong>套接字地址格式比较</strong></p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-address-family-compare.png" alt=""></p>
</li>
</ul>
<p>​</p>
<h5 id="IPv4-套接字格式地址">IPv4 套接字格式地址*</h5>
<ul>
<li>
<p>常用的 IPv4 地址族的结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* IPV4 套接字地址，32bit 值.  */</span>
<span class="token keyword">typedef</span> uint32_t in_addr_t<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">in_addr</span>
  <span class="token punctuation">{</span>
    in_addr_t s_addr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* 描述 IPV4 的套接字地址格式  */</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span>
  <span class="token punctuation">{</span>
    sa_family_t sin_family<span class="token punctuation">;</span> <span class="token comment">/* 16-bit */</span>
    in_port_t sin_port<span class="token punctuation">;</span>     <span class="token comment">/* 端口口  16-bit*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>    <span class="token comment">/* Internet address. 32-bit */</span>
    
    <span class="token comment">/* 这里仅仅用作占位符，不做实际用处  */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> sin_zero<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>sockaddr_in</code>与 <code>sockaddr</code> 一样，都有一个 16-bit 的 <code>sin_family</code> 字段，对于 IPv4 来说这个值就是 <code>AF_INET</code></li>
<li>端口号最多是 16-bit，最大支持 $2^{16}$= 65536，支持寻址的端口号最多就是 65535</li>
</ul>
</li>
<li>
<p>IPv4 地址是一个 32-bit 的字段，最多支持的地址数就是$2^{32}$，大约是 42 亿，但随着互联网发展，全球接入的设备越来越多，地址渐渐显得不太够用了</p>
</li>
</ul>
<p>​</p>
<h5 id="IPv6-套接字地址格式">IPv6 套接字地址格式*</h5>
<ul>
<li>
<p>IPv6 的地址结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in6</span>
  <span class="token punctuation">{</span>
    sa_family_t sin6_family<span class="token punctuation">;</span> <span class="token comment">/* 16-bit */</span>
    in_port_t sin6_port<span class="token punctuation">;</span>  <span class="token comment">/* 传输端口号 # 16-bit */</span>
    uint32_t sin6_flowinfo<span class="token punctuation">;</span> <span class="token comment">/* IPv6 流控信息 32-bit*/</span>
    <span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> sin6_addr<span class="token punctuation">;</span>  <span class="token comment">/* IPv6 地址 128-bit */</span>
    uint32_t sin6_scope_id<span class="token punctuation">;</span> <span class="token comment">/* IPv6 域 ID 32-bit */</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整个结构体长度是 28 个字节，地址族是 <code>AF_INET6</code>，端口同 IPv4 地址一样（其中流控信息和域 IP 这两个字段，一个在 glibc 的官网上没出现，另一个是当前未使用的字段）</p>
</li>
<li>
<p>地址从 32 位升级到 128 位，完全解决了寻址数字不够的问题</p>
</li>
</ul>
<h5 id="本地套接字地址格式">本地套接字地址格式*</h5>
<ul>
<li>
<p>本地套接字用来做为本地进程间的通信，即 <code>AF_LOCAL</code></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sun_family<span class="token punctuation">;</span> <span class="token comment">/* 固定为 AF_LOCAL */</span>
    <span class="token keyword">char</span> sun_path<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* 路径名 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>为什么本地套接字格式不需要端口号，而 IPv4 和 IPv6 套接字格式却需要端口号呢？</p>
<p><strong>一切皆文件，socket也是文件</strong>，socket基于文件操作，<strong>因此只需要根据文件路径便可区分，不需要使用端口</strong>，也正因如此，IPv4 和 IPv6 套接字地址结构的长度是固定的，而本地地址是可变的</p>
</blockquote>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="1-4-TCP-建立连接">1.4 TCP 建立连接</h3>
<h4 id="1-4-1-服务端准备连接">1.4.1 服务端准备连接</h4>
<p>​</p>
<h5 id="创建套接字">创建套接字</h5>
<ul>
<li>
<p>要创建一个可用的套接字，使用 socket 函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>domain</code> 指 <code>PF_INET</code>、<code>PF_INET6</code> 、 <code>PF_LOCAL</code> 等，表示什么样的套接字</li>
<li><code>type</code> 可用的值：</li>
<li><code>SOCK_STREAM</code>: 表示字节流，对应 <code>TCP</code></li>
<li><code>SOCK_DGRAM</code>： 表示数据报，对应 <code>UDP</code></li>
<li><code>SOCK_RAW</code>: 表示原始套接字</li>
<li><code>protocol</code> 原本是用来指定通信协议，但现在基本废弃（因为协议已经通过前面两个参数指定完成，目前一般写成 0 即可）</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="bind">bind</h5>
<p>​</p>
<ul>
<li>
<p>创建的套接字如果需要被使用，就需调用 <code>bind</code> 函数将套接字和套接字地址绑定：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> sockaddr <span class="token operator">*</span> addr<span class="token punctuation">,</span> socklen_t len<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>
<p><code>sockaddr * addr</code>通用地址格式（但实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式）</p>
</li>
<li>
<p><code>len</code> 字段表示的就是传入的地址长度，是一个可变值，bind 函数会根据 <code>len</code> 字段判断传入的参数 <code>addr</code> 该怎么解析</p>
</li>
</ul>
<blockquote>
<p>BSD 设计套接字的时候 C 语言还没有<code>void *</code>的支持，所以 BSD 的设计者们设计了通用地址格式来作为支持 <code>bind</code> 和 <code>accept</code> 等这些函数的参数，对使用者来说，每次需要将 IPv4、IPv6 或者本地套接字格式转化为通用套接字格式</p>
</blockquote>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>设置 bind 时对地址和端口可以有多种处理方式：</p>
<ul>
<li>
<p><strong>把地址设置成本机 IP 地址</strong>，相当于告诉系统内核仅对目标 IP 是本机 IP 地址的包进行处理，对部署前 IP 地址不确定的问题，可以利用<strong>通配地址</strong>的能力帮助解决，IPv4 地址使用 <code>INADDR_ANY</code> 、 IPv6使用 <code>IN6ADDR_ANY</code> 来完成通配地址的设置</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> name<span class="token punctuation">;</span>
name<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span> <span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* IPV4 通配地址 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li>
<p>如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核，操作系统内核会选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用，一般来说服务器端的程序要绑定到一个众所周知的端口上</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p>初始化 IPv4 TCP 套接字的例子</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">make_socket</span> <span class="token punctuation">(</span>uint16_t port<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> sock<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> name<span class="token punctuation">;</span>
    
  <span class="token comment">/* 创建字节流类型的 IPV4 socket. */</span>
  sock <span class="token operator">=</span> <span class="token function">socket</span> <span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>sock <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">perror</span> <span class="token punctuation">(</span><span class="token string">"socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span> <span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
  <span class="token comment">/* 绑定到 port 和 ip. */</span>
  name<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span> <span class="token comment">/* IPV4 */</span>
  name<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 指定端口 */</span>
  name<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span> <span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 通配地址 */</span>
  <span class="token comment">/* 把 IPV4 地址转换成通用地址格式，同时传递长度 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span> <span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">perror</span> <span class="token punctuation">(</span><span class="token string">"bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span> <span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> sock
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="listen">listen</h5>
<p>​</p>
<ul>
<li>
<p>初始化创建的套接字通过 listen 函数可以将原来的“主动”套接字转换为“被动”套接字，告诉操作系统内核<strong>等待用户请求</strong>，内核会为此做好接收用户请求的准备，比如完成连接队列</p>
</li>
<li>
<p><code>listen</code> 函数原型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">listen</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>socketfd</code> 为套接字描述符</li>
<li><code>backlog</code>为未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目（这个参数越大，并发数目理论上也会越大，但是参数过大也会占用过多的系统资源，一些系统如 Linux 不允许修改这个参数）</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="accept">accept</h5>
<p>​</p>
<ul>
<li>
<p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这时操作系统内核要把这个事件通知到应用程序，让应用程序感知到这个连接，<strong>accept 函数的作用就是连接建立之后，操作系统内核和应用程序之间的桥梁</strong></p>
</li>
<li>
<p>accept 函数原型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> listensockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>
<p><code>listensockfd</code> 是套接字，可以称为 listen 套接字，这就是前面通过 bind，listen 一系列操作而得到的套接字</p>
</li>
<li>
<p>返回值有两个部分，第一个部分 <code>cliadd</code> 是通过指针方式获取的客户端的地址，<code>addrlen</code> 告诉地址的大小；另一部分是函数的返回值，是一个全新的描述字，代表了与客户端的连接</p>
</li>
</ul>
</li>
<li>
<p><strong>注意</strong>：有两个套接字描述字，第一个是监听套接字描述字 <code>listensockfd</code>作为输入参数；第二个是返回的已连接套接字描述字</p>
</li>
<li>
<p><strong>监听套接字一直都存在，直到这个监听套接字关闭</strong>，一个客户和服务器连接成功，完成了 TCP 三次握手，操作系统内核就为其生成一个<strong>已连接套接字</strong>，让应用服务器使用这个已连接套接字和客户进行通信处理，如果服务器完成了对这个客户的服务，关闭的就是<strong>已连接套接字</strong>，这样就完成了 TCP 连接的释放，<strong>这时候释放的只是这一个客户连接</strong></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-4-2-客户端发起连接">1.4.2 客户端发起连接</h4>
<ul>
<li>第一步建立一个套接字，客户端调用 <code>connect</code> 向服务端发起请求</li>
</ul>
<p>​</p>
<h5 id="connect">connect</h5>
<ul>
<li>
<p>客户端和服务器端的连接建立是通过 <code>connect</code> 函数完成</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>servaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>sockfd</code> 是连接套接字，通过 <code>socket</code> 函数创建</li>
<li><code>servaddr</code> 和 <code>addrlen</code> 分别代表指向套接字地址结构的指针和该结构的大小</li>
</ul>
</li>
<li>
<p>在调用 <code>connect</code> 前不是必须调用 <code>bind</code> 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口</p>
</li>
<li>
<p>如果是 TCP 套接字，那么调用 <code>connect</code> 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回</p>
</li>
<li>
<p><strong>补充</strong>：出错返回可能有以下几种情况，根据不同的返回值可以做进一步的排查</p>
<ul>
<li>
<p>三次握手无法建立，客户端发出的 <code>SYN</code> 包没有任何响应，返回 <code>TIMEOUT</code> 错误，比较常见的原因是对应的服务端 IP 写错</p>
</li>
<li>
<p>客户端收到了 <code>RST</code>（复位）回答，这时候客户端会立即返回 <code>CONNECTION REFUSED</code> 错误，这种情况比较常见于客户端发送连接请求时的请求端口写错</p>
<blockquote>
<p>产生 RST 条件</p>
<ol>
<li>
<p>目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器</p>
</li>
<li>
<p>TCP 想取消一个已有连接</p>
</li>
<li>
<p>TCP 接收到一个根本不存在的连接上的分节</p>
</li>
</ol>
</blockquote>
</li>
<li>
<p>客户发出的 SYN 包在网络上引起了<code>destination unreachable</code>，目的不可达的错误，常见的原因是客户端和服务器端路由不通</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-4-3-TCP-三次握手">1.4.3 TCP 三次握手</h4>
<ul>
<li>
<p>TCP 三次握手过程</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210206-three-way-handshake.png" alt="TCP 三次握手"></p>
<p>（这里使用的网络编程模型是阻塞式的，调用发起后不会直接返回，由操作系统内核处理之后才会返回）</p>
<blockquote>
<p>信道不可靠，但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论在消息中包含什么信息，三次通信是理论上的最小值</p>
</blockquote>
</li>
<li>
<p>服务端通过 <code>socket</code>、<code>bind</code> 和 <code>listen</code> 完成了被动套接字的准备工作，然后调用 <code>accept</code>，就会阻塞在这里，等待客户端的连接</p>
</li>
<li>
<p>客户端通过 <code>socket</code> 和 <code>connect</code> 函数调用之后也会阻塞，接下来是<strong>内核网络协议栈</strong>工作，具体过程：</p>
<ul>
<li>
<p>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 <code>j</code>，客户端进入 <code>SYNC_SENT</code> 状态</p>
</li>
<li>
<p>服务器端的协议栈收到包之后进行 ACK 应答，应答值为 <code>j+1</code>，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 <code>k</code>，服务器端进入 <code>SYNC_RCVD</code> 状态</p>
</li>
<li>
<p>客户端协议栈收到 ACK 之后，应用程序从 <code>connect</code> 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 <code>ESTABLISHED</code>，同时客户端协议栈也会对 SYN 包进行应答，应答数据为 <code>k+1</code></p>
</li>
<li>
<p>应答包到达服务器端后，服务器端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 <code>ESTABLISHED</code> 状态</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-TCP-Socket-读写">1.5 TCP Socket 读写</h3>
<h4 id="1-5-1-发送数据">1.5.1 发送数据</h4>
<ul>
<li>
<p>发送数据时常用的有三个函数 <code>write</code>、<code>send</code> 和 <code>sendmsg</code>，每个函数使用的场景略有不同</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">write</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
ssize_t <span class="token function">send</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
ssize_t <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>write 函数是常见的文件写函数，如果把 <code>socketfd</code> 换成文件描述符，就是普通的文件写入</li>
<li>send 函数是想指定选项，发送带外数据时使用，<strong>带外数据</strong>是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理</li>
<li>sendmsg 是想<strong>指定多重缓冲区传输数据</strong>时使用，以结构体 <code>msghdr</code> 的方式发送数据</li>
</ul>
</li>
<li>
<p>在套接字描述符上调用 <code>write</code> 函数，和在普通文件描述符上调用 <code>write</code> 函数两者的表现形式是一样（都是通过描述符句柄写入指定的数据），但内在的区别不一样</p>
<ul>
<li>
<p>对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流，此时写入的字节流大小通常和输入参数 size 的值是相同的</p>
</li>
<li>
<p>对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的，内核为读取和发送数据做了很多表面上看不到的工作</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-5-2-发送缓冲区">1.5.2 发送缓冲区</h4>
<ul>
<li>
<p>当 TCP 三次握手成功，连接建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区</p>
</li>
<li>
<p>当应用程序调用 <code>write</code> 函数时，实际所做的事情是把数据<strong>从应用程序中拷贝到操作系统内核的发送缓冲区中</strong>，并不一定是把数据通过套接字写出去</p>
<ul>
<li>
<p>操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小</p>
</li>
<li>
<p>操作系统内核的发送缓冲区够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，应用程序被阻塞，大部分 UNIX 系统会一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210225-send-buffer.png" alt=""></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-5-3-读取数据">1.5.3 读取数据</h4>
<ul>
<li>
<p>read 函数原型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">read</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>函数要求操作系统内核从套接字描述字 <code>socketfd</code> 读取最多多少个字节（size），并将结果存储到 buffer 中</li>
<li>返回值告诉我们实际读取的字节数目，也有一些特殊情况
<ul>
<li>如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况</li>
<li>如果返回值为 -1，表示出错</li>
<li>如果是非阻塞 I/O，情况会略有不同</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从 socketfd 描述字中读取 "size" 个字节. */</span>
ssize_t <span class="token function">readn</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>vptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    size_t  nleft<span class="token punctuation">;</span>
    ssize_t nread<span class="token punctuation">;</span>
    <span class="token keyword">char</span>    <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
 
    ptr <span class="token operator">=</span> vptr<span class="token punctuation">;</span>
    nleft <span class="token operator">=</span> size<span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nleft <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> nleft<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
                nread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">/* 非阻塞 I/O 的情况下，没有数据可以读，需要再次调用 read */</span>
            <span class="token keyword">else</span>
                <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment">/* EOF(End of File) 表示套接字关闭 */</span>
        nleft <span class="token operator">-=</span> nread<span class="token punctuation">;</span>
        ptr   <span class="token operator">+=</span> nread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span>n <span class="token operator">-</span> nleft<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 返回的是实际读取的字节数 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>可不可以无限增大缓冲区</strong>，这样不就可以提高应用程序的吞吐量了么？</p>
<p>不行，write 函数发送数据只是将数据发送到内核缓冲区，而什么时候发送由内核决定，内核缓冲区总是充满数据时会产生<strong>粘包</strong>问题，同时网络的传输大小 MTU 也会限制每次发送的大小，最后由于数据堵塞需要消耗大量内存资源，资源使用效率不高</p>
</blockquote>
<blockquote>
<p>一段数据流从应用程序发送端，一直到应用程序接收端，总共经过了多少次拷贝？</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-copy.png" alt=""></p>
</blockquote>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="实验">实验</h4>
<ul>
<li>
<p>一个客户端 - 服务器的例子，其中客户端不断地发送数据，服务器端每读取一段数据之后进行休眠</p>
</li>
<li>
<p><em>tcp_server.c</em>：服务器端读取数据程序</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span>

<span class="token keyword">void</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ssize_t n<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"block in read\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 每次读取 1K 数据之后休眠 1 秒</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">readn</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        time<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"1K read for %d \n"</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
    socklen_t clilen<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>

    listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/* bind到本地地址，端口为12345 */</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* listen的backlog为1024 */</span>
    <span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/* 循环处理用户请求 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">/* 获取实际的连接 */</span>
        <span class="token function">read_data</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 读取数据 */</span>
        <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">/* 关闭连接套接字，注意不是监听套接字*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p><em>tcp_client.c</em>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">MESSAGE_SIZE <span class="token number">102400</span></span></span>

<span class="token keyword">void</span> <span class="token function">send_data</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化一个长度为 MESSAGE_SIZE 的字符串流</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>query<span class="token punctuation">;</span>
    query <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MESSAGE_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MESSAGE_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        query<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    query<span class="token punctuation">[</span>MESSAGE_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span>
    cp <span class="token operator">=</span> query<span class="token punctuation">;</span>
    size_t remaining <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>remaining<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n_written <span class="token operator">=</span> <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> cp<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"send into buffer %ld \n"</span><span class="token punctuation">,</span> n_written<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n_written <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"send failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        remaining <span class="token operator">-=</span> n_written<span class="token punctuation">;</span>
        cp <span class="token operator">+=</span> n_written<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: tcpclient &lt;IPaddress&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> connect_rt <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 向服务器端发起连接请求</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>connect_rt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"connect failed "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">send_data</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//调用 send_data 发送数据</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>编译运行：</p>
<p><img src="20210225-194139734.png" alt="client"></p>
<p><img src="20210225-194214472.png" alt="server"></p>
<ul>
<li>
<p>程序运行后，服务端不断地在屏幕上打印出读取字节流的过程</p>
</li>
<li>
<p>客户端直到最后所有的字节流发送完毕才打印出“send into buffer”，说明在此之前 send 函数一直都是阻塞的，也就是说阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的</p>
</li>
<li>
<p>如果把服务端的休眠时间稍微调大，客户端打印完后服务端还在屏幕上不断打印读取数据的进度，说明发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="1-6-UDP-编程">1.6 UDP 编程</h3>
<ul>
<li>
<p>TCP和UDP相比有什么差异呢？</p>
<ul>
<li>
<p>UDP 是一种<strong>数据报</strong>协议，而 TCP 是一种面向连接的<strong>数据流</strong>协议</p>
</li>
<li>
<p>TCP 在 IP 报文的基础上，增加了诸如<strong>重传、确认、有序传输、拥塞控制</strong>等能力，通信的双方是在一个确定的上下文中工作的，而 UDP 没有这样一个确定的上下文，是一个不可靠的通信协议，没有重传、确认、有序控制、拥塞控制，也不保证报文的有效传递和有序</p>
</li>
</ul>
</li>
<li>
<p>UDP 程序设计时的主要过程</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210225-udp.png" alt=""></p>
<ul>
<li>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 <code>recvfrom</code> 函数等待客户端的报文发送</li>
<li>客户端创建套接字之后，调用 <code>sendto</code> 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="主要函数">主要函数</h4>
<h5 id="recvfrom">recvfrom</h5>
<ul>
<li>
<p>函数原型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
 
ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> 
　　　　　　　　　　<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>sockfd</code> 是本地创建的套接字描述符</p>
</li>
<li>
<p><code>buff</code> 指向本地的缓存</p>
</li>
<li>
<p><code>nbytes</code> 表示最大接收数据字节</p>
</li>
<li>
<p><code>flags</code> 是和 I/O 相关的参数</p>
</li>
<li>
<p><code>from</code> 和 <code>addrlen</code>，实际上是返回对端发送方的地址和端口等信息</p>
</li>
<li>
<p>函数返回值告诉我们实际接收的字节数</p>
</li>
</ul>
<blockquote>
<p>和 TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息不一样，UDP 报文每次接收都会获取对端的信息，报文和报文之间是没有上下文的</p>
</blockquote>
</li>
</ul>
<p>​</p>
<h5 id="sendto">sendto</h5>
<ul>
<li>
<p>原型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
 
ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>sockfd</code> 是本地创建的套接字描述符</p>
</li>
<li>
<p><code>buff</code> 指向发送的缓存</p>
</li>
<li>
<p><code>nbytes</code> 表示发送字节数</p>
</li>
<li>
<p><code>to</code> 和 <code>addrlen</code>表示发送的对端地址和端口等信息</p>
</li>
<li>
<p>函数的返回值告诉实际接收的字节数</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="实验-2">实验</h4>
<ul>
<li>
<p><em>udp_server.c</em>：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span>
 
<span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
 
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">recvfrom_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nreceived %d datagrams\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>
    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_addr<span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    server_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    server_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    server_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    socklen_t client_len<span class="token punctuation">;</span>
    <span class="token keyword">char</span> message<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> recvfrom_int<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 信号处理响应“Ctrl+C”退出时打印出收到的报文总数</span>
    
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_addr<span class="token punctuation">;</span>
    client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取客户端发送的报文，加上“Hi”前缀发送给客户端</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> message<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        message<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received %d bytes: %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<ul>
<li>
<p><em>udp_client.c</em>：从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span>
 
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span>    <span class="token expression">MAXLINE     <span class="token number">4096</span></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: udpclient &lt;IPaddress&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>
    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_addr<span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    server_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    server_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    socklen_t server_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>reply_addr<span class="token punctuation">;</span>
    reply_addr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> recv_line<span class="token punctuation">[</span>MAXLINE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    socklen_t len<span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending %s\n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size_t rt <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"send failed "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send bytes: %zu \n"</span><span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> recv_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> reply_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"recvfrom failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        recv_line<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span>recv_line<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>运行</p>
<ul>
<li>
<p>场景一：只运行客户端</p>
<p><img src="20210329-101753391.png" alt=""></p>
<p>只运行客户端，程序会一直阻塞在 <code>recvfrom</code> 上</p>
</li>
<li>
<p>场景二：先开启服务端，再开启客户端</p>
<p><img src="20210329-105644830.png" alt=""></p>
</li>
<li>
<p>场景三: 开启服务端，再一次开启两个客户端</p>
<p><img src="20210329-200937835.png" alt="server"></p>
<p><img src="20210329-201010812.png" alt="client"></p>
<p>两个客户端发送的报文依次被服务端收到，客户端也可以收到服务端处理之后的报文，如果此时把服务器端进程杀死，可以看到打印出服务器端接收到的报文个数</p>
<p>之后再重启服务器端进程，并使用客户端 1 和客户端 2 继续发送新的报文，服务器端可以继续收到客户端的报文（说明 UDP 报文无上下文）</p>
</li>
</ul>
<blockquote>
<p>在第一个场景中 <code>recvfrom</code> 一直处于阻塞状态中，这是非常不合理的，这种情形应该怎么处理呢？</p>
<p>一直阻塞会导致程序无法正常退出，可以使用接收超时、IO多路复用的<strong>超时机制</strong></p>
</blockquote>
<blockquote>
<p>UDP 是请求 - 应答模式的，那么请求中的 <strong>UDP 报文最大</strong>可以是多大呢？</p>
<p>IP和UDP头中都有16bit的长度字段，最长65535字节，去掉头部长度得到UDP数据净荷长度：65535-20-8=65507字节</p>
</blockquote>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="1-7-本地套接字">1.7 本地套接字</h3>
<p>​</p>
<p>​</p>
<h4 id="1-7-0-示例">1.7.0 示例</h4>
<ul>
<li>
<p>实际上本地套接字是 IPC 的一种实现方式，因为本地套接字开发便捷，接受度高，普遍适用于在同一台主机上进程间通信的各种场景</p>
</li>
<li>
<p>比如 Kubernetes 的 <strong>CRI</strong> <code>Container Runtime Interface</code>，其思想是将 Kubernetes 的主要逻辑和 Container Runtime 的实现解耦</p>
</li>
<li>
<p>kubelet 是 Kubernetes 的一个组件，负责将控制器和调度器的命令转化为单机上的容器实例，为了实现和容器运行时的解耦，kubelet 设计了基于本地套接字的客户端 - 服务器 GRPC 调用，在路径为 <em>/var/run/dockershim.socket</em> 的 stream 类型的本地套接字上可以看到开启这个套接字的进程为 kubelet（还有 docker-containerd.sock 等其他本地套接字）</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210330-kubelet.png" alt=""></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-7-1-本地套接字概述">1.7.1 本地套接字概述</h4>
<ul>
<li>本地套接字也叫做 UNIX 域套接字，是一种特殊类型的套接字，本地套接字提供了一种<strong>单主机跨进程间调用的手段</strong>，减少了协议栈实现的复杂度，效率更高</li>
<li>类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等</li>
<li>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="1-7-2-本地字节流套接字">1.7.2 本地字节流套接字</h4>
<ul>
<li>
<p>示例：服务器程序打开本地套接字后，接收客户端发送来的字节流，并往客户端回送了新的字节流</p>
</li>
<li>
<p>服务端</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixstreamserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>
    socklen_t clilen<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>
 
    listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>listenfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 创建一个本地地址</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// unlink 把存在的文件删除以保持幂等性</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 设置本地文件路径</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"listen failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"accept failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* back to for() */</span>
        <span class="token keyword">else</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"accept failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 read 和 write 从套接字中按照字节流的方式读取和发送数据</span>
        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">int</span> nbytes <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"write error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>本地字节流套接字识别服务器不再通过 IP 地址和端口，而是通过本地文件</li>
<li>本地文件路径应该是绝对路径，这样的话编写好的程序可以在任何目录里被启动和管理，如果是相对路径，这个程序的启动路径就必须固定，对程序的管理反而是一个很大的负担</li>
<li>如果文件不存在，bind 时会自动创建这个文件</li>
</ul>
</li>
<li>
<p>客户端</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixstreamclient &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>
 
    sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sockfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"create socket failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// sun_path 初始化，表示目标文件路径</span>
 
    <span class="token comment">// 发起对目标套接字的 connect 调用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"connect failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 从标准输入中读取字符串</span>
    <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> recv_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
        <span class="token keyword">int</span> nbytes <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向服务器端发送</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"write error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> recv_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"server terminated prematurely"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token function">fputs</span><span class="token punctuation">(</span>recv_line<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>运行</p>
<ul>
<li>
<p>只启动客户端</p>
<ul>
<li>客户端直接报错，提示没有文件存在</li>
</ul>
</li>
<li>
<p>服务器端监听在无权限的文件路径上</p>
<ul>
<li>启动服务器端程序的用户，必须对本地监听路径有权限</li>
</ul>
</li>
<li>
<p>服务器和客户端正常启动</p>
<p><img src="20220505-201747616.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h4 id="1-7-3-本地数据报套接字">1.7.3 本地数据报套接字</h4>
<ul>
<li>
<p>服务端</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixdataserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>
    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> client_addr<span class="token punctuation">;</span>
    socklen_t client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用 recvfrom 和 sendto 来进行数据报的收发</span>
        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s \n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        size_t nbytes <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending: %s \n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"sendto error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">close</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>客户端</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixdataserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>
    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 指定一个本地路径，以便在服务器端回包时可以正确地找到地址</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> client_addr<span class="token punctuation">;</span>
    socklen_t client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s \n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        size_t nbytes <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending: %s \n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>
            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"sendto error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token function">close</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>运行</p>
<p><img src="20220505-202723787.png" alt=""></p>
</li>
</ul>
<h3 id="工具使用">工具使用</h3>
<h4 id="ping">ping</h4>
<ul>
<li>
<p>ping 命名来自于声呐探测，在网络上用来完成对网连通性的探测</p>
</li>
<li>
<p>ping 基于<a href="">ICMP协议</a>（网际控制协议）开发</p>
</li>
<li>
<p>例：使用 ping 探测和新浪网的网络连通性</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-ping.png" alt=""></p>
<ul>
<li>每次显示是按照 sequence 序列号排序</li>
<li>显示了 <strong>TTL</strong>，反映两个 IP 地址之间传输的时间</li>
<li>还显示了 ping 命令的统计信息，如最小时间、平均时间等</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="ifconfig">ifconfig</h4>
<ul>
<li>
<p>用来显示当前系统中的所有网络设备（网卡列表）</p>
</li>
<li>
<p>示例</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-ifconfig.png" alt=""></p>
<ul>
<li>
<p>第一行：<code>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</code>：网络设备的状态标识</p>
<ul>
<li>UP：网卡开启状态</li>
<li>BROADCAST：网卡有广播地址，可发送广播</li>
<li>RUNNING：网线处于连接状态</li>
<li>MULTICAST：表示网卡可以发送多播包</li>
</ul>
<p><code>mtu 1500</code>：最大传输单元 MTU 为 1500，表示的是链路层包的大小，这是以太网的默认值，规定连 MAC 头带正文合起来，不允许超过 1500 个字节，<strong>如果放不下就需要分片来传输</strong></p>
</li>
<li>
<p>第二行：<code>inet 192.168.121.143  netmask 255.255.255.0  broadcast 192.168.121.255</code>：网卡的IP地址、子网掩码、广播地址</p>
</li>
<li>
<p>第三行：IPV6配置信息</p>
</li>
<li>
<p>第四行：<code>ether 52:00:74:f8:9f:56  txqueuelen 0  (Ethernet)</code>：网卡的MAC地址</p>
<ul>
<li>
<p><code>ether</code>：连接类型为以太网</p>
</li>
<li>
<p><code>txqueuelen</code>：传输队列的长度</p>
</li>
</ul>
</li>
<li>
<p>第五六行：网卡接受数据包的统计信息和接受错误的统计信息</p>
</li>
<li>
<p>第七八行：网卡发送数据包的统计信息和发送错误的统计信息</p>
</li>
</ul>
</li>
<li>
<p><a href="https://night-candle.github.io/2021/02/04/cs-network-protocol/#toc-heading-36">ip addr命令</a></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="netstat">netstat</h4>
<ul>
<li>
<p>netstat（network statistics）是在内核中访问网络连接状态及其相关信息的命令行程序，可以显示路由表、实际的网络连接和网络接口设备的状态信息，以及与 IP、TCP、UDP、ICMP 协议相关的统计数据，一般用于检验本机各端口的网络服务运行状况</p>
</li>
<li>
<p>命令选项</p>
<ul>
<li><em>-a</em>：列出 TCP、UDP 和 Unix 协议下所有套接字的所有连接</li>
<li><em>-t</em>：列出 TCP 协议的连接，可和 <em>-a</em>选项配合使用</li>
<li><em>-u</em>：列出 UDP 协议的连接</li>
<li><em>-n</em>：禁用反向域名解析，加快查询速度，用户 ID 和端口号也优先使用数字显示</li>
<li><em>-l</em>：只列出正在监听的连接（不能和 <em>-a</em> 选项同时使用）</li>
<li><em>-p</em>：查看进程信息
<ul>
<li><em>-pe</em>：同时查看进程名和进程所属的用户名</li>
</ul>
</li>
<li><em>-s</em>：输出针对不同网络协议的统计信息</li>
</ul>
</li>
<li>
<p>当前所有的连接详情</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">netstat <span class="token operator">-</span>apen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="lsof">lsof</h4>
<ul>
<li>
<p>常见用途之一是找出在指定的 IP 地址或者端口上打开套接字的进程</p>
</li>
<li>
<p>Isof 和 netstst 可以结合使用</p>
</li>
<li>
<p>lsof 可以找出正在使用该端口的进程，从而帮助定位问题</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">lsof <span class="token operator">-</span>i <span class="token operator">:</span><span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="tcpdump">tcpdump</h4>
<ul>
<li>
<p>抓包工具，具有非常强大的过滤和匹配功能</p>
</li>
<li>
<p>在开启抓包时 tcpdump 会自动创建一个类型为 AF_PACKET 的网络套接口，并向系统内核注册，当网卡接收到一个网络报文之后，会遍历系统中所有已经被注册的网络协议，内核接下来就会将网卡收到的报文发送给该协议的回调函数进行处理，回调函数可以把接收到的报文复制一份交给 tcpdump 程序，进行各种条件的过滤和判断后对报文进行解析输出</p>
</li>
<li>
<p>命令选项</p>
<ul>
<li><em>-D</em>：列出可用于抓包的接口</li>
<li><em>-i</em>：指定监听的网卡，<code>-i any</code> 显示所有网卡</li>
<li><em>-c</em>：指定要抓取的包数量</li>
<li><em>-nn</em>：不做主机名解析，且端口显示为数值</li>
<li><em>-w</em>：将抓包数据输出到文件中而不是标准输出，可以同时配合*-G time*选项使得输出文件每 time 秒就自动切换到另一个文件（保存成 cap 格式配合 wireshark）</li>
<li><em>-r</em>：从给定数据包文件中读取数据，使用<code>-</code>表示从标准输入中读取</li>
</ul>
</li>
<li>
<p>tcpdump 表达式：用于筛选输出</p>
<ul>
<li>
<p>表达式由一个或多个单元组成，每个单元一般包含 ID 的修饰符和一个 ID（数字或名称）</p>
</li>
<li>
<p>有三种修饰符</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-tcpdump-filter.jpg" style="zoom: 50%;">
<ul>
<li>
<p>proto：可选有 ip、arp、rarp、tcp、udp、icmp、ether 等，默认是所有协议的包</p>
</li>
<li>
<p>dir：可选有 src、dst、src or dst、src and dst，默认为 src or dst</p>
</li>
<li>
<p>type：可选有 host、net、port、portrange，默认为 host</p>
</li>
</ul>
</li>
<li>
<p>表达式单元之间可以使用操作符 <code>and / &amp;&amp; / or / || / not / !</code> 进行连接，从而组成复杂的条件表达式</p>
</li>
<li>
<p>在表达式中出现的 shell 元字符建议使用单引号包围</p>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>查看 TCP，且端口是 80，来自 IP 地址为 192.168.1.25 的包</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token string">'tcp and port 80 and src host 192.168.1.25'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>
<p>查看 TCP，设置了 SYN 分节的且端口是 80 的包</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">tcpdump <span class="token string">'tcp and port 80 and tcp[13:1]&amp;2 != 0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>tcp[13:1]</code> 表示的是 TCP 头部开始处偏移为 13 的字节，如果这个值为 2，说明设置了 SYN 分节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输出格式</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-tcpdump-output.jpg" alt=""></p>
<ul>
<li>
<p><code>Flags [ ]</code> 是包的标志，比较常见的包格式如下：</p>
<ul>
<li><code>[S]</code>：SYN，表示开始连接</li>
<li><code>[.]</code>：没有标记，一般是确认</li>
<li><code>[P]</code>：PSH，表示数据推送</li>
<li><code>[F]</code>：FIN，表示结束连接</li>
<li><code>[R]</code>：RST，表示重启连接</li>
</ul>
</li>
<li>
<p>seq：包序号，就是 TCP 的确认分组</p>
</li>
<li>
<p>cksum：校验码</p>
</li>
<li>
<p>win：滑动窗口大小</p>
</li>
<li>
<p>length：载荷的长度</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="02-网络编程进阶">02 | 网络编程进阶</h2>
<h3 id="2-1-TIME-WAIT">2.1 TIME_WAIT</h3>
<ul>
<li>场景引入：应用服务需要通过发起 TCP 连接对外提供服务，在高并发情况下，TIME_WAIT 状态的连接过多，把本机可用的端口耗尽，应用服务对外表现为不能正常工作，一段时间后处于 TIME_WAIT 的连接被系统回收并关闭后，释放出本地端口，应用服务对外表现为可以正常工作</li>
</ul>
<h4 id="TCP-四次挥手">TCP 四次挥手</h4>
<ul>
<li>
<p>TCP 四次挥手过程</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-four-time-wave.png" alt=""></p>
<ul>
<li>主动关闭方 TCP 发送 FIN 包，表示需要关闭连接，之后主动关闭方进入 FIN_WAIT_1 状态</li>
<li>收到 FIN 包的对端执行被动关闭，进入 <code>CLOSE_WAIT</code> 状态，并发送一个 ACK 应答
<ul>
<li>TCP 协议栈为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包</li>
</ul>
</li>
<li>read 调用获得 EOF，并将此结果通知应用程序调用 close 关闭它的套接字，也发送一个 FIN 包，被动关闭方将进入 <code>LAST_ACK</code> 状态</li>
<li>主动关闭方接收到对方的 FIN 包，并确认这个 FIN 包，主动关闭方进入 <code>TIME_WAIT</code> 状态，而接收到 ACK 的被动关闭方则进入 <code>CLOSED</code> 状态</li>
<li>经过 2MSL 时间之后，主动关闭方也进入 <code>CLOSED</code> 状态</li>
<li>注意：
<ul>
<li><strong>只有发起连接终止的一方会进入 TIME_WAIT 状态</strong></li>
<li>中间使用 <a href="#shutdown">shutdown</a>，执行一端到另一端的半关闭也是可以的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大多数真实情况是客户端执行主动关闭，HTTP/1.0 却是由服务器发起主动关闭的</p>
</li>
<li>
<p>主机在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximum segment lifetime）的两倍，一般称之为 2MSL，时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的，如果在 TIME_WAIT 时间内又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时（目的是为了让旧连接的所有报文都能自然消亡）</p>
</li>
<li>
<p>Linux 里有一个硬编码的字段 <code>TCP_TIMEWAIT_LEN</code> 值为 60 秒，Linux 停留在 TIME_WAIT 的时间为固定的 60 秒</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TCP_TIMEWAIT_LEN</span> <span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span>HZ<span class="token punctuation">)</span> </span><span class="token comment">/* how long to wait to destroy TIME-        WAIT state, about 60 seconds	*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="TIME-WAIT-的作用">TIME_WAIT 的作用</h4>
<ul>
<li>
<p><strong>为了确保最后的 ACK 能让被动关闭方接收从而帮助其正常关闭</strong></p>
<ul>
<li>比如主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文，处于 TIME_WAIT 状态的主机 1 可以在接收到 FIN 报文之后，重新发出一个 ACK 报文</li>
<li>如果没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误</li>
</ul>
</li>
<li>
<p><strong>为了让旧连接的重复分节在网络中自然消失</strong></p>
<ul>
<li>如果迷走报文到达时，发现 TCP 连接四元组所代表的连接不存在，报文自然丢弃，但在原连接中断后，可能又重新创建了一个和原连接四元组完全相同的“化身”，到达的迷走报文会被误认为是连接“化身”的一个 TCP 分节，就会对 TCP 通信产生影响</li>
<li>经过 2MSL 时间足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组都是新化身所产生的</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="TIME-WAIT-的危害">TIME_WAIT 的危害</h4>
<ul>
<li>
<p>内存资源占用，但不是太严重，基本可以忽略</p>
</li>
<li>
<p>端口资源占用，一个 TCP 连接至少消耗一个本地端口，一般可以开启的端口为 32768～61000 ，也可通过 <code>net.ipv4.ip_local_port_range</code> 指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接</p>
</li>
</ul>
<h4 id="如何优化-TIME-WAIT">如何优化 TIME_WAIT</h4>
<ul>
<li>
<p>net.ipv4.tcp_max_tw_buckets（不推荐使用）</p>
<ul>
<li>值默认为 18000</li>
<li>通过 sysctl 命令将系统值调小，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息，但是这个方法暴力且治标不治本</li>
</ul>
</li>
<li>
<p>调低 <code>TCP_TIMEWAIT_LEN</code>，重新编译系统</p>
</li>
<li>
<p><code>SO_LINGER</code> 设置（危险行为，不提倡）</p>
<ul>
<li>
<p>通过设置套接字选项，来设置调用 close 或者 shutdown 关闭连接时的行为</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>optval<span class="token punctuation">,</span> socklen_t optlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">--</span><span class="token operator">-</span>

<span class="token keyword">struct</span> <span class="token class-name">linger</span> <span class="token punctuation">{</span>
　<span class="token keyword">int</span>　 l_onoff<span class="token punctuation">;</span>　　　　<span class="token comment">/* 0=off, nonzero=on */</span>
　<span class="token keyword">int</span>　 l_linger<span class="token punctuation">;</span>　　　　<span class="token comment">/* linger time, POSIX specifies units as seconds */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>如果<code>l_onoff</code>为 0，那么关闭本选项，<code>l_linger</code>的值被忽略</p>
<ul>
<li>对应了默认行为，close 或 shutdown 立即返回</li>
<li>如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去</li>
</ul>
</li>
<li>
<p>如果<code>l_onoff</code>不为 0， 且<code>l_linger</code>值也为 0</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linger</span> so_linger<span class="token punctuation">;</span>
so_linger<span class="token punctuation">.</span>l_onoff <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
so_linger<span class="token punctuation">.</span>l_linger <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_LINGER<span class="token punctuation">,</span> <span class="token operator">&amp;</span>so_linger<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>so_linger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>调用 close 后，会立该发送一个 RST 给对端，该 TCP 连接将<strong>跳过四次挥手</strong>直接关闭，这种关闭的方式称为强行关闭</p>
</li>
<li>
<p>在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开，只有当被动关闭方接受到 RST 时，会得到一个 connet reset by peer 异常</p>
</li>
</ul>
</li>
<li>
<p>如果<code>l_onoff</code>不为 0， 且<code>l_linger</code>的值也不为 0，那么调用 close 后，调用 close 的线程就将阻塞，直到数据被发送出去，或者设置的<code>l_linger</code>计时时间到</p>
</li>
</ul>
</li>
<li>
<p><code>net.ipv4.tcp_tw_reuse</code>：更安全的设置</p>
<ul>
<li>
<p><strong>从协议角度理解如果是安全可控的</strong>，可以<strong>复用</strong>处于 TIME_WAIT 的套接字为新的连接所用</p>
</li>
<li>
<p>从协议角度理解的安全可控：</p>
<ul>
<li>只适用于连接发起方（C/S 模型中的客户端）</li>
<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用</li>
</ul>
</li>
<li>
<p>前提：需要打开对 TCP 时间戳的支持，即 <code>net.ipv4.tcp_timestamps=1</code>（默认即为 1）</p>
<ul>
<li>RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳</li>
<li>由于引入了时间戳，重复数据包会因为时间戳过期被自然丢弃</li>
</ul>
</li>
<li>
<p>注意：要慎用，因为打开了时间戳的支持，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="2-2-优雅关闭连接">2.2 优雅关闭连接</h3>
<ul>
<li>服务器端优雅地关闭连接：绝大数情况下，TCP 连接都是先关闭一个方向，此时另一个方向还可以正常进行数据传输，服务端完成一些操作并将结果通过套接字写给客户端后，才有条不紊地关闭剩下的半个连接</li>
<li>如果服务器端处理不好，就会导致最后的关闭过程是粗暴的，可能服务器端处理完的信息没办法正常传送给客户端，破坏了用户侧的使用场景</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="close">close</h4>
<ul>
<li>
<p>函数原型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>若成功则为 0，若出错则为 -1</li>
<li>函数会对<strong>套接字引用计数</strong> -1，一旦发现套接字引用计数到 0，就会对套接字进行彻底释放，并且会关闭<strong>TCP 两个方向的数据流</strong>
<ul>
<li>套接字引用计数：因为套接字可以被多个进程共享，如果通过 fork 的方式产生子进程，计数 +1， 如果调用一次 close 函数，计数 -1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>close 函数是如何关闭两个方向的数据流呢？</p>
<ul>
<li>在输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常</li>
<li>在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常</li>
<li>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文</li>
</ul>
</li>
<li>
<p>close 函数并不能关闭连接的一个方向</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="shutdown">shutdown</h4>
<ul>
<li>
<p>函数原型：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> howto<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>
<p>若成功则为 0，若出错则为 -1</p>
</li>
<li>
<p><code>howto</code> 的设置有三个主要选项：</p>
<ul>
<li>
<p><code>SHUT_RD(0)</code>：关闭连接的读方向，对该套接字进行读操作直接返回 EOF，从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃</p>
</li>
<li>
<p><code>SHUT_WR(1)</code>：关闭连接的写方向（不管套接字引用计数的值是多少），这就是常被称为<strong>半关闭</strong>的连接，套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端，应用程序如果对该套接字进行写操作会报错</p>
</li>
<li>
<p><code>SHUT_RDWR(2)</code>：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用 <code>SHUT_RDWR</code> 来调用 shutdown 和 close 的差别</p>
<ul>
<li>
<p>close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源</p>
</li>
<li>
<p>close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响</p>
</li>
<li>
<p>close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文</p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="实验-3">实验</h4>
<ul>
<li>
<p>客户端程序，从标准输入不断接收用户输入，把输入的字符串通过套接字发送给服务器端，同时将服务器端的应答显示到标准输出上</p>
<p>如果用户输入了 close，则会调用 close 函数关闭连接，休眠一段时间，等待服务器端处理后退出；如果用户输入了 shutdown，调用 shutdown 函数关闭连接的写方向，并继续等待服务器端的应答，直到服务器端完成自己的操作，在另一个方向上完成关闭</p>
</li>
<li>
<p>服务端打印出接收的字节，并重新格式化后，发送给客户端</p>
</li>
<li>
<p>运行</p>
<ul>
<li>
<p>close</p>
<p><img src="20220508-171352582.png" alt=""></p>
<ul>
<li>
<p>客户端依次发送了 data1 和 data2，服务器端也正常接收到 data1 和 data2，在客户端 close 掉整个连接之后，服务器端接收到 SIGPIPE 信号，直接退出，客户端没有收到服务端的应答数据</p>
</li>
<li>
<p>在 RST 的套接字进行写操作，会直接触发 SIGPIPE 信号</p>
</li>
<li>
<p>可以注册一个信号处理函数对 SIGPIPE 信号进行处理，避免程序莫名退出</p>
</li>
</ul>
<p><img src="20220508-170216734.png" alt=""></p>
</li>
<li>
<p>shutdown</p>
<p><img src="20220508-172244925.png" alt=""></p>
<ul>
<li>
<p>客户端和服务器端各自完成了自己的工作后，正常退出</p>
</li>
<li>
<p>客户端调用 shutdown 函数只是关闭连接的一个方向，服务器端到客户端的这个方向还可以继续进行数据的发送和接收</p>
</li>
<li>
<p>当服务器端读到 EOF 时，立即向客户端发送了 FIN 报文，客户端在 read 函数中感知了 EOF，也进行了正常退出</p>
</li>
</ul>
</li>
<li>
<p>时序图</p>
<p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220508-close-and-shutdown.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<p>​</p>
<h3 id="2-3-检测连接状态">2.3 检测连接状态</h3>
<h4 id="TCP-Keep-Alive">TCP Keep-Alive</h4>
<ul>
<li>
<p>客户端突然崩溃，服务器端可能在几天内都维护着一个无用的 TCP 连接</p>
</li>
<li>
<p>TCP 有一个保持活跃的机制 <strong>Keep-Alive</strong></p>
<ul>
<li>
<p>原理：定义一个时间段，在这个时间段内如果没有任何连接相关的活动，TCP 保活机制就会每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p>
</li>
<li>
<p>上述可定义变量分别被称为<strong>保活时间、保活时间间隔和保活探测次数</strong></p>
</li>
<li>
<p>在 Linux 中这些变量分别对应 sysctl 变量 <code>net.ipv4.tcp_keepalive_time</code>、<code>net.ipv4.tcp_keepalive_intvl</code>、<code>net.ipv4.tcp_keepalve_probes</code></p>
<ul>
<li>默认设置是 7200 秒（2 小时）、75 秒和 9 次探测</li>
<li>最少需要经过 2 小时 11 分 15 秒才可以发现一个已死亡的连接，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的</li>
</ul>
</li>
<li>
<p>TCP Keep-Alive 机制默认是关闭的，可以分别在连接的两个方向上开启，也可以单独在一个方向上开启</p>
<ul>
<li>如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；</li>
<li>开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果开启了 TCP Keep-Alive，需要考虑以下情况：</p>
<ul>
<li>对端程序是正常工作的：当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来</li>
<li>对端程序崩溃并重启：当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置</li>
<li>对端程序崩溃，或对端由于其他原因导致报文不可达：当 TCP 保活的探测报文发送给对端后，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡</li>
</ul>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="应用层探活">应用层探活</h4>
<ul>
<li>可以在应用程序中<strong>模拟</strong> TCP Keep-Alive 机制来完成在应用层的连接探活</li>
<li>可以设计一个 PING-PONG 的机制，需要保活的一方在保活时间达到后，发起对连接的 PING 操作，如果服务器端对 PING 操作有回应，则重新设置保活时间，否则对探测次数进行计数，如果最终探测次数达到了保活探测次数预先设置的值之后，则认为连接已经无效</li>
</ul>
<h5 id="示例">示例</h5>
<blockquote>
<p>完成一个这样的设计，关键：</p>
<ol>
<li>需要使用定时器，可以通过使用 I/O 复用自身的机制实现</li>
<li>需要设计一个 PING-PONG 的协议</li>
</ol>
</blockquote>
<ul>
<li>
<p>消息格式设计</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    u_int32_t type<span class="token punctuation">;</span>
    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> messageObject<span class="token punctuation">;</span>
 
<span class="token comment">// 四种消息类型</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_PING          <span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_PONG          <span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_TYPE1        <span class="token number">11</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_TYPE2        <span class="token number">21</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>客户端程序设计：在保活时间达到后，探活次数增加 1，同时向服务器端发送 PING 格式的消息，此后以预设的保活时间间隔，不断地向服务器端发送 PING 格式的消息，如果能收到服务器端的应答，则结束保活，将保活时间置为 0</p>
</li>
<li>
<p>服务器端程序设计：接收客户端发送来的各种消息后，进行处理，其中如果发现是 PING 类型的消息，在休眠一段时间后回复一个 PONG 消息</p>
</li>
</ul>
<h5 id="实验-4">实验</h5>
<ul>
<li>
<p>服务器端休眠时间为 60 秒：客户端在发送了三次心跳检测报文 PING 报文后，判断出连接无效，直接退出</p>
<p><img src="20220511-001036123.png" alt=""></p>
</li>
<li>
<p>服务器端休眠时间为 5 秒</p>
<p><img src="20220511-001221123.png" alt=""></p>
</li>
</ul>
<h3 id="2-4-TCP-动态数据传输">2.4 TCP 动态数据传输</h3>
<ul>
<li>在任何一个时刻里，TCP 发送缓冲区的数据是否能真正发送出去，决定的因素有发送窗口大小、拥塞窗口大小等</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="流量控制">流量控制</h4>
<ul>
<li>
<p>TCP 为应用程序提供了流量控制服务（flow control service）以消除发送方使接收方缓存溢岀的可能性，流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配</p>
</li>
<li>
<p><strong>发送窗口用来控制发送和接收端的流量</strong></p>
</li>
<li>
<p>发送窗口和接收窗口的本质：TCP 的生产者 - 消费者”模型，发送窗口和接收窗口是 TCP 连接的双方，一个作为生产者，一个作为消费者，为了达到一致协同的生产 - 消费速率、而产生的算法模型实现</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="拥塞控制">拥塞控制</h4>
<ul>
<li>
<p>流量控制只是在考虑单个连接的数据传递，但是 TCP 数据包需要经过网卡、交换机、核心路由器等一系列网络设备，设备本身的能力也是有限的，当多个连接的数据包同时在网络上传送时，势必会发生带宽争抢、数据丢失等，TCP 必须考虑<strong>多个连接共享在有限的带宽上，兼顾效率和公平性的控制</strong>，这就是拥塞控制的本质</p>
</li>
<li>
<p>在 TCP 协议中，拥塞控制是通过拥塞窗口来完成的，拥塞窗口的大小会随着网络状况实时调整</p>
</li>
<li>
<p>拥塞控制常用的算法有<strong>慢启动</strong>，通过一定的规则慢慢地将网络发送数据的速率增加到一个阈值，超过阈值后，进入<strong>拥塞避免</strong>阶段，这个阶段 TCP 会不断地探测网络状况，并随之不断调整拥塞窗口的大小</p>
</li>
<li>
<p>发送窗口反应了作为单 TCP 连接、点对点之间的流量控制模型，它是需要和接收端一起共同协调来调整大小的；而拥塞窗口则是反应了作为多个 TCP 连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整的</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="其他因素">其他因素</h4>
<h5 id="糊涂窗口综合症">糊涂窗口综合症</h5>
<ul>
<li>场景：接收端处理得急不可待，如刚读入 100 个字节就告诉发送端继续发送</li>
<li>在接收端进行优化，接收端不能在接收缓冲区空出一个很小的部分之后，就向发送端发送窗口更新通知，而是需要在自己的缓冲区大到一个合理的值之后，再向发送端发送窗口更新通知</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="Nagle-算法">Nagle 算法</h5>
<ul>
<li>场景：使用 SSH 和远程的服务器交互，在屏幕上敲打了一个命令，等待服务器返回结果，这个过程需要不断和服务器端进行数据传输，但每次传输的数据可能都非常小（这就好比每次叫了一辆大货车只送了一个小水壶）</li>
<li>在发送端进行优化，优化的算法叫做 <code>Nagle</code> 算法</li>
<li><code>Nagle</code> 算法的本质其实就是<strong>限制大批量的小数据包同时发送</strong>，在任何一个时刻，未被确认的小数据包（长度小于最大报文段长度 MSS 的 TCP 分组）不能超过一个，这样发送端就可以把接下来连续的几个小数据包存储起来，等待接收到前一个小数据包的 ACK 分组之后，再将数据一次性发送出去</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="延时-ACK">延时 ACK</h5>
<ul>
<li>场景：接收端需要对每个接收到的 TCP 分组进行确认，但是 ACK 报文本身是不带数据的分段，如果一直发送大量的 ACK 报文，就会消耗大量的带宽</li>
<li>在接收端进行优化，这个优化的算法叫做<strong>延时 ACK</strong>，在收到数据后并不马上回复，而是累计需要发送的 ACK 报文，等到有数据需要发送给对端时，将累计的 ACK 一并发送</li>
<li>延时 ACK 机制不能无限地延时下去，否则发送端误认为数据包没有发送成功，引起重传，反而会占用额外的网络带宽</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="禁用-Nagle-算法">禁用 Nagle 算法</h5>
<ul>
<li>
<p>Nagle 算法和延时 ACK 的组合，会增大处理时延，两个优化彼此在阻止对方，在有些情况下 Nagle 算法并不适用， 比如对时延敏感的应用</p>
<img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220511-delayack-nagle.png" style="zoom: 67%;">
</li>
<li>
<p>可以通过对套接字的修改来关闭 Nagle 算法</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">,</span> TCP_NODELAY<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>on<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>注意</strong>：除非有十足的把握，否则不要轻易改变默认的 TCP Nagle 算法，因为在现代操作系统中，针对 Nagle 算法和延时 ACK 的优化已经非常成熟了，有可能在禁用 Nagle 算法之后，性能问题反而更加严重</p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h5 id="将写操作合并">将写操作合并</h5>
<ul>
<li>
<p>如果能将一个请求一次性发送过去，而不是分开两部分独立发送，结果会好很多，可以在写数据之前，将数据合并到缓冲区再批量发送</p>
</li>
<li>
<p>可使用如下方法进行数据读写操作，从而避免 Nagle 算法引发的副作用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token operator">*</span>iov_base<span class="token punctuation">;</span> <span class="token comment">/* starting address of buffer */</span>
size_t　iov_len<span class="token punctuation">;</span> <span class="token comment">/* size of buffer */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ssize_t <span class="token function">writev</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span>
ssize_t <span class="token function">readv</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>实验</p>
<p><img src="20220515-003659162.png" alt=""></p>
</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="2-5-快速重启">2.5 快速重启</h3>
<p>服务器端程序重启时，地址被占用的原因和解决方法</p>
<h3 id="2-7-如何理解-TCP-流">2.7 如何理解 TCP 流</h3>
<p>2.5 UDP Connect</p>
<p>​</p>
<h2 id="03-网络编程实战">03 | 网络编程实战</h2>
<blockquote>
<p>未完待续</p>
<p>最后一次更新：2022.05.05</p>
</blockquote>
<p>编程语言的I/O模型是通过抽象和设计，总结出的一套规范。</p>
<h2 id="参考-2">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80">保留IP地址</a></li>
<li><a target="_blank" rel="noopener" href="https://shuangxunian.github.io/2021/06/13/TCPInterviewQuestions/">TCP面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://jaminzhang.github.io/dns/The-Reason-of-There-Is-Only-13-DNS-Root-Servers/">只有 13 台 DNS 根域名服务器原因</a></li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">宵烛</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://night-candle.github.io/2021/02/04/cs-network-socket/">http://night-candle.github.io/2021/02/04/cs-network-socket/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">宵烛</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                                    <span class="chip bg-color">网络协议</span>
                                </a>
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
                                    <span class="chip bg-color">网络编程</span>
                                </a>
                            
                                <a href="/tags/socket/">
                                    <span class="chip bg-color">socket</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="google,qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/11/19/linux-kernel/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/24.jpg" class="responsive-img" alt="Linux 内核开发">
                        
                        <span class="card-title">Linux 内核开发</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-19
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AC%94%E8%AE%B0/" class="post-category">
                                    笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/02/04/cs-network-protocol/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/27.jpg" class="responsive-img" alt="网络协议基础入门">
                        
                        <span class="card-title">网络协议基础入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本文自顶而下、由业务到逻辑讲解网络协议相关知识，并分析如何在当下热门领域使用这些协议，如云计算、容器和微服务
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-02-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%A7%91/" class="post-category">
                                    计科
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
                        <span class="chip bg-color">网络协议</span>
                    </a>
                    
                    <a href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">
                        <span class="chip bg-color">云计算</span>
                    </a>
                    
                    <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">
                        <span class="chip bg-color">微服务</span>
                    </a>
                    
                    <a href="/tags/%E5%AE%B9%E5%99%A8/">
                        <span class="chip bg-color">容器</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('200')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 宵烛 Blog<br />'
            + '文章作者: 宵烛<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">宵烛</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">95.4k</span>
            
            
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/night-candle" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1219303301@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1219303301" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1219303301" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
